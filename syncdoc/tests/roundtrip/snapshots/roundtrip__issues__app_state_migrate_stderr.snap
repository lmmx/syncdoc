---
source: syncdoc/tests/roundtrip/issues.rs
expression: result.migrate_stderr
---
[SYNCDOC DEBUG] get_docs_path called:
[SYNCDOC DEBUG]   source_file: src
[SYNCDOC DEBUG]   manifest_dir: /tmp/.tmpXXXXXX
[SYNCDOC DEBUG]   docs_path from toml: docs
[SYNCDOC DEBUG]   manifest_path (canonical): /tmp/.tmpXXXXXX
[SYNCDOC DEBUG]   source_dir (canonical): /tmp/.tmpXXXXXX
[SYNCDOC DEBUG]   relative_path (stripped): 
[SYNCDOC DEBUG]   depth: 0
[SYNCDOC DEBUG]   final result: docs
[SYNCDOC DEBUG] Processing item type: Other
[SYNCDOC DEBUG] Processing item: Other(Ident { sym: use, span: bytes(475..478) })
[SYNCDOC DEBUG] Processing item type: Other
[SYNCDOC DEBUG] Processing item: Other(Ident { sym: crate, span: bytes(479..484) })
[SYNCDOC DEBUG] Processing item type: Other
[SYNCDOC DEBUG] Processing item: Other(Punct { char: ':', spacing: Joint, span: bytes(484..485) })
[SYNCDOC DEBUG] Processing item type: Other
[SYNCDOC DEBUG] Processing item: Other(Punct { char: ':', spacing: Alone, span: bytes(485..486) })
[SYNCDOC DEBUG] Processing item type: Other
[SYNCDOC DEBUG] Processing item: Other(Ident { sym: edit_plan, span: bytes(486..495) })
[SYNCDOC DEBUG] Processing item type: Other
[SYNCDOC DEBUG] Processing item: Other(Punct { char: ':', spacing: Joint, span: bytes(495..496) })
[SYNCDOC DEBUG] Processing item type: Other
[SYNCDOC DEBUG] Processing item: Other(Punct { char: ':', spacing: Alone, span: bytes(496..497) })
[SYNCDOC DEBUG] Processing item type: Other
[SYNCDOC DEBUG] Processing item: Other(Group { delimiter: Brace, stream: TokenStream [Ident { sym: Edit, span: bytes(498..502) }, Punct { char: ',', spacing: Alone, span: bytes(502..503) }, Ident { sym: EditPlan, span: bytes(504..512) }], span: bytes(497..513) })
[SYNCDOC DEBUG] Processing item type: Other
[SYNCDOC DEBUG] Processing item: Other(Punct { char: ';', spacing: Alone, span: bytes(513..514) })
[SYNCDOC DEBUG] Processing item type: Other
[SYNCDOC DEBUG] Processing item: Other(Ident { sym: use, span: bytes(515..518) })
[SYNCDOC DEBUG] Processing item type: Other
[SYNCDOC DEBUG] Processing item: Other(Ident { sym: crate, span: bytes(519..524) })
[SYNCDOC DEBUG] Processing item type: Other
[SYNCDOC DEBUG] Processing item: Other(Punct { char: ':', spacing: Joint, span: bytes(524..525) })
[SYNCDOC DEBUG] Processing item type: Other
[SYNCDOC DEBUG] Processing item: Other(Punct { char: ':', spacing: Alone, span: bytes(525..526) })
[SYNCDOC DEBUG] Processing item type: Other
[SYNCDOC DEBUG] Processing item: Other(Ident { sym: formats, span: bytes(526..533) })
[SYNCDOC DEBUG] Processing item type: Other
[SYNCDOC DEBUG] Processing item: Other(Punct { char: ':', spacing: Joint, span: bytes(533..534) })
[SYNCDOC DEBUG] Processing item type: Other
[SYNCDOC DEBUG] Processing item: Other(Punct { char: ':', spacing: Alone, span: bytes(534..535) })
[SYNCDOC DEBUG] Processing item type: Other
[SYNCDOC DEBUG] Processing item: Other(Ident { sym: markdown, span: bytes(535..543) })
[SYNCDOC DEBUG] Processing item type: Other
[SYNCDOC DEBUG] Processing item: Other(Punct { char: ':', spacing: Joint, span: bytes(543..544) })
[SYNCDOC DEBUG] Processing item type: Other
[SYNCDOC DEBUG] Processing item: Other(Punct { char: ':', spacing: Alone, span: bytes(544..545) })
[SYNCDOC DEBUG] Processing item type: Other
[SYNCDOC DEBUG] Processing item: Other(Ident { sym: MarkdownFormat, span: bytes(545..559) })
[SYNCDOC DEBUG] Processing item type: Other
[SYNCDOC DEBUG] Processing item: Other(Punct { char: ';', spacing: Alone, span: bytes(559..560) })
[SYNCDOC DEBUG] Processing item type: Other
[SYNCDOC DEBUG] Processing item: Other(Ident { sym: use, span: bytes(561..564) })
[SYNCDOC DEBUG] Processing item type: Other
[SYNCDOC DEBUG] Processing item: Other(Ident { sym: crate, span: bytes(565..570) })
[SYNCDOC DEBUG] Processing item type: Other
[SYNCDOC DEBUG] Processing item: Other(Punct { char: ':', spacing: Joint, span: bytes(570..571) })
[SYNCDOC DEBUG] Processing item type: Other
[SYNCDOC DEBUG] Processing item: Other(Punct { char: ':', spacing: Alone, span: bytes(571..572) })
[SYNCDOC DEBUG] Processing item type: Other
[SYNCDOC DEBUG] Processing item: Other(Ident { sym: input, span: bytes(572..577) })
[SYNCDOC DEBUG] Processing item type: Other
[SYNCDOC DEBUG] Processing item: Other(Punct { char: ';', spacing: Alone, span: bytes(577..578) })
[SYNCDOC DEBUG] Processing item type: Other
[SYNCDOC DEBUG] Processing item: Other(Ident { sym: use, span: bytes(579..582) })
[SYNCDOC DEBUG] Processing item type: Other
[SYNCDOC DEBUG] Processing item: Other(Ident { sym: crate, span: bytes(583..588) })
[SYNCDOC DEBUG] Processing item type: Other
[SYNCDOC DEBUG] Processing item: Other(Punct { char: ':', spacing: Joint, span: bytes(588..589) })
[SYNCDOC DEBUG] Processing item type: Other
[SYNCDOC DEBUG] Processing item: Other(Punct { char: ':', spacing: Alone, span: bytes(589..590) })
[SYNCDOC DEBUG] Processing item type: Other
[SYNCDOC DEBUG] Processing item: Other(Ident { sym: section, span: bytes(590..597) })
[SYNCDOC DEBUG] Processing item type: Other
[SYNCDOC DEBUG] Processing item: Other(Punct { char: ':', spacing: Joint, span: bytes(597..598) })
[SYNCDOC DEBUG] Processing item type: Other
[SYNCDOC DEBUG] Processing item: Other(Punct { char: ':', spacing: Alone, span: bytes(598..599) })
[SYNCDOC DEBUG] Processing item type: Other
[SYNCDOC DEBUG] Processing item: Other(Ident { sym: ChunkType, span: bytes(599..608) })
[SYNCDOC DEBUG] Processing item type: Other
[SYNCDOC DEBUG] Processing item: Other(Punct { char: ';', spacing: Alone, span: bytes(608..609) })
[SYNCDOC DEBUG] Processing item type: Other
[SYNCDOC DEBUG] Processing item: Other(Ident { sym: use, span: bytes(610..613) })
[SYNCDOC DEBUG] Processing item type: Other
[SYNCDOC DEBUG] Processing item: Other(Ident { sym: crate, span: bytes(614..619) })
[SYNCDOC DEBUG] Processing item type: Other
[SYNCDOC DEBUG] Processing item: Other(Punct { char: ':', spacing: Joint, span: bytes(619..620) })
[SYNCDOC DEBUG] Processing item type: Other
[SYNCDOC DEBUG] Processing item: Other(Punct { char: ':', spacing: Alone, span: bytes(620..621) })
[SYNCDOC DEBUG] Processing item type: Other
[SYNCDOC DEBUG] Processing item: Other(Ident { sym: section, span: bytes(621..628) })
[SYNCDOC DEBUG] Processing item type: Other
[SYNCDOC DEBUG] Processing item: Other(Punct { char: ':', spacing: Joint, span: bytes(628..629) })
[SYNCDOC DEBUG] Processing item type: Other
[SYNCDOC DEBUG] Processing item: Other(Punct { char: ':', spacing: Alone, span: bytes(629..630) })
[SYNCDOC DEBUG] Processing item type: Other
[SYNCDOC DEBUG] Processing item: Other(Group { delimiter: Brace, stream: TokenStream [Ident { sym: Section, span: bytes(631..638) }, Punct { char: ',', spacing: Alone, span: bytes(638..639) }, Ident { sym: TreeNode, span: bytes(640..648) }], span: bytes(630..649) })
[SYNCDOC DEBUG] Processing item type: Other
[SYNCDOC DEBUG] Processing item: Other(Punct { char: ';', spacing: Alone, span: bytes(649..650) })
[SYNCDOC DEBUG] Processing item type: Other
[SYNCDOC DEBUG] Processing item: Other(Ident { sym: use, span: bytes(651..654) })
[SYNCDOC DEBUG] Processing item type: Other
[SYNCDOC DEBUG] Processing item: Other(Ident { sym: edtui, span: bytes(655..660) })
[SYNCDOC DEBUG] Processing item type: Other
[SYNCDOC DEBUG] Processing item: Other(Punct { char: ':', spacing: Joint, span: bytes(660..661) })
[SYNCDOC DEBUG] Processing item type: Other
[SYNCDOC DEBUG] Processing item: Other(Punct { char: ':', spacing: Alone, span: bytes(661..662) })
[SYNCDOC DEBUG] Processing item type: Other
[SYNCDOC DEBUG] Processing item: Other(Group { delimiter: Brace, stream: TokenStream [Ident { sym: EditorState, span: bytes(663..674) }, Punct { char: ',', spacing: Alone, span: bytes(674..675) }, Ident { sym: Lines, span: bytes(676..681) }], span: bytes(662..682) })
[SYNCDOC DEBUG] Processing item type: Other
[SYNCDOC DEBUG] Processing item: Other(Punct { char: ';', spacing: Alone, span: bytes(682..683) })
[SYNCDOC DEBUG] Processing item type: Other
[SYNCDOC DEBUG] Processing item: Other(Ident { sym: use, span: bytes(684..687) })
[SYNCDOC DEBUG] Processing item type: Other
[SYNCDOC DEBUG] Processing item: Other(Ident { sym: std, span: bytes(688..691) })
[SYNCDOC DEBUG] Processing item type: Other
[SYNCDOC DEBUG] Processing item: Other(Punct { char: ':', spacing: Joint, span: bytes(691..692) })
[SYNCDOC DEBUG] Processing item type: Other
[SYNCDOC DEBUG] Processing item: Other(Punct { char: ':', spacing: Alone, span: bytes(692..693) })
[SYNCDOC DEBUG] Processing item type: Other
[SYNCDOC DEBUG] Processing item: Other(Ident { sym: collections, span: bytes(693..704) })
[SYNCDOC DEBUG] Processing item type: Other
[SYNCDOC DEBUG] Processing item: Other(Punct { char: ':', spacing: Joint, span: bytes(704..705) })
[SYNCDOC DEBUG] Processing item type: Other
[SYNCDOC DEBUG] Processing item: Other(Punct { char: ':', spacing: Alone, span: bytes(705..706) })
[SYNCDOC DEBUG] Processing item type: Other
[SYNCDOC DEBUG] Processing item: Other(Ident { sym: HashMap, span: bytes(706..713) })
[SYNCDOC DEBUG] Processing item type: Other
[SYNCDOC DEBUG] Processing item: Other(Punct { char: ';', spacing: Alone, span: bytes(713..714) })
[SYNCDOC DEBUG] Processing item type: Other
[SYNCDOC DEBUG] Processing item: Other(Ident { sym: use, span: bytes(715..718) })
[SYNCDOC DEBUG] Processing item type: Other
[SYNCDOC DEBUG] Processing item: Other(Ident { sym: std, span: bytes(719..722) })
[SYNCDOC DEBUG] Processing item type: Other
[SYNCDOC DEBUG] Processing item: Other(Punct { char: ':', spacing: Joint, span: bytes(722..723) })
[SYNCDOC DEBUG] Processing item type: Other
[SYNCDOC DEBUG] Processing item: Other(Punct { char: ':', spacing: Alone, span: bytes(723..724) })
[SYNCDOC DEBUG] Processing item type: Other
[SYNCDOC DEBUG] Processing item: Other(Ident { sym: path, span: bytes(724..728) })
[SYNCDOC DEBUG] Processing item type: Other
[SYNCDOC DEBUG] Processing item: Other(Punct { char: ':', spacing: Joint, span: bytes(728..729) })
[SYNCDOC DEBUG] Processing item type: Other
[SYNCDOC DEBUG] Processing item: Other(Punct { char: ':', spacing: Alone, span: bytes(729..730) })
[SYNCDOC DEBUG] Processing item type: Other
[SYNCDOC DEBUG] Processing item: Other(Ident { sym: PathBuf, span: bytes(730..737) })
[SYNCDOC DEBUG] Processing item type: Other
[SYNCDOC DEBUG] Processing item: Other(Punct { char: ';', spacing: Alone, span: bytes(737..738) })
[SYNCDOC DEBUG] Processing item type: Other
[SYNCDOC DEBUG] Processing item: Other(Ident { sym: use, span: bytes(739..742) })
[SYNCDOC DEBUG] Processing item type: Other
[SYNCDOC DEBUG] Processing item: Other(Ident { sym: std, span: bytes(743..746) })
[SYNCDOC DEBUG] Processing item type: Other
[SYNCDOC DEBUG] Processing item: Other(Punct { char: ':', spacing: Joint, span: bytes(746..747) })
[SYNCDOC DEBUG] Processing item type: Other
[SYNCDOC DEBUG] Processing item: Other(Punct { char: ':', spacing: Alone, span: bytes(747..748) })
[SYNCDOC DEBUG] Processing item type: Other
[SYNCDOC DEBUG] Processing item: Other(Group { delimiter: Brace, stream: TokenStream [Ident { sym: fs, span: bytes(749..751) }, Punct { char: ',', spacing: Alone, span: bytes(751..752) }, Ident { sym: io, span: bytes(753..755) }], span: bytes(748..756) })
[SYNCDOC DEBUG] Processing item type: Other
[SYNCDOC DEBUG] Processing item: Other(Punct { char: ';', spacing: Alone, span: bytes(756..757) })
[SYNCDOC DEBUG] Processing item type: Enum
[SYNCDOC DEBUG] Processing item: Enum(EnumSig { attributes: Some(Repeats<1, 18446744073709551615, syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing>([Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: doc, span: bytes(759..831) }, Punct { char: '=', spacing: Alone, span: bytes(759..831) }, Literal { lit: " Determines navigation scope and quit behavior based on project size.", span: bytes(759..831) }], span: bytes(759..831) }) }, delimiter: Some(Nothing) }, Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: derive, span: bytes(834..840) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: PartialEq, span: bytes(841..850) }], span: bytes(840..851) }], span: bytes(833..852) }) }, delimiter: Some(Nothing) }])), visibility: Some(Public(KPub(Cached<proc_macro2::Ident> { value: Ident { sym: pub, span: bytes(853..856) }, string: "pub" }))), _enum: KEnum(Cached<proc_macro2::Ident> { value: Ident { sym: enum, span: bytes(857..861) }, string: "enum" }), name: Ident { sym: FileMode, span: bytes(862..870) }, generics: None, where_clause: None, variants: BraceGroupContaining < core::option::Option<unsynn::container::DelimitedVec<syncdoc_core::parse::EnumVariant, unsynn::operator::Operator<','>>>>(Some(DelimitedVec<syncdoc_core::parse::EnumVariant, unsynn::operator::Operator<','>>([Delimited<syncdoc_core::parse::EnumVariant, unsynn::operator::Operator<','>> { value: EnumVariant { attributes: Some(Repeats<1, 18446744073709551615, syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing>([Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: doc, span: bytes(877..922) }, Punct { char: '=', spacing: Alone, span: bytes(877..922) }, Literal { lit: " Single-file mode quits directly to shell.", span: bytes(877..922) }], span: bytes(877..922) }) }, delimiter: Some(Nothing) }])), name: Ident { sym: Single, span: bytes(927..933) }, data: None }, delimiter: Some(Operator<','>) }, Delimited<syncdoc_core::parse::EnumVariant, unsynn::operator::Operator<','>> { value: EnumVariant { attributes: Some(Repeats<1, 18446744073709551615, syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing>([Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: doc, span: bytes(939..988) }, Punct { char: '=', spacing: Alone, span: bytes(939..988) }, Literal { lit: " Multi-file mode shows file tree in list view.", span: bytes(939..988) }], span: bytes(939..988) }) }, delimiter: Some(Nothing) }])), name: Ident { sym: Multi, span: bytes(993..998) }, data: None }, delimiter: Some(Operator<','>) }]))) })
[SYNCDOC DEBUG] Processing item type: Enum
[SYNCDOC DEBUG] Processing item: Enum(EnumSig { attributes: Some(Repeats<1, 18446744073709551615, syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing>([Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: doc, span: bytes(1003..1062) }, Punct { char: '=', spacing: Alone, span: bytes(1003..1062) }, Literal { lit: " Tracks the lifecycle of a section reordering operation.", span: bytes(1003..1062) }], span: bytes(1003..1062) }) }, delimiter: Some(Nothing) }, Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: derive, span: bytes(1065..1071) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: Clone, span: bytes(1072..1077) }, Punct { char: ',', spacing: Alone, span: bytes(1077..1078) }, Ident { sym: PartialEq, span: bytes(1079..1088) }, Punct { char: ',', spacing: Alone, span: bytes(1088..1089) }, Ident { sym: Debug, span: bytes(1090..1095) }], span: bytes(1071..1096) }], span: bytes(1064..1097) }) }, delimiter: Some(Nothing) }])), visibility: Some(Public(KPub(Cached<proc_macro2::Ident> { value: Ident { sym: pub, span: bytes(1098..1101) }, string: "pub" }))), _enum: KEnum(Cached<proc_macro2::Ident> { value: Ident { sym: enum, span: bytes(1102..1106) }, string: "enum" }), name: Ident { sym: MoveState, span: bytes(1107..1116) }, generics: None, where_clause: None, variants: BraceGroupContaining < core::option::Option<unsynn::container::DelimitedVec<syncdoc_core::parse::EnumVariant, unsynn::operator::Operator<','>>>>(Some(DelimitedVec<syncdoc_core::parse::EnumVariant, unsynn::operator::Operator<','>>([Delimited<syncdoc_core::parse::EnumVariant, unsynn::operator::Operator<','>> { value: EnumVariant { attributes: Some(Repeats<1, 18446744073709551615, syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing>([Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: doc, span: bytes(1123..1177) }, Punct { char: '=', spacing: Alone, span: bytes(1123..1177) }, Literal { lit: " No section is being moved; normal navigation mode.", span: bytes(1123..1177) }], span: bytes(1123..1177) }) }, delimiter: Some(Nothing) }])), name: Ident { sym: None, span: bytes(1182..1186) }, data: None }, delimiter: Some(Operator<','>) }, Delimited<syncdoc_core::parse::EnumVariant, unsynn::operator::Operator<','>> { value: EnumVariant { attributes: Some(Repeats<1, 18446744073709551615, syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing>([Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: doc, span: bytes(1192..1259) }, Punct { char: '=', spacing: Alone, span: bytes(1192..1259) }, Literal { lit: " A section has been selected for moving but no changes made yet.", span: bytes(1192..1259) }], span: bytes(1192..1259) }) }, delimiter: Some(Nothing) }])), name: Ident { sym: Selected, span: bytes(1264..1272) }, data: None }, delimiter: Some(Operator<','>) }, Delimited<syncdoc_core::parse::EnumVariant, unsynn::operator::Operator<','>> { value: EnumVariant { attributes: Some(Repeats<1, 18446744073709551615, syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing>([Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: doc, span: bytes(1278..1350) }, Punct { char: '=', spacing: Alone, span: bytes(1278..1350) }, Literal { lit: " Section has been repositioned but changes not yet persisted to disk.", span: bytes(1278..1350) }], span: bytes(1278..1350) }) }, delimiter: Some(Nothing) }])), name: Ident { sym: Moved, span: bytes(1355..1360) }, data: None }, delimiter: Some(Operator<','>) }]))) })
[SYNCDOC DEBUG] Processing item type: Struct
[SYNCDOC DEBUG] Processing item: Struct(StructSig { attributes: Some(Repeats<1, 18446744073709551615, syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing>([Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: doc, span: bytes(1365..1449) }, Punct { char: '=', spacing: Alone, span: bytes(1365..1449) }, Literal { lit: " Bridges document sections and the interactive editor, maintaining session state.", span: bytes(1365..1449) }], span: bytes(1365..1449) }) }, delimiter: Some(Nothing) }])), visibility: Some(Public(KPub(Cached<proc_macro2::Ident> { value: Ident { sym: pub, span: bytes(1450..1453) }, string: "pub" }))), _struct: KStruct(Cached<proc_macro2::Ident> { value: Ident { sym: struct, span: bytes(1454..1460) }, string: "struct" }), name: Ident { sym: AppState, span: bytes(1461..1469) }, generics: None, where_clause: None, body: Named(BraceGroupContaining < core::option::Option<unsynn::container::DelimitedVec<syncdoc_core::parse::StructField, unsynn::operator::Operator<','>>>>(Some(DelimitedVec<syncdoc_core::parse::StructField, unsynn::operator::Operator<','>>([Delimited<syncdoc_core::parse::StructField, unsynn::operator::Operator<','>> { value: StructField { attributes: Some(Repeats<1, 18446744073709551615, syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing>([Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: doc, span: bytes(1476..1520) }, Punct { char: '=', spacing: Alone, span: bytes(1476..1520) }, Literal { lit: " All parsed sections across loaded files.", span: bytes(1476..1520) }], span: bytes(1476..1520) }) }, delimiter: Some(Nothing) }])), visibility: Some(Public(KPub(Cached<proc_macro2::Ident> { value: Ident { sym: pub, span: bytes(1525..1528) }, string: "pub" }))), name: Ident { sym: sections, span: bytes(1529..1537) }, _colon: Operator<':'>, field_type: Repeats<1, 18446744073709551615, unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::combinator::Either<unsynn::operator::Operator<','>, unsynn::group::BraceGroup>>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing>([Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::combinator::Either<unsynn::operator::Operator<','>, unsynn::group::BraceGroup>>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::combinator::Either<unsynn::operator::Operator<','>, unsynn::group::BraceGroup>>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::combinator::Either<unsynn::operator::Operator<','>, unsynn::group::BraceGroup>>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Ident { sym: Vec, span: bytes(1539..1542) })) }, delimiter: Some(Nothing) }, Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::combinator::Either<unsynn::operator::Operator<','>, unsynn::group::BraceGroup>>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::combinator::Either<unsynn::operator::Operator<','>, unsynn::group::BraceGroup>>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::combinator::Either<unsynn::operator::Operator<','>, unsynn::group::BraceGroup>>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>> { first: Operator<'<'>, second: [Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::operator::Operator<'>'>>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Ident { sym: Section, span: bytes(1543..1550) })) }], third: Operator<'>'> })) }, delimiter: Some(Nothing) }]) }, delimiter: Some(Operator<','>) }, Delimited<syncdoc_core::parse::StructField, unsynn::operator::Operator<','>> { value: StructField { attributes: Some(Repeats<1, 18446744073709551615, syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing>([Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: doc, span: bytes(1557..1621) }, Punct { char: '=', spacing: Alone, span: bytes(1557..1621) }, Literal { lit: " Unified tree of directories, files, and sections for display", span: bytes(1557..1621) }], span: bytes(1557..1621) }) }, delimiter: Some(Nothing) }])), visibility: Some(Public(KPub(Cached<proc_macro2::Ident> { value: Ident { sym: pub, span: bytes(1626..1629) }, string: "pub" }))), name: Ident { sym: tree_nodes, span: bytes(1630..1640) }, _colon: Operator<':'>, field_type: Repeats<1, 18446744073709551615, unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::combinator::Either<unsynn::operator::Operator<','>, unsynn::group::BraceGroup>>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing>([Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::combinator::Either<unsynn::operator::Operator<','>, unsynn::group::BraceGroup>>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::combinator::Either<unsynn::operator::Operator<','>, unsynn::group::BraceGroup>>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::combinator::Either<unsynn::operator::Operator<','>, unsynn::group::BraceGroup>>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Ident { sym: Vec, span: bytes(1642..1645) })) }, delimiter: Some(Nothing) }, Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::combinator::Either<unsynn::operator::Operator<','>, unsynn::group::BraceGroup>>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::combinator::Either<unsynn::operator::Operator<','>, unsynn::group::BraceGroup>>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::combinator::Either<unsynn::operator::Operator<','>, unsynn::group::BraceGroup>>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>> { first: Operator<'<'>, second: [Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::operator::Operator<'>'>>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Ident { sym: TreeNode, span: bytes(1646..1654) })) }], third: Operator<'>'> })) }, delimiter: Some(Nothing) }]) }, delimiter: Some(Operator<','>) }, Delimited<syncdoc_core::parse::StructField, unsynn::operator::Operator<','>> { value: StructField { attributes: Some(Repeats<1, 18446744073709551615, syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing>([Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: doc, span: bytes(1661..1698) }, Punct { char: '=', spacing: Alone, span: bytes(1661..1698) }, Literal { lit: " File paths available for editing.", span: bytes(1661..1698) }], span: bytes(1661..1698) }) }, delimiter: Some(Nothing) }])), visibility: Some(Public(KPub(Cached<proc_macro2::Ident> { value: Ident { sym: pub, span: bytes(1703..1706) }, string: "pub" }))), name: Ident { sym: files, span: bytes(1707..1712) }, _colon: Operator<':'>, field_type: Repeats<1, 18446744073709551615, unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::combinator::Either<unsynn::operator::Operator<','>, unsynn::group::BraceGroup>>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing>([Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::combinator::Either<unsynn::operator::Operator<','>, unsynn::group::BraceGroup>>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::combinator::Either<unsynn::operator::Operator<','>, unsynn::group::BraceGroup>>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::combinator::Either<unsynn::operator::Operator<','>, unsynn::group::BraceGroup>>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Ident { sym: Vec, span: bytes(1714..1717) })) }, delimiter: Some(Nothing) }, Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::combinator::Either<unsynn::operator::Operator<','>, unsynn::group::BraceGroup>>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::combinator::Either<unsynn::operator::Operator<','>, unsynn::group::BraceGroup>>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::combinator::Either<unsynn::operator::Operator<','>, unsynn::group::BraceGroup>>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>> { first: Operator<'<'>, second: [Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::operator::Operator<'>'>>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Ident { sym: PathBuf, span: bytes(1718..1725) })) }], third: Operator<'>'> })) }, delimiter: Some(Nothing) }]) }, delimiter: Some(Operator<','>) }, Delimited<syncdoc_core::parse::StructField, unsynn::operator::Operator<','>> { value: StructField { attributes: Some(Repeats<1, 18446744073709551615, syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing>([Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: doc, span: bytes(1732..1790) }, Punct { char: '=', spacing: Alone, span: bytes(1732..1790) }, Literal { lit: " Controls navigation behavior and file tree visibility.", span: bytes(1732..1790) }], span: bytes(1732..1790) }) }, delimiter: Some(Nothing) }])), visibility: Some(Public(KPub(Cached<proc_macro2::Ident> { value: Ident { sym: pub, span: bytes(1795..1798) }, string: "pub" }))), name: Ident { sym: file_mode, span: bytes(1799..1808) }, _colon: Operator<':'>, field_type: Repeats<1, 18446744073709551615, unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::combinator::Either<unsynn::operator::Operator<','>, unsynn::group::BraceGroup>>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing>([Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::combinator::Either<unsynn::operator::Operator<','>, unsynn::group::BraceGroup>>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::combinator::Either<unsynn::operator::Operator<','>, unsynn::group::BraceGroup>>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::combinator::Either<unsynn::operator::Operator<','>, unsynn::group::BraceGroup>>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Ident { sym: FileMode, span: bytes(1810..1818) })) }, delimiter: Some(Nothing) }]) }, delimiter: Some(Operator<','>) }, Delimited<syncdoc_core::parse::StructField, unsynn::operator::Operator<','>> { value: StructField { attributes: Some(Repeats<1, 18446744073709551615, syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing>([Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: doc, span: bytes(1824..1872) }, Punct { char: '=', spacing: Alone, span: bytes(1824..1872) }, Literal { lit: " Active UI screen determining input handling.", span: bytes(1824..1872) }], span: bytes(1824..1872) }) }, delimiter: Some(Nothing) }])), visibility: Some(Public(KPub(Cached<proc_macro2::Ident> { value: Ident { sym: pub, span: bytes(1877..1880) }, string: "pub" }))), name: Ident { sym: current_view, span: bytes(1881..1893) }, _colon: Operator<':'>, field_type: Repeats<1, 18446744073709551615, unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::combinator::Either<unsynn::operator::Operator<','>, unsynn::group::BraceGroup>>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing>([Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::combinator::Either<unsynn::operator::Operator<','>, unsynn::group::BraceGroup>>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::combinator::Either<unsynn::operator::Operator<','>, unsynn::group::BraceGroup>>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::combinator::Either<unsynn::operator::Operator<','>, unsynn::group::BraceGroup>>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Ident { sym: View, span: bytes(1895..1899) })) }, delimiter: Some(Nothing) }]) }, delimiter: Some(Operator<','>) }, Delimited<syncdoc_core::parse::StructField, unsynn::operator::Operator<','>> { value: StructField { attributes: Some(Repeats<1, 18446744073709551615, syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing>([Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: doc, span: bytes(1905..1940) }, Punct { char: '=', spacing: Alone, span: bytes(1905..1940) }, Literal { lit: " Selected node index in the tree", span: bytes(1905..1940) }], span: bytes(1905..1940) }) }, delimiter: Some(Nothing) }])), visibility: Some(Public(KPub(Cached<proc_macro2::Ident> { value: Ident { sym: pub, span: bytes(1945..1948) }, string: "pub" }))), name: Ident { sym: current_node_index, span: bytes(1949..1967) }, _colon: Operator<':'>, field_type: Repeats<1, 18446744073709551615, unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::combinator::Either<unsynn::operator::Operator<','>, unsynn::group::BraceGroup>>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing>([Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::combinator::Either<unsynn::operator::Operator<','>, unsynn::group::BraceGroup>>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::combinator::Either<unsynn::operator::Operator<','>, unsynn::group::BraceGroup>>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::combinator::Either<unsynn::operator::Operator<','>, unsynn::group::BraceGroup>>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Ident { sym: usize, span: bytes(1969..1974) })) }, delimiter: Some(Nothing) }]) }, delimiter: Some(Operator<','>) }, Delimited<syncdoc_core::parse::StructField, unsynn::operator::Operator<','>> { value: StructField { attributes: Some(Repeats<1, 18446744073709551615, syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing>([Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: doc, span: bytes(1980..2033) }, Punct { char: '=', spacing: Alone, span: bytes(1980..2033) }, Literal { lit: " Editor buffer content when detail view is active.", span: bytes(1980..2033) }], span: bytes(1980..2033) }) }, delimiter: Some(Nothing) }])), visibility: Some(Public(KPub(Cached<proc_macro2::Ident> { value: Ident { sym: pub, span: bytes(2038..2041) }, string: "pub" }))), name: Ident { sym: editor_state, span: bytes(2042..2054) }, _colon: Operator<':'>, field_type: Repeats<1, 18446744073709551615, unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::combinator::Either<unsynn::operator::Operator<','>, unsynn::group::BraceGroup>>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing>([Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::combinator::Either<unsynn::operator::Operator<','>, unsynn::group::BraceGroup>>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::combinator::Either<unsynn::operator::Operator<','>, unsynn::group::BraceGroup>>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::combinator::Either<unsynn::operator::Operator<','>, unsynn::group::BraceGroup>>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Ident { sym: Option, span: bytes(2056..2062) })) }, delimiter: Some(Nothing) }, Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::combinator::Either<unsynn::operator::Operator<','>, unsynn::group::BraceGroup>>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::combinator::Either<unsynn::operator::Operator<','>, unsynn::group::BraceGroup>>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::combinator::Either<unsynn::operator::Operator<','>, unsynn::group::BraceGroup>>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>> { first: Operator<'<'>, second: [Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::operator::Operator<'>'>>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Ident { sym: EditorState, span: bytes(2063..2074) })) }], third: Operator<'>'> })) }, delimiter: Some(Nothing) }]) }, delimiter: Some(Operator<','>) }, Delimited<syncdoc_core::parse::StructField, unsynn::operator::Operator<','>> { value: StructField { attributes: Some(Repeats<1, 18446744073709551615, syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing>([Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: doc, span: bytes(2081..2142) }, Punct { char: '=', spacing: Alone, span: bytes(2081..2142) }, Literal { lit: " Accumulates vim-style command input after ':' is pressed.", span: bytes(2081..2142) }], span: bytes(2081..2142) }) }, delimiter: Some(Nothing) }])), visibility: Some(Public(KPub(Cached<proc_macro2::Ident> { value: Ident { sym: pub, span: bytes(2147..2150) }, string: "pub" }))), name: Ident { sym: command_buffer, span: bytes(2151..2165) }, _colon: Operator<':'>, field_type: Repeats<1, 18446744073709551615, unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::combinator::Either<unsynn::operator::Operator<','>, unsynn::group::BraceGroup>>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing>([Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::combinator::Either<unsynn::operator::Operator<','>, unsynn::group::BraceGroup>>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::combinator::Either<unsynn::operator::Operator<','>, unsynn::group::BraceGroup>>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::combinator::Either<unsynn::operator::Operator<','>, unsynn::group::BraceGroup>>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Ident { sym: String, span: bytes(2167..2173) })) }, delimiter: Some(Nothing) }]) }, delimiter: Some(Operator<','>) }, Delimited<syncdoc_core::parse::StructField, unsynn::operator::Operator<','>> { value: StructField { attributes: Some(Repeats<1, 18446744073709551615, syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing>([Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: doc, span: bytes(2179..2225) }, Punct { char: '=', spacing: Alone, span: bytes(2179..2225) }, Literal { lit: " Status feedback displayed in the help bar.", span: bytes(2179..2225) }], span: bytes(2179..2225) }) }, delimiter: Some(Nothing) }])), visibility: Some(Public(KPub(Cached<proc_macro2::Ident> { value: Ident { sym: pub, span: bytes(2230..2233) }, string: "pub" }))), name: Ident { sym: message, span: bytes(2234..2241) }, _colon: Operator<':'>, field_type: Repeats<1, 18446744073709551615, unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::combinator::Either<unsynn::operator::Operator<','>, unsynn::group::BraceGroup>>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing>([Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::combinator::Either<unsynn::operator::Operator<','>, unsynn::group::BraceGroup>>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::combinator::Either<unsynn::operator::Operator<','>, unsynn::group::BraceGroup>>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::combinator::Either<unsynn::operator::Operator<','>, unsynn::group::BraceGroup>>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Ident { sym: Option, span: bytes(2243..2249) })) }, delimiter: Some(Nothing) }, Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::combinator::Either<unsynn::operator::Operator<','>, unsynn::group::BraceGroup>>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::combinator::Either<unsynn::operator::Operator<','>, unsynn::group::BraceGroup>>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::combinator::Either<unsynn::operator::Operator<','>, unsynn::group::BraceGroup>>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>> { first: Operator<'<'>, second: [Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::operator::Operator<'>'>>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Ident { sym: String, span: bytes(2250..2256) })) }], third: Operator<'>'> })) }, delimiter: Some(Nothing) }]) }, delimiter: Some(Operator<','>) }, Delimited<syncdoc_core::parse::StructField, unsynn::operator::Operator<','>> { value: StructField { attributes: Some(Repeats<1, 18446744073709551615, syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing>([Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: doc, span: bytes(2263..2318) }, Punct { char: '=', spacing: Alone, span: bytes(2263..2318) }, Literal { lit: " Maximum line width for text wrapping in the editor.", span: bytes(2263..2318) }], span: bytes(2263..2318) }) }, delimiter: Some(Nothing) }])), visibility: Some(Public(KPub(Cached<proc_macro2::Ident> { value: Ident { sym: pub, span: bytes(2323..2326) }, string: "pub" }))), name: Ident { sym: wrap_width, span: bytes(2327..2337) }, _colon: Operator<':'>, field_type: Repeats<1, 18446744073709551615, unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::combinator::Either<unsynn::operator::Operator<','>, unsynn::group::BraceGroup>>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing>([Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::combinator::Either<unsynn::operator::Operator<','>, unsynn::group::BraceGroup>>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::combinator::Either<unsynn::operator::Operator<','>, unsynn::group::BraceGroup>>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::combinator::Either<unsynn::operator::Operator<','>, unsynn::group::BraceGroup>>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Ident { sym: usize, span: bytes(2339..2344) })) }, delimiter: Some(Nothing) }]) }, delimiter: Some(Operator<','>) }, Delimited<syncdoc_core::parse::StructField, unsynn::operator::Operator<','>> { value: StructField { attributes: Some(Repeats<1, 18446744073709551615, syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing>([Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: doc, span: bytes(2350..2440) }, Punct { char: '=', spacing: Alone, span: bytes(2350..2440) }, Literal { lit: " Tracks line count changes per section to calculate write positions without re-parsing.", span: bytes(2350..2440) }], span: bytes(2350..2440) }) }, delimiter: Some(Nothing) }])), visibility: Some(Public(KPub(Cached<proc_macro2::Ident> { value: Ident { sym: pub, span: bytes(2445..2448) }, string: "pub" }))), name: Ident { sym: file_offsets, span: bytes(2449..2461) }, _colon: Operator<':'>, field_type: Repeats<1, 18446744073709551615, unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::combinator::Either<unsynn::operator::Operator<','>, unsynn::group::BraceGroup>>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing>([Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::combinator::Either<unsynn::operator::Operator<','>, unsynn::group::BraceGroup>>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::combinator::Either<unsynn::operator::Operator<','>, unsynn::group::BraceGroup>>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::combinator::Either<unsynn::operator::Operator<','>, unsynn::group::BraceGroup>>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Ident { sym: HashMap, span: bytes(2463..2470) })) }, delimiter: Some(Nothing) }, Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::combinator::Either<unsynn::operator::Operator<','>, unsynn::group::BraceGroup>>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::combinator::Either<unsynn::operator::Operator<','>, unsynn::group::BraceGroup>>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::combinator::Either<unsynn::operator::Operator<','>, unsynn::group::BraceGroup>>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>> { first: Operator<'<'>, second: [Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::operator::Operator<'>'>>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Ident { sym: String, span: bytes(2471..2477) })) }, Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::operator::Operator<'>'>>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Punct { char: ',', spacing: Alone, span: bytes(2477..2478) })) }, Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::operator::Operator<'>'>>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Ident { sym: HashMap, span: bytes(2479..2486) })) }, Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::operator::Operator<'>'>>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>> { first: Operator<'<'>, second: [Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::operator::Operator<'>'>>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Ident { sym: i64, span: bytes(2487..2490) })) }, Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::operator::Operator<'>'>>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Punct { char: ',', spacing: Alone, span: bytes(2490..2491) })) }, Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::operator::Operator<'>'>>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Ident { sym: usize, span: bytes(2492..2497) })) }], third: Operator<'>'> })) }], third: Operator<'>'> })) }, delimiter: Some(Nothing) }]) }, delimiter: Some(Operator<','>) }, Delimited<syncdoc_core::parse::StructField, unsynn::operator::Operator<','>> { value: StructField { attributes: Some(Repeats<1, 18446744073709551615, syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing>([Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: doc, span: bytes(2505..2555) }, Punct { char: '=', spacing: Alone, span: bytes(2505..2555) }, Literal { lit: " Tracks section being moved for visual feedback", span: bytes(2505..2555) }], span: bytes(2505..2555) }) }, delimiter: Some(Nothing) }])), visibility: Some(Public(KPub(Cached<proc_macro2::Ident> { value: Ident { sym: pub, span: bytes(2560..2563) }, string: "pub" }))), name: Ident { sym: move_state, span: bytes(2564..2574) }, _colon: Operator<':'>, field_type: Repeats<1, 18446744073709551615, unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::combinator::Either<unsynn::operator::Operator<','>, unsynn::group::BraceGroup>>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing>([Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::combinator::Either<unsynn::operator::Operator<','>, unsynn::group::BraceGroup>>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::combinator::Either<unsynn::operator::Operator<','>, unsynn::group::BraceGroup>>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::combinator::Either<unsynn::operator::Operator<','>, unsynn::group::BraceGroup>>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Ident { sym: MoveState, span: bytes(2576..2585) })) }, delimiter: Some(Nothing) }]) }, delimiter: Some(Operator<','>) }, Delimited<syncdoc_core::parse::StructField, unsynn::operator::Operator<','>> { value: StructField { attributes: Some(Repeats<1, 18446744073709551615, syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing>([Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: doc, span: bytes(2591..2632) }, Punct { char: '=', spacing: Alone, span: bytes(2591..2632) }, Literal { lit: " Index of section being moved (if any)", span: bytes(2591..2632) }], span: bytes(2591..2632) }) }, delimiter: Some(Nothing) }])), visibility: Some(Public(KPub(Cached<proc_macro2::Ident> { value: Ident { sym: pub, span: bytes(2637..2640) }, string: "pub" }))), name: Ident { sym: moving_section_index, span: bytes(2641..2661) }, _colon: Operator<':'>, field_type: Repeats<1, 18446744073709551615, unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::combinator::Either<unsynn::operator::Operator<','>, unsynn::group::BraceGroup>>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing>([Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::combinator::Either<unsynn::operator::Operator<','>, unsynn::group::BraceGroup>>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::combinator::Either<unsynn::operator::Operator<','>, unsynn::group::BraceGroup>>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::combinator::Either<unsynn::operator::Operator<','>, unsynn::group::BraceGroup>>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Ident { sym: Option, span: bytes(2663..2669) })) }, delimiter: Some(Nothing) }, Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::combinator::Either<unsynn::operator::Operator<','>, unsynn::group::BraceGroup>>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::combinator::Either<unsynn::operator::Operator<','>, unsynn::group::BraceGroup>>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::combinator::Either<unsynn::operator::Operator<','>, unsynn::group::BraceGroup>>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>> { first: Operator<'<'>, second: [Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::operator::Operator<'>'>>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Ident { sym: usize, span: bytes(2670..2675) })) }], third: Operator<'>'> })) }, delimiter: Some(Nothing) }]) }, delimiter: Some(Operator<','>) }])))) })
[SYNCDOC DEBUG] Processing item type: Enum
[SYNCDOC DEBUG] Processing item: Enum(EnumSig { attributes: Some(Repeats<1, 18446744073709551615, syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing>([Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: doc, span: bytes(2681..2749) }, Punct { char: '=', spacing: Alone, span: bytes(2681..2749) }, Literal { lit: " Determines which UI screen renders and how input is interpreted.", span: bytes(2681..2749) }], span: bytes(2681..2749) }) }, delimiter: Some(Nothing) }, Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: derive, span: bytes(2752..2758) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: PartialEq, span: bytes(2759..2768) }], span: bytes(2758..2769) }], span: bytes(2751..2770) }) }, delimiter: Some(Nothing) }])), visibility: Some(Public(KPub(Cached<proc_macro2::Ident> { value: Ident { sym: pub, span: bytes(2771..2774) }, string: "pub" }))), _enum: KEnum(Cached<proc_macro2::Ident> { value: Ident { sym: enum, span: bytes(2775..2779) }, string: "enum" }), name: Ident { sym: View, span: bytes(2780..2784) }, generics: None, where_clause: None, variants: BraceGroupContaining < core::option::Option<unsynn::container::DelimitedVec<syncdoc_core::parse::EnumVariant, unsynn::operator::Operator<','>>>>(Some(DelimitedVec<syncdoc_core::parse::EnumVariant, unsynn::operator::Operator<','>>([Delimited<syncdoc_core::parse::EnumVariant, unsynn::operator::Operator<','>> { value: EnumVariant { attributes: Some(Repeats<1, 18446744073709551615, syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing>([Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: doc, span: bytes(2791..2843) }, Punct { char: '=', spacing: Alone, span: bytes(2791..2843) }, Literal { lit: " Shows hierarchical section tree with navigation.", span: bytes(2791..2843) }], span: bytes(2791..2843) }) }, delimiter: Some(Nothing) }])), name: Ident { sym: List, span: bytes(2848..2852) }, data: None }, delimiter: Some(Operator<','>) }, Delimited<syncdoc_core::parse::EnumVariant, unsynn::operator::Operator<','>> { value: EnumVariant { attributes: Some(Repeats<1, 18446744073709551615, syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing>([Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: doc, span: bytes(2858..2907) }, Punct { char: '=', spacing: Alone, span: bytes(2858..2907) }, Literal { lit: " Provides vim-like editor for section content.", span: bytes(2858..2907) }], span: bytes(2858..2907) }) }, delimiter: Some(Nothing) }])), name: Ident { sym: Detail, span: bytes(2912..2918) }, data: None }, delimiter: Some(Operator<','>) }, Delimited<syncdoc_core::parse::EnumVariant, unsynn::operator::Operator<','>> { value: EnumVariant { attributes: Some(Repeats<1, 18446744073709551615, syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing>([Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: doc, span: bytes(2924..2981) }, Punct { char: '=', spacing: Alone, span: bytes(2924..2981) }, Literal { lit: " Captures vim-style command input after ':' keystroke.", span: bytes(2924..2981) }], span: bytes(2924..2981) }) }, delimiter: Some(Nothing) }])), name: Ident { sym: Command, span: bytes(2986..2993) }, data: None }, delimiter: Some(Operator<','>) }]))) })
[SYNCDOC DEBUG] Processing item type: ImplBlock
[SYNCDOC DEBUG] Processing item: ImplBlock(ImplBlockSig { attributes: None, _impl: KImpl(Cached<proc_macro2::Ident> { value: Ident { sym: impl, span: bytes(2998..3002) }, string: "impl" }), generics: None, target_type: Repeats<1, 18446744073709551615, unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::combinator::Either<syncdoc_core::parse::KFor, unsynn::group::BraceGroup>>, proc_macro2::TokenTree>, unsynn::fundamental::Nothing>([Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::combinator::Either<syncdoc_core::parse::KFor, unsynn::group::BraceGroup>>, proc_macro2::TokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::combinator::Either<syncdoc_core::parse::KFor, unsynn::group::BraceGroup>>, proc_macro2::TokenTree> { first: Except<unsynn::combinator::Either<syncdoc_core::parse::KFor, unsynn::group::BraceGroup>>, second: Ident { sym: AppState, span: bytes(3003..3011) } }, delimiter: Some(Nothing) }]), for_trait: None, where_clause: None, items: BraceGroupContaining < syncdoc_core::parse::ModuleContent>(ModuleContent { inner_attrs: None, items: Repeats<1, 18446744073709551615, syncdoc_core::parse::ModuleItem, unsynn::fundamental::Nothing>([Delimited<syncdoc_core::parse::ModuleItem, unsynn::fundamental::Nothing> { value: Function(FnSig { attributes: Some(Repeats<1, 18446744073709551615, syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing>([Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: doc, span: bytes(3018..3098) }, Punct { char: '=', spacing: Alone, span: bytes(3018..3098) }, Literal { lit: " Initialises application state with parsed sections and determines file mode.", span: bytes(3018..3098) }], span: bytes(3018..3098) }) }, delimiter: Some(Nothing) }, Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: must_use, span: bytes(3105..3113) }], span: bytes(3104..3114) }) }, delimiter: Some(Nothing) }])), visibility: Some(Public(KPub(Cached<proc_macro2::Ident> { value: Ident { sym: pub, span: bytes(3119..3122) }, string: "pub" }))), const_kw: None, async_kw: None, unsafe_kw: None, extern_kw: None, _fn: KFn(Cached<proc_macro2::Ident> { value: Ident { sym: fn, span: bytes(3123..3125) }, string: "fn" }), name: Ident { sym: new, span: bytes(3126..3129) }, generics: None, params: ParenthesisGroupContaining < core::option::Option<unsynn::container::DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>>>(Some(DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>([Delimited<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>> { value: Named(NamedParam { mut_kw: None, name: Ident { sym: files, span: bytes(3130..3135) }, _colon: Operator<':'>, param_type: Repeats<1, 18446744073709551615, unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<','>>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing>([Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<','>>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::operator::Operator<','>>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::operator::Operator<','>>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Ident { sym: Vec, span: bytes(3137..3140) })) }, delimiter: Some(Nothing) }, Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<','>>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::operator::Operator<','>>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::operator::Operator<','>>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>> { first: Operator<'<'>, second: [Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::operator::Operator<'>'>>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Ident { sym: PathBuf, span: bytes(3141..3148) })) }], third: Operator<'>'> })) }, delimiter: Some(Nothing) }]) }), delimiter: Some(Operator<','>) }, Delimited<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>> { value: Named(NamedParam { mut_kw: None, name: Ident { sym: sections, span: bytes(3151..3159) }, _colon: Operator<':'>, param_type: Repeats<1, 18446744073709551615, unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<','>>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing>([Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<','>>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::operator::Operator<','>>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::operator::Operator<','>>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Ident { sym: Vec, span: bytes(3161..3164) })) }, delimiter: Some(Nothing) }, Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<','>>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::operator::Operator<','>>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::operator::Operator<','>>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>> { first: Operator<'<'>, second: [Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::operator::Operator<'>'>>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Ident { sym: Section, span: bytes(3165..3172) })) }], third: Operator<'>'> })) }, delimiter: Some(Nothing) }]) }), delimiter: Some(Operator<','>) }, Delimited<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>> { value: Named(NamedParam { mut_kw: None, name: Ident { sym: wrap_width, span: bytes(3175..3185) }, _colon: Operator<':'>, param_type: Repeats<1, 18446744073709551615, unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<','>>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing>([Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<','>>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::operator::Operator<','>>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::operator::Operator<','>>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Ident { sym: usize, span: bytes(3187..3192) })) }, delimiter: Some(Nothing) }]) }), delimiter: None }]))), return_type: Some(ReturnTypeFn { _arrow: Operator<'->'>, return_type: Repeats<1, 18446744073709551615, unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing>([Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::group::BraceGroup>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Ident { sym: Self, span: bytes(3197..3201) })) }, delimiter: Some(Nothing) }]) }), where_clause: None, body: BraceGroup(Group { delimiter: Brace, stream: TokenStream [Ident { sym: let, span: bytes(3212..3215) }, Ident { sym: file_mode, span: bytes(3216..3225) }, Punct { char: '=', spacing: Alone, span: bytes(3226..3227) }, Ident { sym: if, span: bytes(3228..3230) }, Ident { sym: files, span: bytes(3231..3236) }, Punct { char: '.', spacing: Alone, span: bytes(3236..3237) }, Ident { sym: len, span: bytes(3237..3240) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(3240..3242) }, Punct { char: '=', spacing: Joint, span: bytes(3243..3244) }, Punct { char: '=', spacing: Alone, span: bytes(3244..3245) }, Literal { lit: 1, span: bytes(3246..3247) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: FileMode, span: bytes(3262..3270) }, Punct { char: ':', spacing: Joint, span: bytes(3270..3271) }, Punct { char: ':', spacing: Alone, span: bytes(3271..3272) }, Ident { sym: Single, span: bytes(3272..3278) }], span: bytes(3248..3288) }, Ident { sym: else, span: bytes(3289..3293) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: FileMode, span: bytes(3308..3316) }, Punct { char: ':', spacing: Joint, span: bytes(3316..3317) }, Punct { char: ':', spacing: Alone, span: bytes(3317..3318) }, Ident { sym: Multi, span: bytes(3318..3323) }], span: bytes(3294..3333) }, Punct { char: ';', spacing: Alone, span: bytes(3333..3334) }, Ident { sym: let, span: bytes(3344..3347) }, Ident { sym: tree_nodes, span: bytes(3348..3358) }, Punct { char: '=', spacing: Alone, span: bytes(3359..3360) }, Ident { sym: Self, span: bytes(3361..3365) }, Punct { char: ':', spacing: Joint, span: bytes(3365..3366) }, Punct { char: ':', spacing: Alone, span: bytes(3366..3367) }, Ident { sym: build_tree, span: bytes(3367..3377) }, Group { delimiter: Parenthesis, stream: TokenStream [Punct { char: '&', spacing: Alone, span: bytes(3378..3379) }, Ident { sym: files, span: bytes(3379..3384) }, Punct { char: ',', spacing: Alone, span: bytes(3384..3385) }, Punct { char: '&', spacing: Alone, span: bytes(3386..3387) }, Ident { sym: sections, span: bytes(3387..3395) }], span: bytes(3377..3396) }, Punct { char: ';', spacing: Alone, span: bytes(3396..3397) }, Ident { sym: let, span: bytes(3444..3447) }, Ident { sym: initial_index, span: bytes(3448..3461) }, Punct { char: '=', spacing: Alone, span: bytes(3462..3463) }, Ident { sym: tree_nodes, span: bytes(3464..3474) }, Punct { char: '.', spacing: Alone, span: bytes(3474..3475) }, Ident { sym: iter, span: bytes(3475..3479) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(3479..3481) }, Punct { char: '.', spacing: Alone, span: bytes(3481..3482) }, Ident { sym: position, span: bytes(3482..3490) }, Group { delimiter: Parenthesis, stream: TokenStream [Punct { char: '|', spacing: Alone, span: bytes(3491..3492) }, Ident { sym: n, span: bytes(3492..3493) }, Punct { char: '|', spacing: Alone, span: bytes(3493..3494) }, Ident { sym: n, span: bytes(3495..3496) }, Punct { char: '.', spacing: Alone, span: bytes(3496..3497) }, Ident { sym: navigable, span: bytes(3497..3506) }], span: bytes(3490..3507) }, Punct { char: '.', spacing: Alone, span: bytes(3507..3508) }, Ident { sym: unwrap_or, span: bytes(3508..3517) }, Group { delimiter: Parenthesis, stream: TokenStream [Literal { lit: 0, span: bytes(3518..3519) }], span: bytes(3517..3520) }, Punct { char: ';', spacing: Alone, span: bytes(3520..3521) }, Ident { sym: Self, span: bytes(3531..3535) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: sections, span: bytes(3550..3558) }, Punct { char: ',', spacing: Alone, span: bytes(3558..3559) }, Ident { sym: tree_nodes, span: bytes(3572..3582) }, Punct { char: ',', spacing: Alone, span: bytes(3582..3583) }, Ident { sym: files, span: bytes(3596..3601) }, Punct { char: ',', spacing: Alone, span: bytes(3601..3602) }, Ident { sym: file_mode, span: bytes(3615..3624) }, Punct { char: ',', spacing: Alone, span: bytes(3624..3625) }, Ident { sym: current_view, span: bytes(3638..3650) }, Punct { char: ':', spacing: Alone, span: bytes(3650..3651) }, Ident { sym: View, span: bytes(3652..3656) }, Punct { char: ':', spacing: Joint, span: bytes(3656..3657) }, Punct { char: ':', spacing: Alone, span: bytes(3657..3658) }, Ident { sym: List, span: bytes(3658..3662) }, Punct { char: ',', spacing: Alone, span: bytes(3662..3663) }, Ident { sym: current_node_index, span: bytes(3676..3694) }, Punct { char: ':', spacing: Alone, span: bytes(3694..3695) }, Ident { sym: initial_index, span: bytes(3696..3709) }, Punct { char: ',', spacing: Alone, span: bytes(3709..3710) }, Ident { sym: editor_state, span: bytes(3723..3735) }, Punct { char: ':', spacing: Alone, span: bytes(3735..3736) }, Ident { sym: None, span: bytes(3737..3741) }, Punct { char: ',', spacing: Alone, span: bytes(3741..3742) }, Ident { sym: command_buffer, span: bytes(3755..3769) }, Punct { char: ':', spacing: Alone, span: bytes(3769..3770) }, Ident { sym: String, span: bytes(3771..3777) }, Punct { char: ':', spacing: Joint, span: bytes(3777..3778) }, Punct { char: ':', spacing: Alone, span: bytes(3778..3779) }, Ident { sym: new, span: bytes(3779..3782) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(3782..3784) }, Punct { char: ',', spacing: Alone, span: bytes(3784..3785) }, Ident { sym: message, span: bytes(3798..3805) }, Punct { char: ':', spacing: Alone, span: bytes(3805..3806) }, Ident { sym: None, span: bytes(3807..3811) }, Punct { char: ',', spacing: Alone, span: bytes(3811..3812) }, Ident { sym: wrap_width, span: bytes(3825..3835) }, Punct { char: ',', spacing: Alone, span: bytes(3835..3836) }, Ident { sym: file_offsets, span: bytes(3849..3861) }, Punct { char: ':', spacing: Alone, span: bytes(3861..3862) }, Ident { sym: HashMap, span: bytes(3863..3870) }, Punct { char: ':', spacing: Joint, span: bytes(3870..3871) }, Punct { char: ':', spacing: Alone, span: bytes(3871..3872) }, Ident { sym: new, span: bytes(3872..3875) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(3875..3877) }, Punct { char: ',', spacing: Alone, span: bytes(3877..3878) }, Ident { sym: move_state, span: bytes(3891..3901) }, Punct { char: ':', spacing: Alone, span: bytes(3901..3902) }, Ident { sym: MoveState, span: bytes(3903..3912) }, Punct { char: ':', spacing: Joint, span: bytes(3912..3913) }, Punct { char: ':', spacing: Alone, span: bytes(3913..3914) }, Ident { sym: None, span: bytes(3914..3918) }, Punct { char: ',', spacing: Alone, span: bytes(3918..3919) }, Ident { sym: moving_section_index, span: bytes(3932..3952) }, Punct { char: ':', spacing: Alone, span: bytes(3952..3953) }, Ident { sym: None, span: bytes(3954..3958) }, Punct { char: ',', spacing: Alone, span: bytes(3958..3959) }], span: bytes(3536..3969) }], span: bytes(3202..3975) }) }), delimiter: Some(Nothing) }, Delimited<syncdoc_core::parse::ModuleItem, unsynn::fundamental::Nothing> { value: Function(FnSig { attributes: None, visibility: None, const_kw: None, async_kw: None, unsafe_kw: None, extern_kw: None, _fn: KFn(Cached<proc_macro2::Ident> { value: Ident { sym: fn, span: bytes(3981..3983) }, string: "fn" }), name: Ident { sym: build_tree, span: bytes(3984..3994) }, generics: None, params: ParenthesisGroupContaining < core::option::Option<unsynn::container::DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>>>(Some(DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>([Delimited<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>> { value: Named(NamedParam { mut_kw: None, name: Ident { sym: files, span: bytes(3995..4000) }, _colon: Operator<':'>, param_type: Repeats<1, 18446744073709551615, unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<','>>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing>([Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<','>>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::operator::Operator<','>>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::operator::Operator<','>>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Punct { char: '&', spacing: Alone, span: bytes(4002..4003) })) }, delimiter: Some(Nothing) }, Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<','>>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::operator::Operator<','>>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::operator::Operator<','>>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: PathBuf, span: bytes(4004..4011) }], span: bytes(4003..4012) })) }, delimiter: Some(Nothing) }]) }), delimiter: Some(Operator<','>) }, Delimited<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>> { value: Named(NamedParam { mut_kw: None, name: Ident { sym: sections, span: bytes(4014..4022) }, _colon: Operator<':'>, param_type: Repeats<1, 18446744073709551615, unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<','>>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing>([Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<','>>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::operator::Operator<','>>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::operator::Operator<','>>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Punct { char: '&', spacing: Alone, span: bytes(4024..4025) })) }, delimiter: Some(Nothing) }, Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<','>>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::operator::Operator<','>>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::operator::Operator<','>>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: Section, span: bytes(4026..4033) }], span: bytes(4025..4034) })) }, delimiter: Some(Nothing) }]) }), delimiter: None }]))), return_type: Some(ReturnTypeFn { _arrow: Operator<'->'>, return_type: Repeats<1, 18446744073709551615, unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing>([Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::group::BraceGroup>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Ident { sym: Vec, span: bytes(4039..4042) })) }, delimiter: Some(Nothing) }, Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::group::BraceGroup>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>> { first: Operator<'<'>, second: [Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::operator::Operator<'>'>>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Ident { sym: TreeNode, span: bytes(4043..4051) })) }], third: Operator<'>'> })) }, delimiter: Some(Nothing) }]) }), where_clause: None, body: BraceGroup(Group { delimiter: Brace, stream: TokenStream [Ident { sym: let, span: bytes(4063..4066) }, Ident { sym: mut, span: bytes(4067..4070) }, Ident { sym: nodes, span: bytes(4071..4076) }, Punct { char: '=', spacing: Alone, span: bytes(4077..4078) }, Ident { sym: Vec, span: bytes(4079..4082) }, Punct { char: ':', spacing: Joint, span: bytes(4082..4083) }, Punct { char: ':', spacing: Alone, span: bytes(4083..4084) }, Ident { sym: new, span: bytes(4084..4087) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(4087..4089) }, Punct { char: ';', spacing: Alone, span: bytes(4089..4090) }, Ident { sym: let, span: bytes(4308..4311) }, Ident { sym: mut, span: bytes(4312..4315) }, Ident { sym: file_section_counts, span: bytes(4316..4335) }, Punct { char: ':', spacing: Alone, span: bytes(4335..4336) }, Ident { sym: HashMap, span: bytes(4337..4344) }, Punct { char: '<', spacing: Alone, span: bytes(4344..4345) }, Ident { sym: String, span: bytes(4345..4351) }, Punct { char: ',', spacing: Alone, span: bytes(4351..4352) }, Ident { sym: usize, span: bytes(4353..4358) }, Punct { char: '>', spacing: Alone, span: bytes(4358..4359) }, Punct { char: '=', spacing: Alone, span: bytes(4360..4361) }, Ident { sym: HashMap, span: bytes(4362..4369) }, Punct { char: ':', spacing: Joint, span: bytes(4369..4370) }, Punct { char: ':', spacing: Alone, span: bytes(4370..4371) }, Ident { sym: new, span: bytes(4371..4374) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(4374..4376) }, Punct { char: ';', spacing: Alone, span: bytes(4376..4377) }, Ident { sym: for, span: bytes(4386..4389) }, Ident { sym: section, span: bytes(4390..4397) }, Ident { sym: in, span: bytes(4398..4400) }, Ident { sym: sections, span: bytes(4401..4409) }, Group { delimiter: Brace, stream: TokenStream [Punct { char: '*', spacing: Alone, span: bytes(4424..4425) }, Ident { sym: file_section_counts, span: bytes(4425..4444) }, Punct { char: '.', spacing: Alone, span: bytes(4461..4462) }, Ident { sym: entry, span: bytes(4462..4467) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: section, span: bytes(4468..4475) }, Punct { char: '.', spacing: Alone, span: bytes(4475..4476) }, Ident { sym: file_path, span: bytes(4476..4485) }, Punct { char: '.', spacing: Alone, span: bytes(4485..4486) }, Ident { sym: clone, span: bytes(4486..4491) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(4491..4493) }], span: bytes(4467..4494) }, Punct { char: '.', spacing: Alone, span: bytes(4511..4512) }, Ident { sym: or_insert, span: bytes(4512..4521) }, Group { delimiter: Parenthesis, stream: TokenStream [Literal { lit: 0, span: bytes(4522..4523) }], span: bytes(4521..4524) }, Punct { char: '+', spacing: Joint, span: bytes(4525..4526) }, Punct { char: '=', spacing: Alone, span: bytes(4526..4527) }, Literal { lit: 1, span: bytes(4528..4529) }, Punct { char: ';', spacing: Alone, span: bytes(4529..4530) }], span: bytes(4410..4540) }, Ident { sym: let, span: bytes(4549..4552) }, Ident { sym: is_difftastic, span: bytes(4553..4566) }, Punct { char: '=', spacing: Alone, span: bytes(4567..4568) }, Ident { sym: file_section_counts, span: bytes(4569..4588) }, Punct { char: '.', spacing: Alone, span: bytes(4588..4589) }, Ident { sym: values, span: bytes(4589..4595) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(4595..4597) }, Punct { char: '.', spacing: Alone, span: bytes(4597..4598) }, Ident { sym: any, span: bytes(4598..4601) }, Group { delimiter: Parenthesis, stream: TokenStream [Punct { char: '|', spacing: Joint, span: bytes(4602..4603) }, Punct { char: '&', spacing: Alone, span: bytes(4603..4604) }, Ident { sym: count, span: bytes(4604..4609) }, Punct { char: '|', spacing: Alone, span: bytes(4609..4610) }, Ident { sym: count, span: bytes(4611..4616) }, Punct { char: '>', spacing: Alone, span: bytes(4617..4618) }, Literal { lit: 1, span: bytes(4619..4620) }], span: bytes(4601..4621) }, Punct { char: ';', spacing: Alone, span: bytes(4621..4622) }, Ident { sym: if, span: bytes(4632..4634) }, Ident { sym: files, span: bytes(4635..4640) }, Punct { char: '.', spacing: Alone, span: bytes(4640..4641) }, Ident { sym: len, span: bytes(4641..4644) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(4644..4646) }, Punct { char: '=', spacing: Joint, span: bytes(4647..4648) }, Punct { char: '=', spacing: Alone, span: bytes(4648..4649) }, Literal { lit: 1, span: bytes(4650..4651) }, Punct { char: '&', spacing: Joint, span: bytes(4652..4653) }, Punct { char: '&', spacing: Alone, span: bytes(4653..4654) }, Punct { char: '!', spacing: Alone, span: bytes(4655..4656) }, Ident { sym: is_difftastic, span: bytes(4656..4669) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: for, span: bytes(4765..4768) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: idx, span: bytes(4770..4773) }, Punct { char: ',', spacing: Alone, span: bytes(4773..4774) }, Ident { sym: section, span: bytes(4775..4782) }], span: bytes(4769..4783) }, Ident { sym: in, span: bytes(4784..4786) }, Ident { sym: sections, span: bytes(4787..4795) }, Punct { char: '.', spacing: Alone, span: bytes(4795..4796) }, Ident { sym: iter, span: bytes(4796..4800) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(4800..4802) }, Punct { char: '.', spacing: Alone, span: bytes(4802..4803) }, Ident { sym: enumerate, span: bytes(4803..4812) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(4812..4814) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: nodes, span: bytes(4833..4838) }, Punct { char: '.', spacing: Alone, span: bytes(4838..4839) }, Ident { sym: push, span: bytes(4839..4843) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: TreeNode, span: bytes(4844..4852) }, Punct { char: ':', spacing: Joint, span: bytes(4852..4853) }, Punct { char: ':', spacing: Alone, span: bytes(4853..4854) }, Ident { sym: section, span: bytes(4854..4861) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: section, span: bytes(4862..4869) }, Punct { char: '.', spacing: Alone, span: bytes(4869..4870) }, Ident { sym: clone, span: bytes(4870..4875) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(4875..4877) }, Punct { char: ',', spacing: Alone, span: bytes(4877..4878) }, Ident { sym: section, span: bytes(4879..4886) }, Punct { char: '.', spacing: Alone, span: bytes(4886..4887) }, Ident { sym: level, span: bytes(4887..4892) }, Punct { char: ',', spacing: Alone, span: bytes(4892..4893) }, Ident { sym: idx, span: bytes(4894..4897) }], span: bytes(4861..4898) }], span: bytes(4843..4899) }, Punct { char: ';', spacing: Alone, span: bytes(4899..4900) }], span: bytes(4815..4914) }], span: bytes(4670..4924) }, Ident { sym: else, span: bytes(4925..4929) }, Ident { sym: if, span: bytes(4930..4932) }, Ident { sym: is_difftastic, span: bytes(4933..4946) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: let, span: bytes(5051..5054) }, Ident { sym: mut, span: bytes(5055..5058) }, Ident { sym: file_tree, span: bytes(5059..5068) }, Punct { char: ':', spacing: Alone, span: bytes(5068..5069) }, Ident { sym: HashMap, span: bytes(5070..5077) }, Punct { char: '<', spacing: Alone, span: bytes(5077..5078) }, Ident { sym: String, span: bytes(5078..5084) }, Punct { char: ',', spacing: Alone, span: bytes(5084..5085) }, Ident { sym: Vec, span: bytes(5086..5089) }, Punct { char: '<', spacing: Alone, span: bytes(5089..5090) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: usize, span: bytes(5091..5096) }, Punct { char: ',', spacing: Alone, span: bytes(5096..5097) }, Punct { char: '&', spacing: Alone, span: bytes(5098..5099) }, Ident { sym: Section, span: bytes(5099..5106) }], span: bytes(5090..5107) }, Punct { char: '>', spacing: Joint, span: bytes(5107..5108) }, Punct { char: '>', spacing: Alone, span: bytes(5108..5109) }, Punct { char: '=', spacing: Alone, span: bytes(5110..5111) }, Ident { sym: HashMap, span: bytes(5112..5119) }, Punct { char: ':', spacing: Joint, span: bytes(5119..5120) }, Punct { char: ':', spacing: Alone, span: bytes(5120..5121) }, Ident { sym: new, span: bytes(5121..5124) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(5124..5126) }, Punct { char: ';', spacing: Alone, span: bytes(5126..5127) }, Ident { sym: let, span: bytes(5140..5143) }, Ident { sym: mut, span: bytes(5144..5147) }, Ident { sym: file_status, span: bytes(5148..5159) }, Punct { char: ':', spacing: Alone, span: bytes(5159..5160) }, Ident { sym: HashMap, span: bytes(5161..5168) }, Punct { char: '<', spacing: Alone, span: bytes(5168..5169) }, Ident { sym: String, span: bytes(5169..5175) }, Punct { char: ',', spacing: Alone, span: bytes(5175..5176) }, Ident { sym: Option, span: bytes(5177..5183) }, Punct { char: '<', spacing: Alone, span: bytes(5183..5184) }, Ident { sym: String, span: bytes(5184..5190) }, Punct { char: '>', spacing: Joint, span: bytes(5190..5191) }, Punct { char: '>', spacing: Alone, span: bytes(5191..5192) }, Punct { char: '=', spacing: Alone, span: bytes(5193..5194) }, Ident { sym: HashMap, span: bytes(5195..5202) }, Punct { char: ':', spacing: Joint, span: bytes(5202..5203) }, Punct { char: ':', spacing: Alone, span: bytes(5203..5204) }, Ident { sym: new, span: bytes(5204..5207) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(5207..5209) }, Punct { char: ';', spacing: Alone, span: bytes(5209..5210) }, Ident { sym: for, span: bytes(5286..5289) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: idx, span: bytes(5291..5294) }, Punct { char: ',', spacing: Alone, span: bytes(5294..5295) }, Ident { sym: section, span: bytes(5296..5303) }], span: bytes(5290..5304) }, Ident { sym: in, span: bytes(5305..5307) }, Ident { sym: sections, span: bytes(5308..5316) }, Punct { char: '.', spacing: Alone, span: bytes(5316..5317) }, Ident { sym: iter, span: bytes(5317..5321) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(5321..5323) }, Punct { char: '.', spacing: Alone, span: bytes(5323..5324) }, Ident { sym: enumerate, span: bytes(5324..5333) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(5333..5335) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: file_tree, span: bytes(5354..5363) }, Punct { char: '.', spacing: Alone, span: bytes(5384..5385) }, Ident { sym: entry, span: bytes(5385..5390) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: section, span: bytes(5391..5398) }, Punct { char: '.', spacing: Alone, span: bytes(5398..5399) }, Ident { sym: file_path, span: bytes(5399..5408) }, Punct { char: '.', spacing: Alone, span: bytes(5408..5409) }, Ident { sym: clone, span: bytes(5409..5414) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(5414..5416) }], span: bytes(5390..5417) }, Punct { char: '.', spacing: Alone, span: bytes(5438..5439) }, Ident { sym: or_default, span: bytes(5439..5449) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(5449..5451) }, Punct { char: '.', spacing: Alone, span: bytes(5472..5473) }, Ident { sym: push, span: bytes(5473..5477) }, Group { delimiter: Parenthesis, stream: TokenStream [Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: idx, span: bytes(5479..5482) }, Punct { char: ',', spacing: Alone, span: bytes(5482..5483) }, Ident { sym: section, span: bytes(5484..5491) }], span: bytes(5478..5492) }], span: bytes(5477..5493) }, Punct { char: ';', spacing: Alone, span: bytes(5493..5494) }, Ident { sym: if, span: bytes(5571..5573) }, Punct { char: '!', spacing: Alone, span: bytes(5574..5575) }, Ident { sym: file_status, span: bytes(5575..5586) }, Punct { char: '.', spacing: Alone, span: bytes(5586..5587) }, Ident { sym: contains_key, span: bytes(5587..5599) }, Group { delimiter: Parenthesis, stream: TokenStream [Punct { char: '&', spacing: Alone, span: bytes(5600..5601) }, Ident { sym: section, span: bytes(5601..5608) }, Punct { char: '.', spacing: Alone, span: bytes(5608..5609) }, Ident { sym: file_path, span: bytes(5609..5618) }], span: bytes(5599..5619) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: let, span: bytes(5642..5645) }, Ident { sym: status, span: bytes(5646..5652) }, Punct { char: '=', spacing: Alone, span: bytes(5653..5654) }, Ident { sym: if, span: bytes(5655..5657) }, Ident { sym: section, span: bytes(5658..5665) }, Punct { char: '.', spacing: Alone, span: bytes(5665..5666) }, Ident { sym: title, span: bytes(5666..5671) }, Punct { char: '.', spacing: Alone, span: bytes(5671..5672) }, Ident { sym: contains, span: bytes(5672..5680) }, Group { delimiter: Parenthesis, stream: TokenStream [Literal { lit: "@@ -0,0", span: bytes(5681..5690) }], span: bytes(5680..5691) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: Some, span: bytes(5718..5722) }, Group { delimiter: Parenthesis, stream: TokenStream [Literal { lit: "created", span: bytes(5723..5732) }, Punct { char: '.', spacing: Alone, span: bytes(5732..5733) }, Ident { sym: to_string, span: bytes(5733..5742) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(5742..5744) }], span: bytes(5722..5745) }], span: bytes(5692..5767) }, Ident { sym: else, span: bytes(5768..5772) }, Ident { sym: if, span: bytes(5773..5775) }, Ident { sym: section, span: bytes(5776..5783) }, Punct { char: '.', spacing: Alone, span: bytes(5783..5784) }, Ident { sym: title, span: bytes(5784..5789) }, Punct { char: '.', spacing: Alone, span: bytes(5789..5790) }, Ident { sym: contains, span: bytes(5790..5798) }, Group { delimiter: Parenthesis, stream: TokenStream [Literal { lit: "+0,0 @@", span: bytes(5799..5808) }], span: bytes(5798..5809) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: Some, span: bytes(5836..5840) }, Group { delimiter: Parenthesis, stream: TokenStream [Literal { lit: "deleted", span: bytes(5841..5850) }, Punct { char: '.', spacing: Alone, span: bytes(5850..5851) }, Ident { sym: to_string, span: bytes(5851..5860) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(5860..5862) }], span: bytes(5840..5863) }], span: bytes(5810..5885) }, Ident { sym: else, span: bytes(5886..5890) }, Ident { sym: if, span: bytes(5891..5893) }, Ident { sym: section, span: bytes(5894..5901) }, Punct { char: '.', spacing: Alone, span: bytes(5901..5902) }, Ident { sym: title, span: bytes(5902..5907) }, Punct { char: '.', spacing: Alone, span: bytes(5907..5908) }, Ident { sym: contains, span: bytes(5908..5916) }, Group { delimiter: Parenthesis, stream: TokenStream [Literal { lit: "@@ ", span: bytes(5917..5922) }], span: bytes(5916..5923) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: Some, span: bytes(5950..5954) }, Group { delimiter: Parenthesis, stream: TokenStream [Literal { lit: "changed", span: bytes(5955..5964) }, Punct { char: '.', spacing: Alone, span: bytes(5964..5965) }, Ident { sym: to_string, span: bytes(5965..5974) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(5974..5976) }], span: bytes(5954..5977) }], span: bytes(5924..5999) }, Ident { sym: else, span: bytes(6000..6004) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: None, span: bytes(6031..6035) }], span: bytes(6005..6057) }, Punct { char: ';', spacing: Alone, span: bytes(6057..6058) }, Ident { sym: file_status, span: bytes(6079..6090) }, Punct { char: '.', spacing: Alone, span: bytes(6090..6091) }, Ident { sym: insert, span: bytes(6091..6097) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: section, span: bytes(6098..6105) }, Punct { char: '.', spacing: Alone, span: bytes(6105..6106) }, Ident { sym: file_path, span: bytes(6106..6115) }, Punct { char: '.', spacing: Alone, span: bytes(6115..6116) }, Ident { sym: clone, span: bytes(6116..6121) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(6121..6123) }, Punct { char: ',', spacing: Alone, span: bytes(6123..6124) }, Ident { sym: status, span: bytes(6125..6131) }], span: bytes(6097..6132) }, Punct { char: ';', spacing: Alone, span: bytes(6132..6133) }], span: bytes(5620..6151) }], span: bytes(5336..6165) }, Ident { sym: let, span: bytes(6239..6242) }, Ident { sym: mut, span: bytes(6243..6246) }, Ident { sym: sorted_files, span: bytes(6247..6259) }, Punct { char: ':', spacing: Alone, span: bytes(6259..6260) }, Ident { sym: Vec, span: bytes(6261..6264) }, Punct { char: '<', spacing: Alone, span: bytes(6264..6265) }, Ident { sym: _, span: bytes(6265..6266) }, Punct { char: '>', spacing: Alone, span: bytes(6266..6267) }, Punct { char: '=', spacing: Alone, span: bytes(6268..6269) }, Ident { sym: file_tree, span: bytes(6270..6279) }, Punct { char: '.', spacing: Alone, span: bytes(6279..6280) }, Ident { sym: keys, span: bytes(6280..6284) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(6284..6286) }, Punct { char: '.', spacing: Alone, span: bytes(6286..6287) }, Ident { sym: collect, span: bytes(6287..6294) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(6294..6296) }, Punct { char: ';', spacing: Alone, span: bytes(6296..6297) }, Ident { sym: sorted_files, span: bytes(6310..6322) }, Punct { char: '.', spacing: Alone, span: bytes(6322..6323) }, Ident { sym: sort, span: bytes(6323..6327) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(6327..6329) }, Punct { char: ';', spacing: Alone, span: bytes(6329..6330) }, Ident { sym: for, span: bytes(6344..6347) }, Ident { sym: file_path, span: bytes(6348..6357) }, Ident { sym: in, span: bytes(6358..6360) }, Ident { sym: sorted_files, span: bytes(6361..6373) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: let, span: bytes(6441..6444) }, Ident { sym: file_name, span: bytes(6445..6454) }, Punct { char: '=', spacing: Alone, span: bytes(6455..6456) }, Ident { sym: PathBuf, span: bytes(6457..6464) }, Punct { char: ':', spacing: Joint, span: bytes(6464..6465) }, Punct { char: ':', spacing: Alone, span: bytes(6465..6466) }, Ident { sym: from, span: bytes(6466..6470) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: file_path, span: bytes(6471..6480) }], span: bytes(6470..6481) }, Punct { char: '.', spacing: Alone, span: bytes(6502..6503) }, Ident { sym: file_name, span: bytes(6503..6512) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(6512..6514) }, Punct { char: '.', spacing: Alone, span: bytes(6535..6536) }, Ident { sym: map_or_else, span: bytes(6536..6547) }, Group { delimiter: Parenthesis, stream: TokenStream [Punct { char: '|', spacing: Joint, span: bytes(6548..6549) }, Punct { char: '|', spacing: Alone, span: bytes(6549..6550) }, Ident { sym: file_path, span: bytes(6551..6560) }, Punct { char: '.', spacing: Alone, span: bytes(6560..6561) }, Ident { sym: clone, span: bytes(6561..6566) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(6566..6568) }, Punct { char: ',', spacing: Alone, span: bytes(6568..6569) }, Punct { char: '|', spacing: Alone, span: bytes(6570..6571) }, Ident { sym: n, span: bytes(6571..6572) }, Punct { char: '|', spacing: Alone, span: bytes(6572..6573) }, Ident { sym: n, span: bytes(6574..6575) }, Punct { char: '.', spacing: Alone, span: bytes(6575..6576) }, Ident { sym: to_string_lossy, span: bytes(6576..6591) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(6591..6593) }, Punct { char: '.', spacing: Alone, span: bytes(6593..6594) }, Ident { sym: to_string, span: bytes(6594..6603) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(6603..6605) }], span: bytes(6547..6606) }, Punct { char: ';', spacing: Alone, span: bytes(6606..6607) }, Ident { sym: let, span: bytes(6625..6628) }, Ident { sym: status_opt, span: bytes(6629..6639) }, Punct { char: '=', spacing: Alone, span: bytes(6640..6641) }, Ident { sym: file_status, span: bytes(6642..6653) }, Punct { char: '.', spacing: Alone, span: bytes(6653..6654) }, Ident { sym: get, span: bytes(6654..6657) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: file_path, span: bytes(6658..6667) }], span: bytes(6657..6668) }, Punct { char: '.', spacing: Alone, span: bytes(6668..6669) }, Ident { sym: and_then, span: bytes(6669..6677) }, Group { delimiter: Parenthesis, stream: TokenStream [Punct { char: '|', spacing: Alone, span: bytes(6678..6679) }, Ident { sym: opt, span: bytes(6679..6682) }, Punct { char: '|', spacing: Alone, span: bytes(6682..6683) }, Ident { sym: opt, span: bytes(6684..6687) }, Punct { char: '.', spacing: Alone, span: bytes(6687..6688) }, Ident { sym: as_deref, span: bytes(6688..6696) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(6696..6698) }], span: bytes(6677..6699) }, Punct { char: ';', spacing: Alone, span: bytes(6699..6700) }, Ident { sym: let, span: bytes(6750..6753) }, Ident { sym: label, span: bytes(6754..6759) }, Punct { char: '=', spacing: Alone, span: bytes(6760..6761) }, Ident { sym: match, span: bytes(6762..6767) }, Ident { sym: status_opt, span: bytes(6768..6778) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: Some, span: bytes(6801..6805) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: status, span: bytes(6806..6812) }], span: bytes(6805..6813) }, Punct { char: '=', spacing: Joint, span: bytes(6814..6815) }, Punct { char: '>', spacing: Alone, span: bytes(6815..6816) }, Ident { sym: format, span: bytes(6817..6823) }, Punct { char: '!', spacing: Alone, span: bytes(6823..6824) }, Group { delimiter: Parenthesis, stream: TokenStream [Literal { lit: "{file_name} ({status})", span: bytes(6825..6849) }], span: bytes(6824..6850) }, Punct { char: ',', spacing: Alone, span: bytes(6850..6851) }, Ident { sym: None, span: bytes(6872..6876) }, Punct { char: '=', spacing: Joint, span: bytes(6877..6878) }, Punct { char: '>', spacing: Alone, span: bytes(6878..6879) }, Ident { sym: file_name, span: bytes(6880..6889) }, Punct { char: '.', spacing: Alone, span: bytes(6889..6890) }, Ident { sym: clone, span: bytes(6890..6895) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(6895..6897) }, Punct { char: ',', spacing: Alone, span: bytes(6897..6898) }], span: bytes(6779..6916) }, Punct { char: ';', spacing: Alone, span: bytes(6916..6917) }, Ident { sym: nodes, span: bytes(6935..6940) }, Punct { char: '.', spacing: Alone, span: bytes(6940..6941) }, Ident { sym: push, span: bytes(6941..6945) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: TreeNode, span: bytes(6946..6954) }, Punct { char: ':', spacing: Joint, span: bytes(6954..6955) }, Punct { char: ':', spacing: Alone, span: bytes(6955..6956) }, Ident { sym: file, span: bytes(6956..6960) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: label, span: bytes(6961..6966) }, Punct { char: ',', spacing: Alone, span: bytes(6966..6967) }, Ident { sym: file_path, span: bytes(6968..6977) }, Punct { char: '.', spacing: Alone, span: bytes(6977..6978) }, Ident { sym: clone, span: bytes(6978..6983) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(6983..6985) }, Punct { char: ',', spacing: Alone, span: bytes(6985..6986) }, Literal { lit: 0, span: bytes(6987..6988) }], span: bytes(6960..6989) }], span: bytes(6945..6990) }, Punct { char: ';', spacing: Alone, span: bytes(6990..6991) }, Ident { sym: if, span: bytes(7062..7064) }, Ident { sym: let, span: bytes(7065..7068) }, Ident { sym: Some, span: bytes(7069..7073) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: file_sections, span: bytes(7074..7087) }], span: bytes(7073..7088) }, Punct { char: '=', spacing: Alone, span: bytes(7089..7090) }, Ident { sym: file_tree, span: bytes(7091..7100) }, Punct { char: '.', spacing: Alone, span: bytes(7100..7101) }, Ident { sym: get, span: bytes(7101..7104) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: file_path, span: bytes(7105..7114) }], span: bytes(7104..7115) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: for, span: bytes(7138..7141) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: idx, span: bytes(7143..7146) }, Punct { char: ',', spacing: Alone, span: bytes(7146..7147) }, Ident { sym: section, span: bytes(7148..7155) }], span: bytes(7142..7156) }, Ident { sym: in, span: bytes(7157..7159) }, Ident { sym: file_sections, span: bytes(7160..7173) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: nodes, span: bytes(7200..7205) }, Punct { char: '.', spacing: Alone, span: bytes(7205..7206) }, Ident { sym: push, span: bytes(7206..7210) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: TreeNode, span: bytes(7211..7219) }, Punct { char: ':', spacing: Joint, span: bytes(7219..7220) }, Punct { char: ':', spacing: Alone, span: bytes(7220..7221) }, Ident { sym: section, span: bytes(7221..7228) }, Group { delimiter: Parenthesis, stream: TokenStream [Group { delimiter: Parenthesis, stream: TokenStream [Punct { char: '*', spacing: Alone, span: bytes(7230..7231) }, Ident { sym: section, span: bytes(7231..7238) }], span: bytes(7229..7239) }, Punct { char: '.', spacing: Alone, span: bytes(7239..7240) }, Ident { sym: clone, span: bytes(7240..7245) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(7245..7247) }, Punct { char: ',', spacing: Alone, span: bytes(7247..7248) }, Literal { lit: 1, span: bytes(7249..7250) }, Punct { char: ',', spacing: Alone, span: bytes(7250..7251) }, Punct { char: '*', spacing: Alone, span: bytes(7252..7253) }, Ident { sym: idx, span: bytes(7253..7256) }], span: bytes(7228..7257) }], span: bytes(7210..7258) }, Punct { char: ';', spacing: Alone, span: bytes(7258..7259) }], span: bytes(7174..7281) }], span: bytes(7116..7299) }], span: bytes(6374..7313) }], span: bytes(4947..7323) }, Ident { sym: else, span: bytes(7324..7328) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: let, span: bytes(7438..7441) }, Ident { sym: mut, span: bytes(7442..7445) }, Ident { sym: file_tree, span: bytes(7446..7455) }, Punct { char: ':', spacing: Alone, span: bytes(7455..7456) }, Ident { sym: HashMap, span: bytes(7457..7464) }, Punct { char: '<', spacing: Alone, span: bytes(7464..7465) }, Ident { sym: String, span: bytes(7465..7471) }, Punct { char: ',', spacing: Alone, span: bytes(7471..7472) }, Ident { sym: Vec, span: bytes(7473..7476) }, Punct { char: '<', spacing: Alone, span: bytes(7476..7477) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: usize, span: bytes(7478..7483) }, Punct { char: ',', spacing: Alone, span: bytes(7483..7484) }, Punct { char: '&', spacing: Alone, span: bytes(7485..7486) }, Ident { sym: Section, span: bytes(7486..7493) }], span: bytes(7477..7494) }, Punct { char: '>', spacing: Joint, span: bytes(7494..7495) }, Punct { char: '>', spacing: Alone, span: bytes(7495..7496) }, Punct { char: '=', spacing: Alone, span: bytes(7497..7498) }, Ident { sym: HashMap, span: bytes(7499..7506) }, Punct { char: ':', spacing: Joint, span: bytes(7506..7507) }, Punct { char: ':', spacing: Alone, span: bytes(7507..7508) }, Ident { sym: new, span: bytes(7508..7511) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(7511..7513) }, Punct { char: ';', spacing: Alone, span: bytes(7513..7514) }, Ident { sym: for, span: bytes(7566..7569) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: idx, span: bytes(7571..7574) }, Punct { char: ',', spacing: Alone, span: bytes(7574..7575) }, Ident { sym: section, span: bytes(7576..7583) }], span: bytes(7570..7584) }, Ident { sym: in, span: bytes(7585..7587) }, Ident { sym: sections, span: bytes(7588..7596) }, Punct { char: '.', spacing: Alone, span: bytes(7596..7597) }, Ident { sym: iter, span: bytes(7597..7601) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(7601..7603) }, Punct { char: '.', spacing: Alone, span: bytes(7603..7604) }, Ident { sym: enumerate, span: bytes(7604..7613) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(7613..7615) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: file_tree, span: bytes(7634..7643) }, Punct { char: '.', spacing: Alone, span: bytes(7664..7665) }, Ident { sym: entry, span: bytes(7665..7670) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: section, span: bytes(7671..7678) }, Punct { char: '.', spacing: Alone, span: bytes(7678..7679) }, Ident { sym: file_path, span: bytes(7679..7688) }, Punct { char: '.', spacing: Alone, span: bytes(7688..7689) }, Ident { sym: clone, span: bytes(7689..7694) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(7694..7696) }], span: bytes(7670..7697) }, Punct { char: '.', spacing: Alone, span: bytes(7718..7719) }, Ident { sym: or_default, span: bytes(7719..7729) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(7729..7731) }, Punct { char: '.', spacing: Alone, span: bytes(7752..7753) }, Ident { sym: push, span: bytes(7753..7757) }, Group { delimiter: Parenthesis, stream: TokenStream [Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: idx, span: bytes(7759..7762) }, Punct { char: ',', spacing: Alone, span: bytes(7762..7763) }, Ident { sym: section, span: bytes(7764..7771) }], span: bytes(7758..7772) }], span: bytes(7757..7773) }, Punct { char: ';', spacing: Alone, span: bytes(7773..7774) }], span: bytes(7616..7788) }, Ident { sym: let, span: bytes(7853..7856) }, Ident { sym: mut, span: bytes(7857..7860) }, Ident { sym: sorted_files, span: bytes(7861..7873) }, Punct { char: ':', spacing: Alone, span: bytes(7873..7874) }, Ident { sym: Vec, span: bytes(7875..7878) }, Punct { char: '<', spacing: Alone, span: bytes(7878..7879) }, Ident { sym: _, span: bytes(7879..7880) }, Punct { char: '>', spacing: Alone, span: bytes(7880..7881) }, Punct { char: '=', spacing: Alone, span: bytes(7882..7883) }, Ident { sym: files, span: bytes(7884..7889) }, Punct { char: '.', spacing: Alone, span: bytes(7889..7890) }, Ident { sym: iter, span: bytes(7890..7894) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(7894..7896) }, Punct { char: '.', spacing: Alone, span: bytes(7896..7897) }, Ident { sym: collect, span: bytes(7897..7904) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(7904..7906) }, Punct { char: ';', spacing: Alone, span: bytes(7906..7907) }, Ident { sym: sorted_files, span: bytes(7920..7932) }, Punct { char: '.', spacing: Alone, span: bytes(7932..7933) }, Ident { sym: sort, span: bytes(7933..7937) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(7937..7939) }, Punct { char: ';', spacing: Alone, span: bytes(7939..7940) }, Ident { sym: for, span: bytes(7954..7957) }, Ident { sym: file_path, span: bytes(7958..7967) }, Ident { sym: in, span: bytes(7968..7970) }, Ident { sym: sorted_files, span: bytes(7971..7983) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: let, span: bytes(8002..8005) }, Ident { sym: path_str, span: bytes(8006..8014) }, Punct { char: '=', spacing: Alone, span: bytes(8015..8016) }, Ident { sym: file_path, span: bytes(8017..8026) }, Punct { char: '.', spacing: Alone, span: bytes(8026..8027) }, Ident { sym: to_string_lossy, span: bytes(8027..8042) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(8042..8044) }, Punct { char: '.', spacing: Alone, span: bytes(8044..8045) }, Ident { sym: to_string, span: bytes(8045..8054) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(8054..8056) }, Punct { char: ';', spacing: Alone, span: bytes(8056..8057) }, Ident { sym: let, span: bytes(8124..8127) }, Ident { sym: file_name, span: bytes(8128..8137) }, Punct { char: '=', spacing: Alone, span: bytes(8138..8139) }, Ident { sym: file_path, span: bytes(8140..8149) }, Punct { char: '.', spacing: Alone, span: bytes(8170..8171) }, Ident { sym: file_name, span: bytes(8171..8180) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(8180..8182) }, Punct { char: '.', spacing: Alone, span: bytes(8203..8204) }, Ident { sym: map_or_else, span: bytes(8204..8215) }, Group { delimiter: Parenthesis, stream: TokenStream [Punct { char: '|', spacing: Joint, span: bytes(8216..8217) }, Punct { char: '|', spacing: Alone, span: bytes(8217..8218) }, Ident { sym: path_str, span: bytes(8219..8227) }, Punct { char: '.', spacing: Alone, span: bytes(8227..8228) }, Ident { sym: clone, span: bytes(8228..8233) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(8233..8235) }, Punct { char: ',', spacing: Alone, span: bytes(8235..8236) }, Punct { char: '|', spacing: Alone, span: bytes(8237..8238) }, Ident { sym: n, span: bytes(8238..8239) }, Punct { char: '|', spacing: Alone, span: bytes(8239..8240) }, Ident { sym: n, span: bytes(8241..8242) }, Punct { char: '.', spacing: Alone, span: bytes(8242..8243) }, Ident { sym: to_string_lossy, span: bytes(8243..8258) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(8258..8260) }, Punct { char: '.', spacing: Alone, span: bytes(8260..8261) }, Ident { sym: to_string, span: bytes(8261..8270) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(8270..8272) }], span: bytes(8215..8273) }, Punct { char: ';', spacing: Alone, span: bytes(8273..8274) }, Ident { sym: nodes, span: bytes(8292..8297) }, Punct { char: '.', spacing: Alone, span: bytes(8297..8298) }, Ident { sym: push, span: bytes(8298..8302) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: TreeNode, span: bytes(8303..8311) }, Punct { char: ':', spacing: Joint, span: bytes(8311..8312) }, Punct { char: ':', spacing: Alone, span: bytes(8312..8313) }, Ident { sym: file, span: bytes(8313..8317) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: file_name, span: bytes(8318..8327) }, Punct { char: '.', spacing: Alone, span: bytes(8327..8328) }, Ident { sym: clone, span: bytes(8328..8333) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(8333..8335) }, Punct { char: ',', spacing: Alone, span: bytes(8335..8336) }, Ident { sym: path_str, span: bytes(8337..8345) }, Punct { char: '.', spacing: Alone, span: bytes(8345..8346) }, Ident { sym: clone, span: bytes(8346..8351) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(8351..8353) }, Punct { char: ',', spacing: Alone, span: bytes(8353..8354) }, Literal { lit: 0, span: bytes(8355..8356) }], span: bytes(8317..8357) }], span: bytes(8302..8358) }, Punct { char: ';', spacing: Alone, span: bytes(8358..8359) }, Ident { sym: if, span: bytes(8425..8427) }, Ident { sym: let, span: bytes(8428..8431) }, Ident { sym: Some, span: bytes(8432..8436) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: file_sections, span: bytes(8437..8450) }], span: bytes(8436..8451) }, Punct { char: '=', spacing: Alone, span: bytes(8452..8453) }, Ident { sym: file_tree, span: bytes(8454..8463) }, Punct { char: '.', spacing: Alone, span: bytes(8463..8464) }, Ident { sym: get, span: bytes(8464..8467) }, Group { delimiter: Parenthesis, stream: TokenStream [Punct { char: '&', spacing: Alone, span: bytes(8468..8469) }, Ident { sym: path_str, span: bytes(8469..8477) }], span: bytes(8467..8478) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: for, span: bytes(8501..8504) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: idx, span: bytes(8506..8509) }, Punct { char: ',', spacing: Alone, span: bytes(8509..8510) }, Ident { sym: section, span: bytes(8511..8518) }], span: bytes(8505..8519) }, Ident { sym: in, span: bytes(8520..8522) }, Ident { sym: file_sections, span: bytes(8523..8536) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: nodes, span: bytes(8563..8568) }, Punct { char: '.', spacing: Alone, span: bytes(8568..8569) }, Ident { sym: push, span: bytes(8569..8573) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: TreeNode, span: bytes(8574..8582) }, Punct { char: ':', spacing: Joint, span: bytes(8582..8583) }, Punct { char: ':', spacing: Alone, span: bytes(8583..8584) }, Ident { sym: section, span: bytes(8584..8591) }, Group { delimiter: Parenthesis, stream: TokenStream [Group { delimiter: Parenthesis, stream: TokenStream [Punct { char: '*', spacing: Alone, span: bytes(8593..8594) }, Ident { sym: section, span: bytes(8594..8601) }], span: bytes(8592..8602) }, Punct { char: '.', spacing: Alone, span: bytes(8602..8603) }, Ident { sym: clone, span: bytes(8603..8608) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(8608..8610) }, Punct { char: ',', spacing: Alone, span: bytes(8610..8611) }, Ident { sym: section, span: bytes(8612..8619) }, Punct { char: '.', spacing: Alone, span: bytes(8619..8620) }, Ident { sym: level, span: bytes(8620..8625) }, Punct { char: ',', spacing: Alone, span: bytes(8625..8626) }, Punct { char: '*', spacing: Alone, span: bytes(8627..8628) }, Ident { sym: idx, span: bytes(8628..8631) }], span: bytes(8591..8632) }], span: bytes(8573..8633) }, Punct { char: ';', spacing: Alone, span: bytes(8633..8634) }], span: bytes(8537..8656) }], span: bytes(8479..8674) }], span: bytes(7984..8688) }], span: bytes(7329..8698) }, Ident { sym: nodes, span: bytes(8708..8713) }], span: bytes(4053..8719) }) }), delimiter: Some(Nothing) }, Delimited<syncdoc_core::parse::ModuleItem, unsynn::fundamental::Nothing> { value: Function(FnSig { attributes: Some(Repeats<1, 18446744073709551615, syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing>([Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: doc, span: bytes(8725..8782) }, Punct { char: '=', spacing: Alone, span: bytes(8725..8782) }, Literal { lit: " Rebuild tree after sections change (e.g., after save)", span: bytes(8725..8782) }], span: bytes(8725..8782) }) }, delimiter: Some(Nothing) }])), visibility: Some(Public(KPub(Cached<proc_macro2::Ident> { value: Ident { sym: pub, span: bytes(8787..8790) }, string: "pub" }))), const_kw: None, async_kw: None, unsafe_kw: None, extern_kw: None, _fn: KFn(Cached<proc_macro2::Ident> { value: Ident { sym: fn, span: bytes(8791..8793) }, string: "fn" }), name: Ident { sym: rebuild_tree, span: bytes(8794..8806) }, generics: None, params: ParenthesisGroupContaining < core::option::Option<unsynn::container::DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>>>(Some(DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>([Delimited<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>> { value: SelfParam(RefMut(Cons<unsynn::operator::Operator<'&'>, unsynn::combinator::Cons<syncdoc_core::parse::KMut, syncdoc_core::parse::KSelf>> { first: Operator<'&'>, second: Cons<syncdoc_core::parse::KMut, syncdoc_core::parse::KSelf> { first: KMut(Cached<proc_macro2::Ident> { value: Ident { sym: mut, span: bytes(8808..8811) }, string: "mut" }), second: KSelf(Cached<proc_macro2::Ident> { value: Ident { sym: self, span: bytes(8812..8816) }, string: "self" }) } })), delimiter: None }]))), return_type: None, where_clause: None, body: BraceGroup(Group { delimiter: Brace, stream: TokenStream [Ident { sym: self, span: bytes(8828..8832) }, Punct { char: '.', spacing: Alone, span: bytes(8832..8833) }, Ident { sym: tree_nodes, span: bytes(8833..8843) }, Punct { char: '=', spacing: Alone, span: bytes(8844..8845) }, Ident { sym: Self, span: bytes(8846..8850) }, Punct { char: ':', spacing: Joint, span: bytes(8850..8851) }, Punct { char: ':', spacing: Alone, span: bytes(8851..8852) }, Ident { sym: build_tree, span: bytes(8852..8862) }, Group { delimiter: Parenthesis, stream: TokenStream [Punct { char: '&', spacing: Alone, span: bytes(8863..8864) }, Ident { sym: self, span: bytes(8864..8868) }, Punct { char: '.', spacing: Alone, span: bytes(8868..8869) }, Ident { sym: files, span: bytes(8869..8874) }, Punct { char: ',', spacing: Alone, span: bytes(8874..8875) }, Punct { char: '&', spacing: Alone, span: bytes(8876..8877) }, Ident { sym: self, span: bytes(8877..8881) }, Punct { char: '.', spacing: Alone, span: bytes(8881..8882) }, Ident { sym: sections, span: bytes(8882..8890) }], span: bytes(8862..8891) }, Punct { char: ';', spacing: Alone, span: bytes(8891..8892) }, Ident { sym: if, span: bytes(8970..8972) }, Ident { sym: let, span: bytes(8973..8976) }, Ident { sym: Some, span: bytes(8977..8981) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: current_section_idx, span: bytes(8982..9001) }], span: bytes(8981..9002) }, Punct { char: '=', spacing: Alone, span: bytes(9003..9004) }, Ident { sym: self, span: bytes(9005..9009) }, Punct { char: '.', spacing: Alone, span: bytes(9009..9010) }, Ident { sym: get_current_section_index, span: bytes(9010..9035) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(9035..9037) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: if, span: bytes(9052..9054) }, Ident { sym: let, span: bytes(9055..9058) }, Ident { sym: Some, span: bytes(9059..9063) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: node_idx, span: bytes(9064..9072) }], span: bytes(9063..9073) }, Punct { char: '=', spacing: Alone, span: bytes(9074..9075) }, Ident { sym: self, span: bytes(9076..9080) }, Punct { char: '.', spacing: Alone, span: bytes(9097..9098) }, Ident { sym: tree_nodes, span: bytes(9098..9108) }, Punct { char: '.', spacing: Alone, span: bytes(9125..9126) }, Ident { sym: iter, span: bytes(9126..9130) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(9130..9132) }, Punct { char: '.', spacing: Alone, span: bytes(9149..9150) }, Ident { sym: position, span: bytes(9150..9158) }, Group { delimiter: Parenthesis, stream: TokenStream [Punct { char: '|', spacing: Alone, span: bytes(9159..9160) }, Ident { sym: n, span: bytes(9160..9161) }, Punct { char: '|', spacing: Alone, span: bytes(9161..9162) }, Ident { sym: n, span: bytes(9163..9164) }, Punct { char: '.', spacing: Alone, span: bytes(9164..9165) }, Ident { sym: section_index, span: bytes(9165..9178) }, Punct { char: '=', spacing: Joint, span: bytes(9179..9180) }, Punct { char: '=', spacing: Alone, span: bytes(9180..9181) }, Ident { sym: Some, span: bytes(9182..9186) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: current_section_idx, span: bytes(9187..9206) }], span: bytes(9186..9207) }], span: bytes(9158..9208) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: self, span: bytes(9239..9243) }, Punct { char: '.', spacing: Alone, span: bytes(9243..9244) }, Ident { sym: current_node_index, span: bytes(9244..9262) }, Punct { char: '=', spacing: Alone, span: bytes(9263..9264) }, Ident { sym: node_idx, span: bytes(9265..9273) }, Punct { char: ';', spacing: Alone, span: bytes(9273..9274) }], span: bytes(9221..9288) }], span: bytes(9038..9298) }], span: bytes(8818..9304) }) }), delimiter: Some(Nothing) }, Delimited<syncdoc_core::parse::ModuleItem, unsynn::fundamental::Nothing> { value: Function(FnSig { attributes: Some(Repeats<1, 18446744073709551615, syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing>([Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: doc, span: bytes(9310..9387) }, Punct { char: '=', spacing: Alone, span: bytes(9310..9387) }, Literal { lit: " Get the section index for the currently selected node (if it's a section)", span: bytes(9310..9387) }], span: bytes(9310..9387) }) }, delimiter: Some(Nothing) }, Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: must_use, span: bytes(9394..9402) }], span: bytes(9393..9403) }) }, delimiter: Some(Nothing) }])), visibility: Some(Public(KPub(Cached<proc_macro2::Ident> { value: Ident { sym: pub, span: bytes(9408..9411) }, string: "pub" }))), const_kw: None, async_kw: None, unsafe_kw: None, extern_kw: None, _fn: KFn(Cached<proc_macro2::Ident> { value: Ident { sym: fn, span: bytes(9412..9414) }, string: "fn" }), name: Ident { sym: get_current_section_index, span: bytes(9415..9440) }, generics: None, params: ParenthesisGroupContaining < core::option::Option<unsynn::container::DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>>>(Some(DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>([Delimited<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>> { value: SelfParam(Ref(Cons<unsynn::operator::Operator<'&'>, syncdoc_core::parse::KSelf> { first: Operator<'&'>, second: KSelf(Cached<proc_macro2::Ident> { value: Ident { sym: self, span: bytes(9442..9446) }, string: "self" }) })), delimiter: None }]))), return_type: Some(ReturnTypeFn { _arrow: Operator<'->'>, return_type: Repeats<1, 18446744073709551615, unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing>([Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::group::BraceGroup>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Ident { sym: Option, span: bytes(9451..9457) })) }, delimiter: Some(Nothing) }, Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::group::BraceGroup>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>> { first: Operator<'<'>, second: [Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::operator::Operator<'>'>>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Ident { sym: usize, span: bytes(9458..9463) })) }], third: Operator<'>'> })) }, delimiter: Some(Nothing) }]) }), where_clause: None, body: BraceGroup(Group { delimiter: Brace, stream: TokenStream [Ident { sym: if, span: bytes(9475..9477) }, Ident { sym: self, span: bytes(9478..9482) }, Punct { char: '.', spacing: Alone, span: bytes(9482..9483) }, Ident { sym: current_node_index, span: bytes(9483..9501) }, Punct { char: '<', spacing: Alone, span: bytes(9502..9503) }, Ident { sym: self, span: bytes(9504..9508) }, Punct { char: '.', spacing: Alone, span: bytes(9508..9509) }, Ident { sym: tree_nodes, span: bytes(9509..9519) }, Punct { char: '.', spacing: Alone, span: bytes(9519..9520) }, Ident { sym: len, span: bytes(9520..9523) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(9523..9525) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: self, span: bytes(9540..9544) }, Punct { char: '.', spacing: Alone, span: bytes(9544..9545) }, Ident { sym: tree_nodes, span: bytes(9545..9555) }, Group { delimiter: Bracket, stream: TokenStream [Ident { sym: self, span: bytes(9556..9560) }, Punct { char: '.', spacing: Alone, span: bytes(9560..9561) }, Ident { sym: current_node_index, span: bytes(9561..9579) }], span: bytes(9555..9580) }, Punct { char: '.', spacing: Alone, span: bytes(9580..9581) }, Ident { sym: section_index, span: bytes(9581..9594) }], span: bytes(9526..9604) }, Ident { sym: else, span: bytes(9605..9609) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: None, span: bytes(9624..9628) }], span: bytes(9610..9638) }], span: bytes(9465..9644) }) }), delimiter: Some(Nothing) }, Delimited<syncdoc_core::parse::ModuleItem, unsynn::fundamental::Nothing> { value: Function(FnSig { attributes: Some(Repeats<1, 18446744073709551615, syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing>([Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: doc, span: bytes(9650..9700) }, Punct { char: '=', spacing: Alone, span: bytes(9650..9700) }, Literal { lit: " Get the current section (if on a section node)", span: bytes(9650..9700) }], span: bytes(9650..9700) }) }, delimiter: Some(Nothing) }, Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: must_use, span: bytes(9707..9715) }], span: bytes(9706..9716) }) }, delimiter: Some(Nothing) }])), visibility: Some(Public(KPub(Cached<proc_macro2::Ident> { value: Ident { sym: pub, span: bytes(9721..9724) }, string: "pub" }))), const_kw: None, async_kw: None, unsafe_kw: None, extern_kw: None, _fn: KFn(Cached<proc_macro2::Ident> { value: Ident { sym: fn, span: bytes(9725..9727) }, string: "fn" }), name: Ident { sym: get_current_section, span: bytes(9728..9747) }, generics: None, params: ParenthesisGroupContaining < core::option::Option<unsynn::container::DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>>>(Some(DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>([Delimited<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>> { value: SelfParam(Ref(Cons<unsynn::operator::Operator<'&'>, syncdoc_core::parse::KSelf> { first: Operator<'&'>, second: KSelf(Cached<proc_macro2::Ident> { value: Ident { sym: self, span: bytes(9749..9753) }, string: "self" }) })), delimiter: None }]))), return_type: Some(ReturnTypeFn { _arrow: Operator<'->'>, return_type: Repeats<1, 18446744073709551615, unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing>([Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::group::BraceGroup>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Ident { sym: Option, span: bytes(9758..9764) })) }, delimiter: Some(Nothing) }, Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::group::BraceGroup>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>> { first: Operator<'<'>, second: [Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::operator::Operator<'>'>>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Punct { char: '&', spacing: Alone, span: bytes(9765..9766) })) }, Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::operator::Operator<'>'>>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Ident { sym: Section, span: bytes(9766..9773) })) }], third: Operator<'>'> })) }, delimiter: Some(Nothing) }]) }), where_clause: None, body: BraceGroup(Group { delimiter: Brace, stream: TokenStream [Ident { sym: self, span: bytes(9785..9789) }, Punct { char: '.', spacing: Alone, span: bytes(9789..9790) }, Ident { sym: get_current_section_index, span: bytes(9790..9815) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(9815..9817) }, Punct { char: '.', spacing: Alone, span: bytes(9830..9831) }, Ident { sym: and_then, span: bytes(9831..9839) }, Group { delimiter: Parenthesis, stream: TokenStream [Punct { char: '|', spacing: Alone, span: bytes(9840..9841) }, Ident { sym: idx, span: bytes(9841..9844) }, Punct { char: '|', spacing: Alone, span: bytes(9844..9845) }, Ident { sym: self, span: bytes(9846..9850) }, Punct { char: '.', spacing: Alone, span: bytes(9850..9851) }, Ident { sym: sections, span: bytes(9851..9859) }, Punct { char: '.', spacing: Alone, span: bytes(9859..9860) }, Ident { sym: get, span: bytes(9860..9863) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: idx, span: bytes(9864..9867) }], span: bytes(9863..9868) }], span: bytes(9839..9869) }], span: bytes(9775..9875) }) }), delimiter: Some(Nothing) }, Delimited<syncdoc_core::parse::ModuleItem, unsynn::fundamental::Nothing> { value: Function(FnSig { attributes: None, visibility: None, const_kw: None, async_kw: None, unsafe_kw: None, extern_kw: None, _fn: KFn(Cached<proc_macro2::Ident> { value: Ident { sym: fn, span: bytes(9881..9883) }, string: "fn" }), name: Ident { sym: rebuild_file_offsets, span: bytes(9884..9904) }, generics: None, params: ParenthesisGroupContaining < core::option::Option<unsynn::container::DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>>>(Some(DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>([Delimited<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>> { value: SelfParam(RefMut(Cons<unsynn::operator::Operator<'&'>, unsynn::combinator::Cons<syncdoc_core::parse::KMut, syncdoc_core::parse::KSelf>> { first: Operator<'&'>, second: Cons<syncdoc_core::parse::KMut, syncdoc_core::parse::KSelf> { first: KMut(Cached<proc_macro2::Ident> { value: Ident { sym: mut, span: bytes(9906..9909) }, string: "mut" }), second: KSelf(Cached<proc_macro2::Ident> { value: Ident { sym: self, span: bytes(9910..9914) }, string: "self" }) } })), delimiter: None }]))), return_type: None, where_clause: None, body: BraceGroup(Group { delimiter: Brace, stream: TokenStream [Ident { sym: self, span: bytes(9926..9930) }, Punct { char: '.', spacing: Alone, span: bytes(9930..9931) }, Ident { sym: file_offsets, span: bytes(9931..9943) }, Punct { char: '.', spacing: Alone, span: bytes(9943..9944) }, Ident { sym: clear, span: bytes(9944..9949) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(9949..9951) }, Punct { char: ';', spacing: Alone, span: bytes(9951..9952) }, Ident { sym: if, span: bytes(9962..9964) }, Ident { sym: let, span: bytes(9965..9968) }, Ident { sym: Some, span: bytes(9969..9973) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: section_idx, span: bytes(9974..9985) }], span: bytes(9973..9986) }, Punct { char: '=', spacing: Alone, span: bytes(9987..9988) }, Ident { sym: self, span: bytes(9989..9993) }, Punct { char: '.', spacing: Alone, span: bytes(9993..9994) }, Ident { sym: get_current_section_index, span: bytes(9994..10019) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(10019..10021) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: if, span: bytes(10036..10038) }, Ident { sym: let, span: bytes(10039..10042) }, Ident { sym: Some, span: bytes(10043..10047) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: section, span: bytes(10048..10055) }], span: bytes(10047..10056) }, Punct { char: '=', spacing: Alone, span: bytes(10057..10058) }, Ident { sym: self, span: bytes(10059..10063) }, Punct { char: '.', spacing: Alone, span: bytes(10063..10064) }, Ident { sym: sections, span: bytes(10064..10072) }, Punct { char: '.', spacing: Alone, span: bytes(10072..10073) }, Ident { sym: get, span: bytes(10073..10076) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: section_idx, span: bytes(10077..10088) }], span: bytes(10076..10089) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: let, span: bytes(10108..10111) }, Ident { sym: lines_added, span: bytes(10112..10123) }, Punct { char: '=', spacing: Alone, span: bytes(10124..10125) }, Ident { sym: self, span: bytes(10126..10130) }, Punct { char: '.', spacing: Alone, span: bytes(10130..10131) }, Ident { sym: editor_state, span: bytes(10131..10143) }, Punct { char: '.', spacing: Alone, span: bytes(10143..10144) }, Ident { sym: as_ref, span: bytes(10144..10150) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(10150..10152) }, Punct { char: '.', spacing: Alone, span: bytes(10152..10153) }, Ident { sym: map_or, span: bytes(10153..10159) }, Group { delimiter: Parenthesis, stream: TokenStream [Literal { lit: 0, span: bytes(10160..10161) }, Punct { char: ',', spacing: Alone, span: bytes(10161..10162) }, Punct { char: '|', spacing: Alone, span: bytes(10163..10164) }, Ident { sym: es, span: bytes(10164..10166) }, Punct { char: '|', spacing: Alone, span: bytes(10166..10167) }, Ident { sym: es, span: bytes(10168..10170) }, Punct { char: '.', spacing: Alone, span: bytes(10170..10171) }, Ident { sym: lines, span: bytes(10171..10176) }, Punct { char: '.', spacing: Alone, span: bytes(10176..10177) }, Ident { sym: len, span: bytes(10177..10180) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(10180..10182) }], span: bytes(10159..10183) }, Punct { char: ';', spacing: Alone, span: bytes(10183..10184) }, Ident { sym: let, span: bytes(10202..10205) }, Ident { sym: file_map, span: bytes(10206..10214) }, Punct { char: '=', spacing: Alone, span: bytes(10215..10216) }, Ident { sym: self, span: bytes(10217..10221) }, Punct { char: '.', spacing: Alone, span: bytes(10242..10243) }, Ident { sym: file_offsets, span: bytes(10243..10255) }, Punct { char: '.', spacing: Alone, span: bytes(10276..10277) }, Ident { sym: entry, span: bytes(10277..10282) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: section, span: bytes(10283..10290) }, Punct { char: '.', spacing: Alone, span: bytes(10290..10291) }, Ident { sym: file_path, span: bytes(10291..10300) }, Punct { char: '.', spacing: Alone, span: bytes(10300..10301) }, Ident { sym: clone, span: bytes(10301..10306) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(10306..10308) }], span: bytes(10282..10309) }, Punct { char: '.', spacing: Alone, span: bytes(10330..10331) }, Ident { sym: or_default, span: bytes(10331..10341) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(10341..10343) }, Punct { char: ';', spacing: Alone, span: bytes(10343..10344) }, Ident { sym: file_map, span: bytes(10362..10370) }, Punct { char: '.', spacing: Alone, span: bytes(10370..10371) }, Ident { sym: insert, span: bytes(10371..10377) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: section, span: bytes(10378..10385) }, Punct { char: '.', spacing: Alone, span: bytes(10385..10386) }, Ident { sym: line_start, span: bytes(10386..10396) }, Punct { char: ',', spacing: Alone, span: bytes(10396..10397) }, Ident { sym: lines_added, span: bytes(10398..10409) }], span: bytes(10377..10410) }, Punct { char: ';', spacing: Alone, span: bytes(10410..10411) }], span: bytes(10090..10425) }], span: bytes(10022..10435) }], span: bytes(9916..10441) }) }), delimiter: Some(Nothing) }, Delimited<syncdoc_core::parse::ModuleItem, unsynn::fundamental::Nothing> { value: Function(FnSig { attributes: Some(Repeats<1, 18446744073709551615, syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing>([Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: doc, span: bytes(10447..10533) }, Punct { char: '=', spacing: Alone, span: bytes(10447..10533) }, Literal { lit: " Calculates total lines added before a section to determine correct write position.", span: bytes(10447..10533) }], span: bytes(10447..10533) }) }, delimiter: Some(Nothing) }, Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: must_use, span: bytes(10540..10548) }], span: bytes(10539..10549) }) }, delimiter: Some(Nothing) }])), visibility: Some(Public(KPub(Cached<proc_macro2::Ident> { value: Ident { sym: pub, span: bytes(10554..10557) }, string: "pub" }))), const_kw: None, async_kw: None, unsafe_kw: None, extern_kw: None, _fn: KFn(Cached<proc_macro2::Ident> { value: Ident { sym: fn, span: bytes(10558..10560) }, string: "fn" }), name: Ident { sym: cumulative_offset, span: bytes(10561..10578) }, generics: None, params: ParenthesisGroupContaining < core::option::Option<unsynn::container::DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>>>(Some(DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>([Delimited<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>> { value: SelfParam(Ref(Cons<unsynn::operator::Operator<'&'>, syncdoc_core::parse::KSelf> { first: Operator<'&'>, second: KSelf(Cached<proc_macro2::Ident> { value: Ident { sym: self, span: bytes(10580..10584) }, string: "self" }) })), delimiter: Some(Operator<','>) }, Delimited<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>> { value: Named(NamedParam { mut_kw: None, name: Ident { sym: index, span: bytes(10586..10591) }, _colon: Operator<':'>, param_type: Repeats<1, 18446744073709551615, unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<','>>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing>([Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<','>>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::operator::Operator<','>>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::operator::Operator<','>>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Ident { sym: usize, span: bytes(10593..10598) })) }, delimiter: Some(Nothing) }]) }), delimiter: None }]))), return_type: Some(ReturnTypeFn { _arrow: Operator<'->'>, return_type: Repeats<1, 18446744073709551615, unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing>([Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::group::BraceGroup>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Ident { sym: usize, span: bytes(10603..10608) })) }, delimiter: Some(Nothing) }]) }), where_clause: None, body: BraceGroup(Group { delimiter: Brace, stream: TokenStream [Ident { sym: let, span: bytes(10619..10622) }, Ident { sym: section, span: bytes(10623..10630) }, Punct { char: '=', spacing: Alone, span: bytes(10631..10632) }, Punct { char: '&', spacing: Alone, span: bytes(10633..10634) }, Ident { sym: self, span: bytes(10634..10638) }, Punct { char: '.', spacing: Alone, span: bytes(10638..10639) }, Ident { sym: sections, span: bytes(10639..10647) }, Group { delimiter: Bracket, stream: TokenStream [Ident { sym: index, span: bytes(10648..10653) }], span: bytes(10647..10654) }, Punct { char: ';', spacing: Alone, span: bytes(10654..10655) }, Ident { sym: let, span: bytes(10664..10667) }, Ident { sym: target_file, span: bytes(10668..10679) }, Punct { char: '=', spacing: Alone, span: bytes(10680..10681) }, Punct { char: '&', spacing: Alone, span: bytes(10682..10683) }, Ident { sym: section, span: bytes(10683..10690) }, Punct { char: '.', spacing: Alone, span: bytes(10690..10691) }, Ident { sym: file_path, span: bytes(10691..10700) }, Punct { char: ';', spacing: Alone, span: bytes(10700..10701) }, Ident { sym: let, span: bytes(10710..10713) }, Ident { sym: target_line, span: bytes(10714..10725) }, Punct { char: '=', spacing: Alone, span: bytes(10726..10727) }, Ident { sym: section, span: bytes(10728..10735) }, Punct { char: '.', spacing: Alone, span: bytes(10735..10736) }, Ident { sym: line_start, span: bytes(10736..10746) }, Punct { char: ';', spacing: Alone, span: bytes(10746..10747) }, Ident { sym: if, span: bytes(10757..10759) }, Ident { sym: let, span: bytes(10760..10763) }, Ident { sym: Some, span: bytes(10764..10768) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: file_map, span: bytes(10769..10777) }], span: bytes(10768..10778) }, Punct { char: '=', spacing: Alone, span: bytes(10779..10780) }, Ident { sym: self, span: bytes(10781..10785) }, Punct { char: '.', spacing: Alone, span: bytes(10785..10786) }, Ident { sym: file_offsets, span: bytes(10786..10798) }, Punct { char: '.', spacing: Alone, span: bytes(10798..10799) }, Ident { sym: get, span: bytes(10799..10802) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: target_file, span: bytes(10803..10814) }], span: bytes(10802..10815) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: file_map, span: bytes(10830..10838) }, Punct { char: '.', spacing: Alone, span: bytes(10855..10856) }, Ident { sym: iter, span: bytes(10856..10860) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(10860..10862) }, Punct { char: '.', spacing: Alone, span: bytes(10879..10880) }, Ident { sym: filter, span: bytes(10880..10886) }, Group { delimiter: Parenthesis, stream: TokenStream [Punct { char: '|', spacing: Alone, span: bytes(10887..10888) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: line, span: bytes(10889..10893) }, Punct { char: ',', spacing: Alone, span: bytes(10893..10894) }, Ident { sym: _, span: bytes(10895..10896) }], span: bytes(10888..10897) }, Punct { char: '|', spacing: Alone, span: bytes(10897..10898) }, Punct { char: '*', spacing: Joint, span: bytes(10899..10900) }, Punct { char: '*', spacing: Alone, span: bytes(10900..10901) }, Ident { sym: line, span: bytes(10901..10905) }, Punct { char: '<', spacing: Alone, span: bytes(10906..10907) }, Ident { sym: target_line, span: bytes(10908..10919) }], span: bytes(10886..10920) }, Punct { char: '.', spacing: Alone, span: bytes(10937..10938) }, Ident { sym: map, span: bytes(10938..10941) }, Group { delimiter: Parenthesis, stream: TokenStream [Punct { char: '|', spacing: Alone, span: bytes(10942..10943) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: _, span: bytes(10944..10945) }, Punct { char: ',', spacing: Alone, span: bytes(10945..10946) }, Ident { sym: offset, span: bytes(10947..10953) }], span: bytes(10943..10954) }, Punct { char: '|', spacing: Alone, span: bytes(10954..10955) }, Ident { sym: offset, span: bytes(10956..10962) }], span: bytes(10941..10963) }, Punct { char: '.', spacing: Alone, span: bytes(10980..10981) }, Ident { sym: sum, span: bytes(10981..10984) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(10984..10986) }], span: bytes(10816..10996) }, Ident { sym: else, span: bytes(10997..11001) }, Group { delimiter: Brace, stream: TokenStream [Literal { lit: 0, span: bytes(11016..11017) }], span: bytes(11002..11027) }], span: bytes(10609..11033) }) }), delimiter: Some(Nothing) }, Delimited<syncdoc_core::parse::ModuleItem, unsynn::fundamental::Nothing> { value: Function(FnSig { attributes: Some(Repeats<1, 18446744073709551615, syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing>([Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: doc, span: bytes(11039..11101) }, Punct { char: '=', spacing: Alone, span: bytes(11039..11101) }, Literal { lit: " Restores previously edited content from a saved edit plan.", span: bytes(11039..11101) }], span: bytes(11039..11101) }) }, delimiter: Some(Nothing) }])), visibility: Some(Public(KPub(Cached<proc_macro2::Ident> { value: Ident { sym: pub, span: bytes(11106..11109) }, string: "pub" }))), const_kw: None, async_kw: None, unsafe_kw: None, extern_kw: None, _fn: KFn(Cached<proc_macro2::Ident> { value: Ident { sym: fn, span: bytes(11110..11112) }, string: "fn" }), name: Ident { sym: load_docs, span: bytes(11113..11122) }, generics: None, params: ParenthesisGroupContaining < core::option::Option<unsynn::container::DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>>>(Some(DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>([Delimited<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>> { value: SelfParam(RefMut(Cons<unsynn::operator::Operator<'&'>, unsynn::combinator::Cons<syncdoc_core::parse::KMut, syncdoc_core::parse::KSelf>> { first: Operator<'&'>, second: Cons<syncdoc_core::parse::KMut, syncdoc_core::parse::KSelf> { first: KMut(Cached<proc_macro2::Ident> { value: Ident { sym: mut, span: bytes(11124..11127) }, string: "mut" }), second: KSelf(Cached<proc_macro2::Ident> { value: Ident { sym: self, span: bytes(11128..11132) }, string: "self" }) } })), delimiter: Some(Operator<','>) }, Delimited<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>> { value: Named(NamedParam { mut_kw: None, name: Ident { sym: plan, span: bytes(11134..11138) }, _colon: Operator<':'>, param_type: Repeats<1, 18446744073709551615, unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<','>>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing>([Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<','>>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::operator::Operator<','>>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::operator::Operator<','>>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Ident { sym: EditPlan, span: bytes(11140..11148) })) }, delimiter: Some(Nothing) }]) }), delimiter: None }]))), return_type: None, where_clause: None, body: BraceGroup(Group { delimiter: Brace, stream: TokenStream [Ident { sym: let, span: bytes(11160..11163) }, Ident { sym: mut, span: bytes(11164..11167) }, Ident { sym: doc_map, span: bytes(11168..11175) }, Punct { char: ':', spacing: Alone, span: bytes(11175..11176) }, Ident { sym: HashMap, span: bytes(11177..11184) }, Punct { char: '<', spacing: Alone, span: bytes(11184..11185) }, Ident { sym: String, span: bytes(11185..11191) }, Punct { char: ',', spacing: Alone, span: bytes(11191..11192) }, Ident { sym: Vec, span: bytes(11193..11196) }, Punct { char: '<', spacing: Alone, span: bytes(11196..11197) }, Ident { sym: String, span: bytes(11197..11203) }, Punct { char: '>', spacing: Joint, span: bytes(11203..11204) }, Punct { char: '>', spacing: Alone, span: bytes(11204..11205) }, Punct { char: '=', spacing: Alone, span: bytes(11206..11207) }, Ident { sym: HashMap, span: bytes(11208..11215) }, Punct { char: ':', spacing: Joint, span: bytes(11215..11216) }, Punct { char: ':', spacing: Alone, span: bytes(11216..11217) }, Ident { sym: new, span: bytes(11217..11220) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(11220..11222) }, Punct { char: ';', spacing: Alone, span: bytes(11222..11223) }, Ident { sym: for, span: bytes(11232..11235) }, Ident { sym: edit, span: bytes(11236..11240) }, Ident { sym: in, span: bytes(11241..11243) }, Ident { sym: plan, span: bytes(11244..11248) }, Punct { char: '.', spacing: Alone, span: bytes(11248..11249) }, Ident { sym: edits, span: bytes(11249..11254) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: let, span: bytes(11269..11272) }, Ident { sym: key, span: bytes(11273..11276) }, Punct { char: '=', spacing: Alone, span: bytes(11277..11278) }, Ident { sym: format, span: bytes(11279..11285) }, Punct { char: '!', spacing: Alone, span: bytes(11285..11286) }, Group { delimiter: Parenthesis, stream: TokenStream [Literal { lit: "{}:{}:{}", span: bytes(11304..11314) }, Punct { char: ',', spacing: Alone, span: bytes(11314..11315) }, Ident { sym: edit, span: bytes(11332..11336) }, Punct { char: '.', spacing: Alone, span: bytes(11336..11337) }, Ident { sym: file_name, span: bytes(11337..11346) }, Punct { char: ',', spacing: Alone, span: bytes(11346..11347) }, Ident { sym: edit, span: bytes(11348..11352) }, Punct { char: '.', spacing: Alone, span: bytes(11352..11353) }, Ident { sym: line_start, span: bytes(11353..11363) }, Punct { char: ',', spacing: Alone, span: bytes(11363..11364) }, Ident { sym: edit, span: bytes(11365..11369) }, Punct { char: '.', spacing: Alone, span: bytes(11369..11370) }, Ident { sym: column_start, span: bytes(11370..11382) }], span: bytes(11286..11396) }, Punct { char: ';', spacing: Alone, span: bytes(11396..11397) }, Ident { sym: let, span: bytes(11410..11413) }, Ident { sym: lines, span: bytes(11414..11419) }, Punct { char: ':', spacing: Alone, span: bytes(11419..11420) }, Ident { sym: Vec, span: bytes(11421..11424) }, Punct { char: '<', spacing: Alone, span: bytes(11424..11425) }, Ident { sym: String, span: bytes(11425..11431) }, Punct { char: '>', spacing: Alone, span: bytes(11431..11432) }, Punct { char: '=', spacing: Alone, span: bytes(11433..11434) }, Ident { sym: edit, span: bytes(11435..11439) }, Punct { char: '.', spacing: Alone, span: bytes(11456..11457) }, Ident { sym: section_content, span: bytes(11457..11472) }, Punct { char: '.', spacing: Alone, span: bytes(11489..11490) }, Ident { sym: lines, span: bytes(11490..11495) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(11495..11497) }, Punct { char: '.', spacing: Alone, span: bytes(11514..11515) }, Ident { sym: map, span: bytes(11515..11518) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: std, span: bytes(11519..11522) }, Punct { char: ':', spacing: Joint, span: bytes(11522..11523) }, Punct { char: ':', spacing: Alone, span: bytes(11523..11524) }, Ident { sym: string, span: bytes(11524..11530) }, Punct { char: ':', spacing: Joint, span: bytes(11530..11531) }, Punct { char: ':', spacing: Alone, span: bytes(11531..11532) }, Ident { sym: ToString, span: bytes(11532..11540) }, Punct { char: ':', spacing: Joint, span: bytes(11540..11541) }, Punct { char: ':', spacing: Alone, span: bytes(11541..11542) }, Ident { sym: to_string, span: bytes(11542..11551) }], span: bytes(11518..11552) }, Punct { char: '.', spacing: Alone, span: bytes(11569..11570) }, Ident { sym: collect, span: bytes(11570..11577) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(11577..11579) }, Punct { char: ';', spacing: Alone, span: bytes(11579..11580) }, Ident { sym: doc_map, span: bytes(11593..11600) }, Punct { char: '.', spacing: Alone, span: bytes(11600..11601) }, Ident { sym: insert, span: bytes(11601..11607) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: key, span: bytes(11608..11611) }, Punct { char: ',', spacing: Alone, span: bytes(11611..11612) }, Ident { sym: lines, span: bytes(11613..11618) }], span: bytes(11607..11619) }, Punct { char: ';', spacing: Alone, span: bytes(11619..11620) }], span: bytes(11255..11630) }, Ident { sym: for, span: bytes(11707..11710) }, Ident { sym: section, span: bytes(11711..11718) }, Ident { sym: in, span: bytes(11719..11721) }, Punct { char: '&', spacing: Alone, span: bytes(11722..11723) }, Ident { sym: mut, span: bytes(11723..11726) }, Ident { sym: self, span: bytes(11727..11731) }, Punct { char: '.', spacing: Alone, span: bytes(11731..11732) }, Ident { sym: sections, span: bytes(11732..11740) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: let, span: bytes(11755..11758) }, Ident { sym: key, span: bytes(11759..11762) }, Punct { char: '=', spacing: Alone, span: bytes(11763..11764) }, Ident { sym: format, span: bytes(11765..11771) }, Punct { char: '!', spacing: Alone, span: bytes(11771..11772) }, Group { delimiter: Parenthesis, stream: TokenStream [Literal { lit: "{}:{}:{}", span: bytes(11790..11800) }, Punct { char: ',', spacing: Alone, span: bytes(11800..11801) }, Ident { sym: section, span: bytes(11818..11825) }, Punct { char: '.', spacing: Alone, span: bytes(11825..11826) }, Ident { sym: file_path, span: bytes(11826..11835) }, Punct { char: ',', spacing: Alone, span: bytes(11835..11836) }, Ident { sym: section, span: bytes(11837..11844) }, Punct { char: '.', spacing: Alone, span: bytes(11844..11845) }, Ident { sym: line_start, span: bytes(11845..11855) }, Punct { char: ',', spacing: Alone, span: bytes(11855..11856) }, Ident { sym: section, span: bytes(11857..11864) }, Punct { char: '.', spacing: Alone, span: bytes(11864..11865) }, Ident { sym: column_start, span: bytes(11865..11877) }], span: bytes(11772..11891) }, Punct { char: ';', spacing: Alone, span: bytes(11891..11892) }, Ident { sym: if, span: bytes(11905..11907) }, Ident { sym: doc_map, span: bytes(11908..11915) }, Punct { char: '.', spacing: Alone, span: bytes(11915..11916) }, Ident { sym: contains_key, span: bytes(11916..11928) }, Group { delimiter: Parenthesis, stream: TokenStream [Punct { char: '&', spacing: Alone, span: bytes(11929..11930) }, Ident { sym: key, span: bytes(11930..11933) }], span: bytes(11928..11934) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: if, span: bytes(11953..11955) }, Ident { sym: let, span: bytes(11956..11959) }, Ident { sym: Ok, span: bytes(11960..11962) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: content, span: bytes(11963..11970) }], span: bytes(11962..11971) }, Punct { char: '=', spacing: Alone, span: bytes(11972..11973) }, Ident { sym: fs, span: bytes(11974..11976) }, Punct { char: ':', spacing: Joint, span: bytes(11976..11977) }, Punct { char: ':', spacing: Alone, span: bytes(11977..11978) }, Ident { sym: read_to_string, span: bytes(11978..11992) }, Group { delimiter: Parenthesis, stream: TokenStream [Punct { char: '&', spacing: Alone, span: bytes(11993..11994) }, Ident { sym: section, span: bytes(11994..12001) }, Punct { char: '.', spacing: Alone, span: bytes(12001..12002) }, Ident { sym: file_path, span: bytes(12002..12011) }], span: bytes(11992..12012) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: let, span: bytes(12035..12038) }, Ident { sym: bytes, span: bytes(12039..12044) }, Punct { char: '=', spacing: Alone, span: bytes(12045..12046) }, Ident { sym: content, span: bytes(12047..12054) }, Punct { char: '.', spacing: Alone, span: bytes(12054..12055) }, Ident { sym: as_bytes, span: bytes(12055..12063) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(12063..12065) }, Punct { char: ';', spacing: Alone, span: bytes(12065..12066) }, Ident { sym: if, span: bytes(12087..12089) }, Ident { sym: section, span: bytes(12090..12097) }, Punct { char: '.', spacing: Alone, span: bytes(12097..12098) }, Ident { sym: byte_start, span: bytes(12098..12108) }, Punct { char: '<', spacing: Alone, span: bytes(12109..12110) }, Ident { sym: bytes, span: bytes(12111..12116) }, Punct { char: '.', spacing: Alone, span: bytes(12116..12117) }, Ident { sym: len, span: bytes(12117..12120) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(12120..12122) }, Punct { char: '&', spacing: Joint, span: bytes(12123..12124) }, Punct { char: '&', spacing: Alone, span: bytes(12124..12125) }, Ident { sym: section, span: bytes(12126..12133) }, Punct { char: '.', spacing: Alone, span: bytes(12133..12134) }, Ident { sym: byte_end, span: bytes(12134..12142) }, Punct { char: '<', spacing: Joint, span: bytes(12143..12144) }, Punct { char: '=', spacing: Alone, span: bytes(12144..12145) }, Ident { sym: bytes, span: bytes(12146..12151) }, Punct { char: '.', spacing: Alone, span: bytes(12151..12152) }, Ident { sym: len, span: bytes(12152..12155) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(12155..12157) }, Group { delimiter: Brace, stream: TokenStream [], span: bytes(12158..12241) }], span: bytes(12013..12259) }], span: bytes(11935..12273) }], span: bytes(11741..12283) }], span: bytes(11150..12289) }) }), delimiter: Some(Nothing) }, Delimited<syncdoc_core::parse::ModuleItem, unsynn::fundamental::Nothing> { value: Function(FnSig { attributes: Some(Repeats<1, 18446744073709551615, syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing>([Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: doc, span: bytes(12295..12366) }, Punct { char: '=', spacing: Alone, span: bytes(12295..12366) }, Literal { lit: " Creates a serialisable plan capturing current editor modifications.", span: bytes(12295..12366) }], span: bytes(12295..12366) }) }, delimiter: Some(Nothing) }, Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: must_use, span: bytes(12373..12381) }], span: bytes(12372..12382) }) }, delimiter: Some(Nothing) }])), visibility: Some(Public(KPub(Cached<proc_macro2::Ident> { value: Ident { sym: pub, span: bytes(12387..12390) }, string: "pub" }))), const_kw: None, async_kw: None, unsafe_kw: None, extern_kw: None, _fn: KFn(Cached<proc_macro2::Ident> { value: Ident { sym: fn, span: bytes(12391..12393) }, string: "fn" }), name: Ident { sym: generate_edit_plan, span: bytes(12394..12412) }, generics: None, params: ParenthesisGroupContaining < core::option::Option<unsynn::container::DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>>>(Some(DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>([Delimited<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>> { value: SelfParam(Ref(Cons<unsynn::operator::Operator<'&'>, syncdoc_core::parse::KSelf> { first: Operator<'&'>, second: KSelf(Cached<proc_macro2::Ident> { value: Ident { sym: self, span: bytes(12414..12418) }, string: "self" }) })), delimiter: None }]))), return_type: Some(ReturnTypeFn { _arrow: Operator<'->'>, return_type: Repeats<1, 18446744073709551615, unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing>([Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::group::BraceGroup>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Ident { sym: EditPlan, span: bytes(12423..12431) })) }, delimiter: Some(Nothing) }]) }), where_clause: None, body: BraceGroup(Group { delimiter: Brace, stream: TokenStream [Ident { sym: let, span: bytes(12442..12445) }, Ident { sym: mut, span: bytes(12446..12449) }, Ident { sym: edits, span: bytes(12450..12455) }, Punct { char: '=', spacing: Alone, span: bytes(12456..12457) }, Ident { sym: Vec, span: bytes(12458..12461) }, Punct { char: ':', spacing: Joint, span: bytes(12461..12462) }, Punct { char: ':', spacing: Alone, span: bytes(12462..12463) }, Ident { sym: new, span: bytes(12463..12466) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(12466..12468) }, Punct { char: ';', spacing: Alone, span: bytes(12468..12469) }, Ident { sym: for, span: bytes(12479..12482) }, Ident { sym: section, span: bytes(12483..12490) }, Ident { sym: in, span: bytes(12491..12493) }, Punct { char: '&', spacing: Alone, span: bytes(12494..12495) }, Ident { sym: self, span: bytes(12495..12499) }, Punct { char: '.', spacing: Alone, span: bytes(12499..12500) }, Ident { sym: sections, span: bytes(12500..12508) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: if, span: bytes(12523..12525) }, Ident { sym: let, span: bytes(12526..12529) }, Ident { sym: Some, span: bytes(12530..12534) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: ref, span: bytes(12535..12538) }, Ident { sym: doc_lines, span: bytes(12539..12548) }], span: bytes(12534..12549) }, Punct { char: '=', spacing: Alone, span: bytes(12550..12551) }, Ident { sym: section, span: bytes(12552..12559) }, Punct { char: '.', spacing: Alone, span: bytes(12559..12560) }, Ident { sym: section_content, span: bytes(12560..12575) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: let, span: bytes(12594..12597) }, Ident { sym: section_content, span: bytes(12598..12613) }, Punct { char: '=', spacing: Alone, span: bytes(12614..12615) }, Ident { sym: doc_lines, span: bytes(12616..12625) }, Punct { char: '.', spacing: Alone, span: bytes(12625..12626) }, Ident { sym: join, span: bytes(12626..12630) }, Group { delimiter: Parenthesis, stream: TokenStream [Literal { lit: "\n", span: bytes(12631..12635) }], span: bytes(12630..12636) }, Punct { char: ';', spacing: Alone, span: bytes(12636..12637) }, Ident { sym: edits, span: bytes(12655..12660) }, Punct { char: '.', spacing: Alone, span: bytes(12660..12661) }, Ident { sym: push, span: bytes(12661..12665) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: Edit, span: bytes(12666..12670) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: file_name, span: bytes(12693..12702) }, Punct { char: ':', spacing: Alone, span: bytes(12702..12703) }, Ident { sym: section, span: bytes(12704..12711) }, Punct { char: '.', spacing: Alone, span: bytes(12711..12712) }, Ident { sym: file_path, span: bytes(12712..12721) }, Punct { char: '.', spacing: Alone, span: bytes(12721..12722) }, Ident { sym: clone, span: bytes(12722..12727) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(12727..12729) }, Punct { char: ',', spacing: Alone, span: bytes(12729..12730) }, Ident { sym: line_start, span: bytes(12751..12761) }, Punct { char: ':', spacing: Alone, span: bytes(12761..12762) }, Ident { sym: section, span: bytes(12763..12770) }, Punct { char: '.', spacing: Alone, span: bytes(12770..12771) }, Ident { sym: line_start, span: bytes(12771..12781) }, Punct { char: ',', spacing: Alone, span: bytes(12781..12782) }, Ident { sym: line_end, span: bytes(12803..12811) }, Punct { char: ':', spacing: Alone, span: bytes(12811..12812) }, Ident { sym: section, span: bytes(12813..12820) }, Punct { char: '.', spacing: Alone, span: bytes(12820..12821) }, Ident { sym: line_end, span: bytes(12821..12829) }, Punct { char: ',', spacing: Alone, span: bytes(12829..12830) }, Ident { sym: column_start, span: bytes(12851..12863) }, Punct { char: ':', spacing: Alone, span: bytes(12863..12864) }, Ident { sym: section, span: bytes(12865..12872) }, Punct { char: '.', spacing: Alone, span: bytes(12872..12873) }, Ident { sym: column_start, span: bytes(12873..12885) }, Punct { char: ',', spacing: Alone, span: bytes(12885..12886) }, Ident { sym: column_end, span: bytes(12907..12917) }, Punct { char: ':', spacing: Alone, span: bytes(12917..12918) }, Ident { sym: section, span: bytes(12919..12926) }, Punct { char: '.', spacing: Alone, span: bytes(12926..12927) }, Ident { sym: column_end, span: bytes(12927..12937) }, Punct { char: ',', spacing: Alone, span: bytes(12937..12938) }, Ident { sym: section_content, span: bytes(12959..12974) }, Punct { char: ',', spacing: Alone, span: bytes(12974..12975) }, Ident { sym: item_name, span: bytes(12996..13005) }, Punct { char: ':', spacing: Alone, span: bytes(13005..13006) }, Ident { sym: section, span: bytes(13007..13014) }, Punct { char: '.', spacing: Alone, span: bytes(13014..13015) }, Ident { sym: title, span: bytes(13015..13020) }, Punct { char: '.', spacing: Alone, span: bytes(13020..13021) }, Ident { sym: clone, span: bytes(13021..13026) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(13026..13028) }, Punct { char: ',', spacing: Alone, span: bytes(13028..13029) }], span: bytes(12671..13047) }], span: bytes(12665..13048) }, Punct { char: ';', spacing: Alone, span: bytes(13048..13049) }], span: bytes(12576..13063) }], span: bytes(12509..13073) }, Ident { sym: EditPlan, span: bytes(13083..13091) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: edits, span: bytes(13094..13099) }], span: bytes(13092..13101) }], span: bytes(12432..13107) }) }), delimiter: Some(Nothing) }, Delimited<syncdoc_core::parse::ModuleItem, unsynn::fundamental::Nothing> { value: Function(FnSig { attributes: Some(Repeats<1, 18446744073709551615, syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing>([Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: doc, span: bytes(13113..13171) }, Punct { char: '=', spacing: Alone, span: bytes(13113..13171) }, Literal { lit: " Loads selected section content into the editor buffer.", span: bytes(13113..13171) }], span: bytes(13113..13171) }) }, delimiter: Some(Nothing) }])), visibility: Some(Public(KPub(Cached<proc_macro2::Ident> { value: Ident { sym: pub, span: bytes(13176..13179) }, string: "pub" }))), const_kw: None, async_kw: None, unsafe_kw: None, extern_kw: None, _fn: KFn(Cached<proc_macro2::Ident> { value: Ident { sym: fn, span: bytes(13180..13182) }, string: "fn" }), name: Ident { sym: enter_detail_view, span: bytes(13183..13200) }, generics: None, params: ParenthesisGroupContaining < core::option::Option<unsynn::container::DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>>>(Some(DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>([Delimited<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>> { value: SelfParam(RefMut(Cons<unsynn::operator::Operator<'&'>, unsynn::combinator::Cons<syncdoc_core::parse::KMut, syncdoc_core::parse::KSelf>> { first: Operator<'&'>, second: Cons<syncdoc_core::parse::KMut, syncdoc_core::parse::KSelf> { first: KMut(Cached<proc_macro2::Ident> { value: Ident { sym: mut, span: bytes(13202..13205) }, string: "mut" }), second: KSelf(Cached<proc_macro2::Ident> { value: Ident { sym: self, span: bytes(13206..13210) }, string: "self" }) } })), delimiter: None }]))), return_type: None, where_clause: None, body: BraceGroup(Group { delimiter: Brace, stream: TokenStream [Ident { sym: let, span: bytes(13222..13225) }, Ident { sym: Some, span: bytes(13226..13230) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: section_idx, span: bytes(13231..13242) }], span: bytes(13230..13243) }, Punct { char: '=', spacing: Alone, span: bytes(13244..13245) }, Ident { sym: self, span: bytes(13246..13250) }, Punct { char: '.', spacing: Alone, span: bytes(13250..13251) }, Ident { sym: get_current_section_index, span: bytes(13251..13276) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(13276..13278) }, Ident { sym: else, span: bytes(13279..13283) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: return, span: bytes(13298..13304) }, Punct { char: ';', spacing: Alone, span: bytes(13304..13305) }], span: bytes(13284..13315) }, Punct { char: ';', spacing: Alone, span: bytes(13315..13316) }, Ident { sym: let, span: bytes(13326..13329) }, Ident { sym: section, span: bytes(13330..13337) }, Punct { char: '=', spacing: Alone, span: bytes(13338..13339) }, Punct { char: '&', spacing: Alone, span: bytes(13340..13341) }, Ident { sym: self, span: bytes(13341..13345) }, Punct { char: '.', spacing: Alone, span: bytes(13345..13346) }, Ident { sym: sections, span: bytes(13346..13354) }, Group { delimiter: Bracket, stream: TokenStream [Ident { sym: section_idx, span: bytes(13355..13366) }], span: bytes(13354..13367) }, Punct { char: ';', spacing: Alone, span: bytes(13367..13368) }, Ident { sym: if, span: bytes(13426..13428) }, Ident { sym: let, span: bytes(13429..13432) }, Ident { sym: Some, span: bytes(13433..13437) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: chunk_type, span: bytes(13438..13448) }], span: bytes(13437..13449) }, Punct { char: '=', spacing: Alone, span: bytes(13450..13451) }, Punct { char: '&', spacing: Alone, span: bytes(13452..13453) }, Ident { sym: section, span: bytes(13453..13460) }, Punct { char: '.', spacing: Alone, span: bytes(13460..13461) }, Ident { sym: chunk_type, span: bytes(13461..13471) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: let, span: bytes(13486..13489) }, Ident { sym: content, span: bytes(13490..13497) }, Punct { char: '=', spacing: Alone, span: bytes(13498..13499) }, Ident { sym: match, span: bytes(13500..13505) }, Ident { sym: chunk_type, span: bytes(13506..13516) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: ChunkType, span: bytes(13535..13544) }, Punct { char: ':', spacing: Joint, span: bytes(13544..13545) }, Punct { char: ':', spacing: Alone, span: bytes(13545..13546) }, Ident { sym: Added, span: bytes(13546..13551) }, Punct { char: '=', spacing: Joint, span: bytes(13552..13553) }, Punct { char: '>', spacing: Alone, span: bytes(13553..13554) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: section, span: bytes(13631..13638) }, Punct { char: '.', spacing: Alone, span: bytes(13638..13639) }, Ident { sym: rhs_content, span: bytes(13639..13650) }, Punct { char: '.', spacing: Alone, span: bytes(13650..13651) }, Ident { sym: clone, span: bytes(13651..13656) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(13656..13658) }, Punct { char: '.', spacing: Alone, span: bytes(13658..13659) }, Ident { sym: unwrap_or_default, span: bytes(13659..13676) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(13676..13678) }], span: bytes(13555..13696) }, Ident { sym: ChunkType, span: bytes(13713..13722) }, Punct { char: ':', spacing: Joint, span: bytes(13722..13723) }, Punct { char: ':', spacing: Alone, span: bytes(13723..13724) }, Ident { sym: Deleted, span: bytes(13724..13731) }, Punct { char: '=', spacing: Joint, span: bytes(13732..13733) }, Punct { char: '>', spacing: Alone, span: bytes(13733..13734) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: section, span: bytes(13830..13837) }, Punct { char: '.', spacing: Alone, span: bytes(13837..13838) }, Ident { sym: lhs_content, span: bytes(13838..13849) }, Punct { char: '.', spacing: Alone, span: bytes(13849..13850) }, Ident { sym: clone, span: bytes(13850..13855) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(13855..13857) }, Punct { char: '.', spacing: Alone, span: bytes(13857..13858) }, Ident { sym: unwrap_or_default, span: bytes(13858..13875) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(13875..13877) }], span: bytes(13735..13895) }, Ident { sym: ChunkType, span: bytes(13912..13921) }, Punct { char: ':', spacing: Joint, span: bytes(13921..13922) }, Punct { char: ':', spacing: Alone, span: bytes(13922..13923) }, Ident { sym: Modified, span: bytes(13923..13931) }, Punct { char: '=', spacing: Joint, span: bytes(13932..13933) }, Punct { char: '>', spacing: Alone, span: bytes(13933..13934) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: let, span: bytes(14016..14019) }, Ident { sym: lhs, span: bytes(14020..14023) }, Punct { char: '=', spacing: Alone, span: bytes(14024..14025) }, Ident { sym: section, span: bytes(14026..14033) }, Punct { char: '.', spacing: Alone, span: bytes(14033..14034) }, Ident { sym: lhs_content, span: bytes(14034..14045) }, Punct { char: '.', spacing: Alone, span: bytes(14045..14046) }, Ident { sym: as_deref, span: bytes(14046..14054) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(14054..14056) }, Punct { char: '.', spacing: Alone, span: bytes(14056..14057) }, Ident { sym: unwrap_or, span: bytes(14057..14066) }, Group { delimiter: Parenthesis, stream: TokenStream [Literal { lit: "", span: bytes(14067..14069) }], span: bytes(14066..14070) }, Punct { char: ';', spacing: Alone, span: bytes(14070..14071) }, Ident { sym: let, span: bytes(14092..14095) }, Ident { sym: rhs, span: bytes(14096..14099) }, Punct { char: '=', spacing: Alone, span: bytes(14100..14101) }, Ident { sym: section, span: bytes(14102..14109) }, Punct { char: '.', spacing: Alone, span: bytes(14109..14110) }, Ident { sym: rhs_content, span: bytes(14110..14121) }, Punct { char: '.', spacing: Alone, span: bytes(14121..14122) }, Ident { sym: as_deref, span: bytes(14122..14130) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(14130..14132) }, Punct { char: '.', spacing: Alone, span: bytes(14132..14133) }, Ident { sym: unwrap_or, span: bytes(14133..14142) }, Group { delimiter: Parenthesis, stream: TokenStream [Literal { lit: "", span: bytes(14143..14145) }], span: bytes(14142..14146) }, Punct { char: ';', spacing: Alone, span: bytes(14146..14147) }, Ident { sym: format, span: bytes(14168..14174) }, Punct { char: '!', spacing: Alone, span: bytes(14174..14175) }, Group { delimiter: Parenthesis, stream: TokenStream [Literal { lit: "- {lhs}\n+ {rhs}", span: bytes(14176..14194) }], span: bytes(14175..14195) }], span: bytes(13935..14213) }, Ident { sym: ChunkType, span: bytes(14230..14239) }, Punct { char: ':', spacing: Joint, span: bytes(14239..14240) }, Punct { char: ':', spacing: Alone, span: bytes(14240..14241) }, Ident { sym: Unchanged, span: bytes(14241..14250) }, Punct { char: '=', spacing: Joint, span: bytes(14251..14252) }, Punct { char: '>', spacing: Alone, span: bytes(14252..14253) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: section, span: bytes(14335..14342) }, Punct { char: '.', spacing: Alone, span: bytes(14367..14368) }, Ident { sym: lhs_content, span: bytes(14368..14379) }, Punct { char: '.', spacing: Alone, span: bytes(14404..14405) }, Ident { sym: clone, span: bytes(14405..14410) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(14410..14412) }, Punct { char: '.', spacing: Alone, span: bytes(14437..14438) }, Ident { sym: or_else, span: bytes(14438..14445) }, Group { delimiter: Parenthesis, stream: TokenStream [Punct { char: '|', spacing: Joint, span: bytes(14446..14447) }, Punct { char: '|', spacing: Alone, span: bytes(14447..14448) }, Ident { sym: section, span: bytes(14449..14456) }, Punct { char: '.', spacing: Alone, span: bytes(14456..14457) }, Ident { sym: rhs_content, span: bytes(14457..14468) }, Punct { char: '.', spacing: Alone, span: bytes(14468..14469) }, Ident { sym: clone, span: bytes(14469..14474) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(14474..14476) }], span: bytes(14445..14477) }, Punct { char: '.', spacing: Alone, span: bytes(14502..14503) }, Ident { sym: unwrap_or_default, span: bytes(14503..14520) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(14520..14522) }], span: bytes(14254..14540) }], span: bytes(13517..14554) }, Punct { char: ';', spacing: Alone, span: bytes(14554..14555) }, Ident { sym: let, span: bytes(14569..14572) }, Ident { sym: lines, span: bytes(14573..14578) }, Punct { char: '=', spacing: Alone, span: bytes(14579..14580) }, Ident { sym: Lines, span: bytes(14581..14586) }, Punct { char: ':', spacing: Joint, span: bytes(14586..14587) }, Punct { char: ':', spacing: Alone, span: bytes(14587..14588) }, Ident { sym: from, span: bytes(14588..14592) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: content, span: bytes(14593..14600) }, Punct { char: '.', spacing: Alone, span: bytes(14600..14601) }, Ident { sym: as_str, span: bytes(14601..14607) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(14607..14609) }], span: bytes(14592..14610) }, Punct { char: ';', spacing: Alone, span: bytes(14610..14611) }, Ident { sym: self, span: bytes(14624..14628) }, Punct { char: '.', spacing: Alone, span: bytes(14628..14629) }, Ident { sym: editor_state, span: bytes(14629..14641) }, Punct { char: '=', spacing: Alone, span: bytes(14642..14643) }, Ident { sym: Some, span: bytes(14644..14648) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: EditorState, span: bytes(14649..14660) }, Punct { char: ':', spacing: Joint, span: bytes(14660..14661) }, Punct { char: ':', spacing: Alone, span: bytes(14661..14662) }, Ident { sym: new, span: bytes(14662..14665) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: lines, span: bytes(14666..14671) }], span: bytes(14665..14672) }], span: bytes(14648..14673) }, Punct { char: ';', spacing: Alone, span: bytes(14673..14674) }], span: bytes(13472..14684) }, Ident { sym: else, span: bytes(14685..14689) }, Ident { sym: if, span: bytes(14690..14692) }, Ident { sym: let, span: bytes(14693..14696) }, Ident { sym: Ok, span: bytes(14697..14699) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: content, span: bytes(14700..14707) }], span: bytes(14699..14708) }, Punct { char: '=', spacing: Alone, span: bytes(14709..14710) }, Ident { sym: fs, span: bytes(14711..14713) }, Punct { char: ':', spacing: Joint, span: bytes(14713..14714) }, Punct { char: ':', spacing: Alone, span: bytes(14714..14715) }, Ident { sym: read_to_string, span: bytes(14715..14729) }, Group { delimiter: Parenthesis, stream: TokenStream [Punct { char: '&', spacing: Alone, span: bytes(14730..14731) }, Ident { sym: section, span: bytes(14731..14738) }, Punct { char: '.', spacing: Alone, span: bytes(14738..14739) }, Ident { sym: file_path, span: bytes(14739..14748) }], span: bytes(14729..14749) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: let, span: bytes(14764..14767) }, Ident { sym: bytes, span: bytes(14768..14773) }, Punct { char: '=', spacing: Alone, span: bytes(14774..14775) }, Ident { sym: content, span: bytes(14776..14783) }, Punct { char: '.', spacing: Alone, span: bytes(14783..14784) }, Ident { sym: as_bytes, span: bytes(14784..14792) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(14792..14794) }, Punct { char: ';', spacing: Alone, span: bytes(14794..14795) }, Ident { sym: let, span: bytes(14808..14811) }, Ident { sym: section_bytes, span: bytes(14812..14825) }, Punct { char: '=', spacing: Alone, span: bytes(14826..14827) }, Punct { char: '&', spacing: Alone, span: bytes(14844..14845) }, Ident { sym: bytes, span: bytes(14845..14850) }, Group { delimiter: Bracket, stream: TokenStream [Ident { sym: section, span: bytes(14851..14858) }, Punct { char: '.', spacing: Alone, span: bytes(14858..14859) }, Ident { sym: byte_start, span: bytes(14859..14869) }, Punct { char: '.', spacing: Alone, span: bytes(14869..14870) }, Ident { sym: min, span: bytes(14870..14873) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: bytes, span: bytes(14874..14879) }, Punct { char: '.', spacing: Alone, span: bytes(14879..14880) }, Ident { sym: len, span: bytes(14880..14883) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(14883..14885) }], span: bytes(14873..14886) }, Punct { char: '.', spacing: Joint, span: bytes(14886..14887) }, Punct { char: '.', spacing: Alone, span: bytes(14887..14888) }, Ident { sym: section, span: bytes(14888..14895) }, Punct { char: '.', spacing: Alone, span: bytes(14895..14896) }, Ident { sym: byte_end, span: bytes(14896..14904) }, Punct { char: '.', spacing: Alone, span: bytes(14904..14905) }, Ident { sym: min, span: bytes(14905..14908) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: bytes, span: bytes(14909..14914) }, Punct { char: '.', spacing: Alone, span: bytes(14914..14915) }, Ident { sym: len, span: bytes(14915..14918) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(14918..14920) }], span: bytes(14908..14921) }], span: bytes(14850..14922) }, Punct { char: ';', spacing: Alone, span: bytes(14922..14923) }, Ident { sym: let, span: bytes(14937..14940) }, Ident { sym: section_content, span: bytes(14941..14956) }, Punct { char: '=', spacing: Alone, span: bytes(14957..14958) }, Ident { sym: String, span: bytes(14959..14965) }, Punct { char: ':', spacing: Joint, span: bytes(14965..14966) }, Punct { char: ':', spacing: Alone, span: bytes(14966..14967) }, Ident { sym: from_utf8_lossy, span: bytes(14967..14982) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: section_bytes, span: bytes(14983..14996) }], span: bytes(14982..14997) }, Punct { char: '.', spacing: Alone, span: bytes(14997..14998) }, Ident { sym: to_string, span: bytes(14998..15007) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(15007..15009) }, Punct { char: ';', spacing: Alone, span: bytes(15009..15010) }, Ident { sym: let, span: bytes(15024..15027) }, Ident { sym: lines_text, span: bytes(15028..15038) }, Punct { char: '=', spacing: Alone, span: bytes(15039..15040) }, Ident { sym: if, span: bytes(15041..15043) }, Ident { sym: section_content, span: bytes(15044..15059) }, Punct { char: '.', spacing: Alone, span: bytes(15059..15060) }, Ident { sym: trim, span: bytes(15060..15064) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(15064..15066) }, Punct { char: '.', spacing: Alone, span: bytes(15066..15067) }, Ident { sym: is_empty, span: bytes(15067..15075) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(15075..15077) }, Group { delimiter: Brace, stream: TokenStream [Literal { lit: "\n", span: bytes(15096..15100) }, Punct { char: '.', spacing: Alone, span: bytes(15100..15101) }, Ident { sym: to_string, span: bytes(15101..15110) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(15110..15112) }], span: bytes(15078..15126) }, Ident { sym: else, span: bytes(15127..15131) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: format, span: bytes(15150..15156) }, Punct { char: '!', spacing: Alone, span: bytes(15156..15157) }, Group { delimiter: Parenthesis, stream: TokenStream [Literal { lit: "\n{}\n", span: bytes(15158..15166) }, Punct { char: ',', spacing: Alone, span: bytes(15166..15167) }, Ident { sym: section_content, span: bytes(15168..15183) }, Punct { char: '.', spacing: Alone, span: bytes(15183..15184) }, Ident { sym: trim, span: bytes(15184..15188) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(15188..15190) }], span: bytes(15157..15191) }], span: bytes(15132..15205) }, Punct { char: ';', spacing: Alone, span: bytes(15205..15206) }, Ident { sym: let, span: bytes(15220..15223) }, Ident { sym: lines, span: bytes(15224..15229) }, Punct { char: '=', spacing: Alone, span: bytes(15230..15231) }, Ident { sym: Lines, span: bytes(15232..15237) }, Punct { char: ':', spacing: Joint, span: bytes(15237..15238) }, Punct { char: ':', spacing: Alone, span: bytes(15238..15239) }, Ident { sym: from, span: bytes(15239..15243) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: lines_text, span: bytes(15244..15254) }, Punct { char: '.', spacing: Alone, span: bytes(15254..15255) }, Ident { sym: as_str, span: bytes(15255..15261) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(15261..15263) }], span: bytes(15243..15264) }, Punct { char: ';', spacing: Alone, span: bytes(15264..15265) }, Ident { sym: self, span: bytes(15278..15282) }, Punct { char: '.', spacing: Alone, span: bytes(15282..15283) }, Ident { sym: editor_state, span: bytes(15283..15295) }, Punct { char: '=', spacing: Alone, span: bytes(15296..15297) }, Ident { sym: Some, span: bytes(15298..15302) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: EditorState, span: bytes(15303..15314) }, Punct { char: ':', spacing: Joint, span: bytes(15314..15315) }, Punct { char: ':', spacing: Alone, span: bytes(15315..15316) }, Ident { sym: new, span: bytes(15316..15319) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: lines, span: bytes(15320..15325) }], span: bytes(15319..15326) }], span: bytes(15302..15327) }, Punct { char: ';', spacing: Alone, span: bytes(15327..15328) }], span: bytes(14750..15338) }, Ident { sym: self, span: bytes(15348..15352) }, Punct { char: '.', spacing: Alone, span: bytes(15352..15353) }, Ident { sym: current_view, span: bytes(15353..15365) }, Punct { char: '=', spacing: Alone, span: bytes(15366..15367) }, Ident { sym: View, span: bytes(15368..15372) }, Punct { char: ':', spacing: Joint, span: bytes(15372..15373) }, Punct { char: ':', spacing: Alone, span: bytes(15373..15374) }, Ident { sym: Detail, span: bytes(15374..15380) }, Punct { char: ';', spacing: Alone, span: bytes(15380..15381) }], span: bytes(13212..15387) }) }), delimiter: Some(Nothing) }, Delimited<syncdoc_core::parse::ModuleItem, unsynn::fundamental::Nothing> { value: Function(FnSig { attributes: Some(Repeats<1, 18446744073709551615, syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing>([Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: doc, span: bytes(15393..15459) }, Punct { char: '=', spacing: Alone, span: bytes(15393..15459) }, Literal { lit: " Returns to section list, optionally persisting editor changes.", span: bytes(15393..15459) }], span: bytes(15393..15459) }) }, delimiter: Some(Nothing) }])), visibility: Some(Public(KPub(Cached<proc_macro2::Ident> { value: Ident { sym: pub, span: bytes(15464..15467) }, string: "pub" }))), const_kw: None, async_kw: None, unsafe_kw: None, extern_kw: None, _fn: KFn(Cached<proc_macro2::Ident> { value: Ident { sym: fn, span: bytes(15468..15470) }, string: "fn" }), name: Ident { sym: exit_detail_view, span: bytes(15471..15487) }, generics: None, params: ParenthesisGroupContaining < core::option::Option<unsynn::container::DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>>>(Some(DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>([Delimited<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>> { value: SelfParam(RefMut(Cons<unsynn::operator::Operator<'&'>, unsynn::combinator::Cons<syncdoc_core::parse::KMut, syncdoc_core::parse::KSelf>> { first: Operator<'&'>, second: Cons<syncdoc_core::parse::KMut, syncdoc_core::parse::KSelf> { first: KMut(Cached<proc_macro2::Ident> { value: Ident { sym: mut, span: bytes(15489..15492) }, string: "mut" }), second: KSelf(Cached<proc_macro2::Ident> { value: Ident { sym: self, span: bytes(15493..15497) }, string: "self" }) } })), delimiter: Some(Operator<','>) }, Delimited<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>> { value: Named(NamedParam { mut_kw: None, name: Ident { sym: save, span: bytes(15499..15503) }, _colon: Operator<':'>, param_type: Repeats<1, 18446744073709551615, unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<','>>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing>([Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<','>>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::operator::Operator<','>>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::operator::Operator<','>>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Ident { sym: bool, span: bytes(15505..15509) })) }, delimiter: Some(Nothing) }]) }), delimiter: None }]))), return_type: None, where_clause: None, body: BraceGroup(Group { delimiter: Brace, stream: TokenStream [Ident { sym: if, span: bytes(15521..15523) }, Ident { sym: save, span: bytes(15524..15528) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: if, span: bytes(15543..15545) }, Ident { sym: let, span: bytes(15546..15549) }, Ident { sym: Some, span: bytes(15550..15554) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: ref, span: bytes(15555..15558) }, Ident { sym: editor_state, span: bytes(15559..15571) }], span: bytes(15554..15572) }, Punct { char: '=', spacing: Alone, span: bytes(15573..15574) }, Ident { sym: self, span: bytes(15575..15579) }, Punct { char: '.', spacing: Alone, span: bytes(15579..15580) }, Ident { sym: editor_state, span: bytes(15580..15592) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: if, span: bytes(15611..15613) }, Ident { sym: let, span: bytes(15614..15617) }, Ident { sym: Some, span: bytes(15618..15622) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: section_idx, span: bytes(15623..15634) }], span: bytes(15622..15635) }, Punct { char: '=', spacing: Alone, span: bytes(15636..15637) }, Ident { sym: self, span: bytes(15638..15642) }, Punct { char: '.', spacing: Alone, span: bytes(15642..15643) }, Ident { sym: get_current_section_index, span: bytes(15643..15668) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(15668..15670) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: let, span: bytes(15693..15696) }, Ident { sym: lines, span: bytes(15697..15702) }, Punct { char: '=', spacing: Alone, span: bytes(15703..15704) }, Ident { sym: editor_state, span: bytes(15705..15717) }, Punct { char: '.', spacing: Alone, span: bytes(15742..15743) }, Ident { sym: lines, span: bytes(15743..15748) }, Punct { char: '.', spacing: Alone, span: bytes(15773..15774) }, Ident { sym: iter_row, span: bytes(15774..15782) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(15782..15784) }, Punct { char: '.', spacing: Alone, span: bytes(15809..15810) }, Ident { sym: map, span: bytes(15810..15813) }, Group { delimiter: Parenthesis, stream: TokenStream [Punct { char: '|', spacing: Alone, span: bytes(15814..15815) }, Ident { sym: line, span: bytes(15815..15819) }, Punct { char: '|', spacing: Alone, span: bytes(15819..15820) }, Ident { sym: line, span: bytes(15821..15825) }, Punct { char: '.', spacing: Alone, span: bytes(15825..15826) }, Ident { sym: iter, span: bytes(15826..15830) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(15830..15832) }, Punct { char: '.', spacing: Alone, span: bytes(15832..15833) }, Ident { sym: collect, span: bytes(15833..15840) }, Punct { char: ':', spacing: Joint, span: bytes(15840..15841) }, Punct { char: ':', spacing: Joint, span: bytes(15841..15842) }, Punct { char: '<', spacing: Alone, span: bytes(15842..15843) }, Ident { sym: String, span: bytes(15843..15849) }, Punct { char: '>', spacing: Alone, span: bytes(15849..15850) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(15850..15852) }], span: bytes(15813..15853) }, Punct { char: '.', spacing: Alone, span: bytes(15878..15879) }, Ident { sym: collect, span: bytes(15879..15886) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(15886..15888) }, Punct { char: ';', spacing: Alone, span: bytes(15888..15889) }, Ident { sym: self, span: bytes(15910..15914) }, Punct { char: '.', spacing: Alone, span: bytes(15914..15915) }, Ident { sym: sections, span: bytes(15915..15923) }, Group { delimiter: Bracket, stream: TokenStream [Ident { sym: section_idx, span: bytes(15924..15935) }], span: bytes(15923..15936) }, Punct { char: '.', spacing: Alone, span: bytes(15936..15937) }, Ident { sym: section_content, span: bytes(15937..15952) }, Punct { char: '=', spacing: Alone, span: bytes(15953..15954) }, Ident { sym: Some, span: bytes(15955..15959) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: lines, span: bytes(15960..15965) }], span: bytes(15959..15966) }, Punct { char: ';', spacing: Alone, span: bytes(15966..15967) }], span: bytes(15671..15985) }], span: bytes(15593..15999) }], span: bytes(15529..16009) }, Ident { sym: self, span: bytes(16018..16022) }, Punct { char: '.', spacing: Alone, span: bytes(16022..16023) }, Ident { sym: editor_state, span: bytes(16023..16035) }, Punct { char: '=', spacing: Alone, span: bytes(16036..16037) }, Ident { sym: None, span: bytes(16038..16042) }, Punct { char: ';', spacing: Alone, span: bytes(16042..16043) }, Ident { sym: self, span: bytes(16052..16056) }, Punct { char: '.', spacing: Alone, span: bytes(16056..16057) }, Ident { sym: current_view, span: bytes(16057..16069) }, Punct { char: '=', spacing: Alone, span: bytes(16070..16071) }, Ident { sym: View, span: bytes(16072..16076) }, Punct { char: ':', spacing: Joint, span: bytes(16076..16077) }, Punct { char: ':', spacing: Alone, span: bytes(16077..16078) }, Ident { sym: List, span: bytes(16078..16082) }, Punct { char: ';', spacing: Alone, span: bytes(16082..16083) }], span: bytes(15511..16089) }) }), delimiter: Some(Nothing) }, Delimited<syncdoc_core::parse::ModuleItem, unsynn::fundamental::Nothing> { value: Function(FnSig { attributes: Some(Repeats<1, 18446744073709551615, syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing>([Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: doc, span: bytes(16095..16142) }, Punct { char: '=', spacing: Alone, span: bytes(16095..16142) }, Literal { lit: " Save the current section's content to disk.", span: bytes(16095..16142) }], span: bytes(16095..16142) }) }, delimiter: Some(Nothing) }, Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: doc, span: bytes(16147..16150) }, Punct { char: '=', spacing: Alone, span: bytes(16147..16150) }, Literal { lit: "", span: bytes(16147..16150) }], span: bytes(16147..16150) }) }, delimiter: Some(Nothing) }, Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: doc, span: bytes(16155..16167) }, Punct { char: '=', spacing: Alone, span: bytes(16155..16167) }, Literal { lit: " # Errors", span: bytes(16155..16167) }], span: bytes(16155..16167) }) }, delimiter: Some(Nothing) }, Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: doc, span: bytes(16172..16175) }, Punct { char: '=', spacing: Alone, span: bytes(16172..16175) }, Literal { lit: "", span: bytes(16172..16175) }], span: bytes(16172..16175) }) }, delimiter: Some(Nothing) }, Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: doc, span: bytes(16180..16264) }, Punct { char: '=', spacing: Alone, span: bytes(16180..16264) }, Literal { lit: " Returns an error if writing to disk fails or if file operations cannot complete.", span: bytes(16180..16264) }], span: bytes(16180..16264) }) }, delimiter: Some(Nothing) }])), visibility: Some(Public(KPub(Cached<proc_macro2::Ident> { value: Ident { sym: pub, span: bytes(16269..16272) }, string: "pub" }))), const_kw: None, async_kw: None, unsafe_kw: None, extern_kw: None, _fn: KFn(Cached<proc_macro2::Ident> { value: Ident { sym: fn, span: bytes(16273..16275) }, string: "fn" }), name: Ident { sym: save_current, span: bytes(16276..16288) }, generics: None, params: ParenthesisGroupContaining < core::option::Option<unsynn::container::DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>>>(Some(DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>([Delimited<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>> { value: SelfParam(RefMut(Cons<unsynn::operator::Operator<'&'>, unsynn::combinator::Cons<syncdoc_core::parse::KMut, syncdoc_core::parse::KSelf>> { first: Operator<'&'>, second: Cons<syncdoc_core::parse::KMut, syncdoc_core::parse::KSelf> { first: KMut(Cached<proc_macro2::Ident> { value: Ident { sym: mut, span: bytes(16290..16293) }, string: "mut" }), second: KSelf(Cached<proc_macro2::Ident> { value: Ident { sym: self, span: bytes(16294..16298) }, string: "self" }) } })), delimiter: None }]))), return_type: Some(ReturnTypeFn { _arrow: Operator<'->'>, return_type: Repeats<1, 18446744073709551615, unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing>([Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::group::BraceGroup>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Ident { sym: io, span: bytes(16303..16305) })) }, delimiter: Some(Nothing) }, Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::group::BraceGroup>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Punct { char: ':', spacing: Joint, span: bytes(16305..16306) })) }, delimiter: Some(Nothing) }, Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::group::BraceGroup>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Punct { char: ':', spacing: Alone, span: bytes(16306..16307) })) }, delimiter: Some(Nothing) }, Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::group::BraceGroup>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Ident { sym: Result, span: bytes(16307..16313) })) }, delimiter: Some(Nothing) }, Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::group::BraceGroup>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>> { first: Operator<'<'>, second: [Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::operator::Operator<'>'>>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(16314..16316) })) }], third: Operator<'>'> })) }, delimiter: Some(Nothing) }]) }), where_clause: None, body: BraceGroup(Group { delimiter: Brace, stream: TokenStream [Ident { sym: let, span: bytes(16328..16331) }, Ident { sym: editor_lines, span: bytes(16332..16344) }, Punct { char: '=', spacing: Alone, span: bytes(16345..16346) }, Ident { sym: if, span: bytes(16347..16349) }, Ident { sym: let, span: bytes(16350..16353) }, Ident { sym: Some, span: bytes(16354..16358) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: ref, span: bytes(16359..16362) }, Ident { sym: editor_state, span: bytes(16363..16375) }], span: bytes(16358..16376) }, Punct { char: '=', spacing: Alone, span: bytes(16377..16378) }, Ident { sym: self, span: bytes(16379..16383) }, Punct { char: '.', spacing: Alone, span: bytes(16383..16384) }, Ident { sym: editor_state, span: bytes(16384..16396) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: editor_state, span: bytes(16411..16423) }, Punct { char: '.', spacing: Alone, span: bytes(16440..16441) }, Ident { sym: lines, span: bytes(16441..16446) }, Punct { char: '.', spacing: Alone, span: bytes(16463..16464) }, Ident { sym: iter_row, span: bytes(16464..16472) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(16472..16474) }, Punct { char: '.', spacing: Alone, span: bytes(16491..16492) }, Ident { sym: map, span: bytes(16492..16495) }, Group { delimiter: Parenthesis, stream: TokenStream [Punct { char: '|', spacing: Alone, span: bytes(16496..16497) }, Ident { sym: line, span: bytes(16497..16501) }, Punct { char: '|', spacing: Alone, span: bytes(16501..16502) }, Ident { sym: line, span: bytes(16503..16507) }, Punct { char: '.', spacing: Alone, span: bytes(16507..16508) }, Ident { sym: iter, span: bytes(16508..16512) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(16512..16514) }, Punct { char: '.', spacing: Alone, span: bytes(16514..16515) }, Ident { sym: collect, span: bytes(16515..16522) }, Punct { char: ':', spacing: Joint, span: bytes(16522..16523) }, Punct { char: ':', spacing: Joint, span: bytes(16523..16524) }, Punct { char: '<', spacing: Alone, span: bytes(16524..16525) }, Ident { sym: String, span: bytes(16525..16531) }, Punct { char: '>', spacing: Alone, span: bytes(16531..16532) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(16532..16534) }], span: bytes(16495..16535) }, Punct { char: '.', spacing: Alone, span: bytes(16552..16553) }, Ident { sym: collect, span: bytes(16553..16560) }, Punct { char: ':', spacing: Joint, span: bytes(16560..16561) }, Punct { char: ':', spacing: Joint, span: bytes(16561..16562) }, Punct { char: '<', spacing: Alone, span: bytes(16562..16563) }, Ident { sym: Vec, span: bytes(16563..16566) }, Punct { char: '<', spacing: Alone, span: bytes(16566..16567) }, Ident { sym: _, span: bytes(16567..16568) }, Punct { char: '>', spacing: Joint, span: bytes(16568..16569) }, Punct { char: '>', spacing: Alone, span: bytes(16569..16570) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(16570..16572) }], span: bytes(16397..16582) }, Ident { sym: else, span: bytes(16583..16587) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: return, span: bytes(16602..16608) }, Ident { sym: Ok, span: bytes(16609..16611) }, Group { delimiter: Parenthesis, stream: TokenStream [Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(16612..16614) }], span: bytes(16611..16615) }, Punct { char: ';', spacing: Alone, span: bytes(16615..16616) }], span: bytes(16588..16626) }, Punct { char: ';', spacing: Alone, span: bytes(16626..16627) }, Ident { sym: let, span: bytes(16637..16640) }, Ident { sym: Some, span: bytes(16641..16645) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: section_idx, span: bytes(16646..16657) }], span: bytes(16645..16658) }, Punct { char: '=', spacing: Alone, span: bytes(16659..16660) }, Ident { sym: self, span: bytes(16661..16665) }, Punct { char: '.', spacing: Alone, span: bytes(16665..16666) }, Ident { sym: get_current_section_index, span: bytes(16666..16691) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(16691..16693) }, Ident { sym: else, span: bytes(16694..16698) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: return, span: bytes(16713..16719) }, Ident { sym: Ok, span: bytes(16720..16722) }, Group { delimiter: Parenthesis, stream: TokenStream [Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(16723..16725) }], span: bytes(16722..16726) }, Punct { char: ';', spacing: Alone, span: bytes(16726..16727) }], span: bytes(16699..16737) }, Punct { char: ';', spacing: Alone, span: bytes(16737..16738) }, Ident { sym: self, span: bytes(16748..16752) }, Punct { char: '.', spacing: Alone, span: bytes(16752..16753) }, Ident { sym: sections, span: bytes(16753..16761) }, Group { delimiter: Bracket, stream: TokenStream [Ident { sym: section_idx, span: bytes(16762..16773) }], span: bytes(16761..16774) }, Punct { char: '.', spacing: Alone, span: bytes(16774..16775) }, Ident { sym: section_content, span: bytes(16775..16790) }, Punct { char: '=', spacing: Alone, span: bytes(16791..16792) }, Ident { sym: Some, span: bytes(16793..16797) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: editor_lines, span: bytes(16798..16810) }, Punct { char: '.', spacing: Alone, span: bytes(16810..16811) }, Ident { sym: clone, span: bytes(16811..16816) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(16816..16818) }], span: bytes(16797..16819) }, Punct { char: ';', spacing: Alone, span: bytes(16819..16820) }, Ident { sym: let, span: bytes(16830..16833) }, Ident { sym: section, span: bytes(16834..16841) }, Punct { char: '=', spacing: Alone, span: bytes(16842..16843) }, Punct { char: '&', spacing: Alone, span: bytes(16844..16845) }, Ident { sym: self, span: bytes(16845..16849) }, Punct { char: '.', spacing: Alone, span: bytes(16849..16850) }, Ident { sym: sections, span: bytes(16850..16858) }, Group { delimiter: Bracket, stream: TokenStream [Ident { sym: section_idx, span: bytes(16859..16870) }], span: bytes(16858..16871) }, Punct { char: ';', spacing: Alone, span: bytes(16871..16872) }, Ident { sym: let, span: bytes(16882..16885) }, Ident { sym: raw_content, span: bytes(16886..16897) }, Punct { char: '=', spacing: Alone, span: bytes(16898..16899) }, Ident { sym: editor_lines, span: bytes(16900..16912) }, Punct { char: '.', spacing: Alone, span: bytes(16912..16913) }, Ident { sym: join, span: bytes(16913..16917) }, Group { delimiter: Parenthesis, stream: TokenStream [Literal { lit: "\n", span: bytes(16918..16922) }], span: bytes(16917..16923) }, Punct { char: ';', spacing: Alone, span: bytes(16923..16924) }, Ident { sym: let, span: bytes(16933..16936) }, Ident { sym: trimmed_content, span: bytes(16937..16952) }, Punct { char: '=', spacing: Alone, span: bytes(16953..16954) }, Ident { sym: raw_content, span: bytes(16955..16966) }, Punct { char: '.', spacing: Alone, span: bytes(16966..16967) }, Ident { sym: trim, span: bytes(16967..16971) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(16971..16973) }, Punct { char: ';', spacing: Alone, span: bytes(16973..16974) }, Ident { sym: let, span: bytes(16983..16986) }, Ident { sym: padded_content, span: bytes(16987..17001) }, Punct { char: '=', spacing: Alone, span: bytes(17002..17003) }, Ident { sym: format, span: bytes(17004..17010) }, Punct { char: '!', spacing: Alone, span: bytes(17010..17011) }, Group { delimiter: Parenthesis, stream: TokenStream [Literal { lit: "\n{trimmed_content}\n\n", span: bytes(17012..17037) }], span: bytes(17011..17038) }, Punct { char: ';', spacing: Alone, span: bytes(17038..17039) }, Ident { sym: let, span: bytes(17049..17052) }, Ident { sym: edit, span: bytes(17053..17057) }, Punct { char: '=', spacing: Alone, span: bytes(17058..17059) }, Ident { sym: Edit, span: bytes(17060..17064) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: file_name, span: bytes(17079..17088) }, Punct { char: ':', spacing: Alone, span: bytes(17088..17089) }, Ident { sym: section, span: bytes(17090..17097) }, Punct { char: '.', spacing: Alone, span: bytes(17097..17098) }, Ident { sym: file_path, span: bytes(17098..17107) }, Punct { char: '.', spacing: Alone, span: bytes(17107..17108) }, Ident { sym: clone, span: bytes(17108..17113) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(17113..17115) }, Punct { char: ',', spacing: Alone, span: bytes(17115..17116) }, Ident { sym: line_start, span: bytes(17129..17139) }, Punct { char: ':', spacing: Alone, span: bytes(17139..17140) }, Ident { sym: section, span: bytes(17141..17148) }, Punct { char: '.', spacing: Alone, span: bytes(17148..17149) }, Ident { sym: line_start, span: bytes(17149..17159) }, Punct { char: ',', spacing: Alone, span: bytes(17159..17160) }, Ident { sym: line_end, span: bytes(17173..17181) }, Punct { char: ':', spacing: Alone, span: bytes(17181..17182) }, Ident { sym: section, span: bytes(17183..17190) }, Punct { char: '.', spacing: Alone, span: bytes(17190..17191) }, Ident { sym: line_end, span: bytes(17191..17199) }, Punct { char: ',', spacing: Alone, span: bytes(17199..17200) }, Ident { sym: column_start, span: bytes(17213..17225) }, Punct { char: ':', spacing: Alone, span: bytes(17225..17226) }, Ident { sym: section, span: bytes(17227..17234) }, Punct { char: '.', spacing: Alone, span: bytes(17234..17235) }, Ident { sym: column_start, span: bytes(17235..17247) }, Punct { char: ',', spacing: Alone, span: bytes(17247..17248) }, Ident { sym: column_end, span: bytes(17261..17271) }, Punct { char: ':', spacing: Alone, span: bytes(17271..17272) }, Ident { sym: section, span: bytes(17273..17280) }, Punct { char: '.', spacing: Alone, span: bytes(17280..17281) }, Ident { sym: column_end, span: bytes(17281..17291) }, Punct { char: ',', spacing: Alone, span: bytes(17291..17292) }, Ident { sym: section_content, span: bytes(17305..17320) }, Punct { char: ':', spacing: Alone, span: bytes(17320..17321) }, Ident { sym: padded_content, span: bytes(17322..17336) }, Punct { char: ',', spacing: Alone, span: bytes(17336..17337) }, Ident { sym: item_name, span: bytes(17350..17359) }, Punct { char: ':', spacing: Alone, span: bytes(17359..17360) }, Ident { sym: section, span: bytes(17361..17368) }, Punct { char: '.', spacing: Alone, span: bytes(17368..17369) }, Ident { sym: title, span: bytes(17369..17374) }, Punct { char: '.', spacing: Alone, span: bytes(17374..17375) }, Ident { sym: clone, span: bytes(17375..17380) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(17380..17382) }, Punct { char: ',', spacing: Alone, span: bytes(17382..17383) }], span: bytes(17065..17393) }, Punct { char: ';', spacing: Alone, span: bytes(17393..17394) }, Ident { sym: let, span: bytes(17404..17407) }, Ident { sym: mut, span: bytes(17408..17411) }, Ident { sym: plan, span: bytes(17412..17416) }, Punct { char: '=', spacing: Alone, span: bytes(17417..17418) }, Ident { sym: EditPlan, span: bytes(17419..17427) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: edits, span: bytes(17430..17435) }, Punct { char: ':', spacing: Alone, span: bytes(17435..17436) }, Ident { sym: vec, span: bytes(17437..17440) }, Punct { char: '!', spacing: Alone, span: bytes(17440..17441) }, Group { delimiter: Bracket, stream: TokenStream [Ident { sym: edit, span: bytes(17442..17446) }], span: bytes(17441..17447) }], span: bytes(17428..17449) }, Punct { char: ';', spacing: Alone, span: bytes(17449..17450) }, Ident { sym: plan, span: bytes(17459..17463) }, Punct { char: '.', spacing: Alone, span: bytes(17463..17464) }, Ident { sym: apply, span: bytes(17464..17469) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(17469..17471) }, Punct { char: '?', spacing: Joint, span: bytes(17471..17472) }, Punct { char: ';', spacing: Alone, span: bytes(17472..17473) }, Ident { sym: let, span: bytes(17510..17513) }, Ident { sym: format, span: bytes(17514..17520) }, Punct { char: '=', spacing: Alone, span: bytes(17521..17522) }, Ident { sym: MarkdownFormat, span: bytes(17523..17537) }, Punct { char: ';', spacing: Alone, span: bytes(17537..17538) }, Ident { sym: if, span: bytes(17547..17549) }, Ident { sym: let, span: bytes(17550..17553) }, Ident { sym: Ok, span: bytes(17554..17556) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: new_sections, span: bytes(17557..17569) }], span: bytes(17556..17570) }, Punct { char: '=', spacing: Alone, span: bytes(17571..17572) }, Ident { sym: input, span: bytes(17585..17590) }, Punct { char: ':', spacing: Joint, span: bytes(17590..17591) }, Punct { char: ':', spacing: Alone, span: bytes(17591..17592) }, Ident { sym: extract_sections, span: bytes(17592..17608) }, Group { delimiter: Parenthesis, stream: TokenStream [Punct { char: '&', spacing: Alone, span: bytes(17609..17610) }, Ident { sym: PathBuf, span: bytes(17610..17617) }, Punct { char: ':', spacing: Joint, span: bytes(17617..17618) }, Punct { char: ':', spacing: Alone, span: bytes(17618..17619) }, Ident { sym: from, span: bytes(17619..17623) }, Group { delimiter: Parenthesis, stream: TokenStream [Punct { char: '&', spacing: Alone, span: bytes(17624..17625) }, Ident { sym: section, span: bytes(17625..17632) }, Punct { char: '.', spacing: Alone, span: bytes(17632..17633) }, Ident { sym: file_path, span: bytes(17633..17642) }], span: bytes(17623..17643) }, Punct { char: ',', spacing: Alone, span: bytes(17643..17644) }, Punct { char: '&', spacing: Alone, span: bytes(17645..17646) }, Ident { sym: format, span: bytes(17646..17652) }], span: bytes(17608..17653) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: let, span: bytes(17676..17679) }, Ident { sym: target_title, span: bytes(17680..17692) }, Punct { char: '=', spacing: Alone, span: bytes(17693..17694) }, Ident { sym: section, span: bytes(17695..17702) }, Punct { char: '.', spacing: Alone, span: bytes(17702..17703) }, Ident { sym: title, span: bytes(17703..17708) }, Punct { char: '.', spacing: Alone, span: bytes(17708..17709) }, Ident { sym: clone, span: bytes(17709..17714) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(17714..17716) }, Punct { char: ';', spacing: Alone, span: bytes(17716..17717) }, Ident { sym: let, span: bytes(17730..17733) }, Ident { sym: target_level, span: bytes(17734..17746) }, Punct { char: '=', spacing: Alone, span: bytes(17747..17748) }, Ident { sym: section, span: bytes(17749..17756) }, Punct { char: '.', spacing: Alone, span: bytes(17756..17757) }, Ident { sym: level, span: bytes(17757..17762) }, Punct { char: ';', spacing: Alone, span: bytes(17762..17763) }, Ident { sym: let, span: bytes(17777..17780) }, Ident { sym: file_path, span: bytes(17781..17790) }, Punct { char: '=', spacing: Alone, span: bytes(17791..17792) }, Ident { sym: section, span: bytes(17793..17800) }, Punct { char: '.', spacing: Alone, span: bytes(17800..17801) }, Ident { sym: file_path, span: bytes(17801..17810) }, Punct { char: '.', spacing: Alone, span: bytes(17810..17811) }, Ident { sym: clone, span: bytes(17811..17816) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(17816..17818) }, Punct { char: ';', spacing: Alone, span: bytes(17818..17819) }, Ident { sym: self, span: bytes(17832..17836) }, Punct { char: '.', spacing: Alone, span: bytes(17836..17837) }, Ident { sym: sections, span: bytes(17837..17845) }, Punct { char: '.', spacing: Alone, span: bytes(17845..17846) }, Ident { sym: retain, span: bytes(17846..17852) }, Group { delimiter: Parenthesis, stream: TokenStream [Punct { char: '|', spacing: Alone, span: bytes(17853..17854) }, Ident { sym: s, span: bytes(17854..17855) }, Punct { char: '|', spacing: Alone, span: bytes(17855..17856) }, Ident { sym: s, span: bytes(17857..17858) }, Punct { char: '.', spacing: Alone, span: bytes(17858..17859) }, Ident { sym: file_path, span: bytes(17859..17868) }, Punct { char: '!', spacing: Joint, span: bytes(17869..17870) }, Punct { char: '=', spacing: Alone, span: bytes(17870..17871) }, Ident { sym: file_path, span: bytes(17872..17881) }], span: bytes(17852..17882) }, Punct { char: ';', spacing: Alone, span: bytes(17882..17883) }, Ident { sym: if, span: bytes(17897..17899) }, Ident { sym: let, span: bytes(17900..17903) }, Ident { sym: Some, span: bytes(17904..17908) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: local_index, span: bytes(17909..17920) }], span: bytes(17908..17921) }, Punct { char: '=', spacing: Alone, span: bytes(17922..17923) }, Ident { sym: new_sections, span: bytes(17924..17936) }, Punct { char: '.', spacing: Alone, span: bytes(17953..17954) }, Ident { sym: iter, span: bytes(17954..17958) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(17958..17960) }, Punct { char: '.', spacing: Alone, span: bytes(17977..17978) }, Ident { sym: position, span: bytes(17978..17986) }, Group { delimiter: Parenthesis, stream: TokenStream [Punct { char: '|', spacing: Alone, span: bytes(17987..17988) }, Ident { sym: s, span: bytes(17988..17989) }, Punct { char: '|', spacing: Alone, span: bytes(17989..17990) }, Ident { sym: s, span: bytes(17991..17992) }, Punct { char: '.', spacing: Alone, span: bytes(17992..17993) }, Ident { sym: title, span: bytes(17993..17998) }, Punct { char: '=', spacing: Joint, span: bytes(17999..18000) }, Punct { char: '=', spacing: Alone, span: bytes(18000..18001) }, Ident { sym: target_title, span: bytes(18002..18014) }, Punct { char: '&', spacing: Joint, span: bytes(18015..18016) }, Punct { char: '&', spacing: Alone, span: bytes(18016..18017) }, Ident { sym: s, span: bytes(18018..18019) }, Punct { char: '.', spacing: Alone, span: bytes(18019..18020) }, Ident { sym: level, span: bytes(18020..18025) }, Punct { char: '=', spacing: Joint, span: bytes(18026..18027) }, Punct { char: '=', spacing: Alone, span: bytes(18027..18028) }, Ident { sym: target_level, span: bytes(18029..18041) }], span: bytes(17986..18042) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: let, span: bytes(18073..18076) }, Ident { sym: new_global_index, span: bytes(18077..18093) }, Punct { char: '=', spacing: Alone, span: bytes(18094..18095) }, Ident { sym: self, span: bytes(18096..18100) }, Punct { char: '.', spacing: Alone, span: bytes(18100..18101) }, Ident { sym: sections, span: bytes(18101..18109) }, Punct { char: '.', spacing: Alone, span: bytes(18109..18110) }, Ident { sym: len, span: bytes(18110..18113) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(18113..18115) }, Punct { char: '+', spacing: Alone, span: bytes(18116..18117) }, Ident { sym: local_index, span: bytes(18118..18129) }, Punct { char: ';', spacing: Alone, span: bytes(18129..18130) }, Ident { sym: self, span: bytes(18147..18151) }, Punct { char: '.', spacing: Alone, span: bytes(18151..18152) }, Ident { sym: sections, span: bytes(18152..18160) }, Punct { char: '.', spacing: Alone, span: bytes(18160..18161) }, Ident { sym: extend, span: bytes(18161..18167) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: new_sections, span: bytes(18168..18180) }], span: bytes(18167..18181) }, Punct { char: ';', spacing: Alone, span: bytes(18181..18182) }, Ident { sym: self, span: bytes(18261..18265) }, Punct { char: '.', spacing: Alone, span: bytes(18265..18266) }, Ident { sym: rebuild_tree, span: bytes(18266..18278) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(18278..18280) }, Punct { char: ';', spacing: Alone, span: bytes(18280..18281) }, Ident { sym: if, span: bytes(18352..18354) }, Ident { sym: let, span: bytes(18355..18358) }, Ident { sym: Some, span: bytes(18359..18363) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: node_idx, span: bytes(18364..18372) }], span: bytes(18363..18373) }, Punct { char: '=', spacing: Alone, span: bytes(18374..18375) }, Ident { sym: self, span: bytes(18376..18380) }, Punct { char: '.', spacing: Alone, span: bytes(18401..18402) }, Ident { sym: tree_nodes, span: bytes(18402..18412) }, Punct { char: '.', spacing: Alone, span: bytes(18433..18434) }, Ident { sym: iter, span: bytes(18434..18438) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(18438..18440) }, Punct { char: '.', spacing: Alone, span: bytes(18461..18462) }, Ident { sym: position, span: bytes(18462..18470) }, Group { delimiter: Parenthesis, stream: TokenStream [Punct { char: '|', spacing: Alone, span: bytes(18471..18472) }, Ident { sym: n, span: bytes(18472..18473) }, Punct { char: '|', spacing: Alone, span: bytes(18473..18474) }, Ident { sym: n, span: bytes(18475..18476) }, Punct { char: '.', spacing: Alone, span: bytes(18476..18477) }, Ident { sym: section_index, span: bytes(18477..18490) }, Punct { char: '=', spacing: Joint, span: bytes(18491..18492) }, Punct { char: '=', spacing: Alone, span: bytes(18492..18493) }, Ident { sym: Some, span: bytes(18494..18498) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: new_global_index, span: bytes(18499..18515) }], span: bytes(18498..18516) }], span: bytes(18470..18517) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: self, span: bytes(18556..18560) }, Punct { char: '.', spacing: Alone, span: bytes(18560..18561) }, Ident { sym: current_node_index, span: bytes(18561..18579) }, Punct { char: '=', spacing: Alone, span: bytes(18580..18581) }, Ident { sym: node_idx, span: bytes(18582..18590) }, Punct { char: ';', spacing: Alone, span: bytes(18590..18591) }], span: bytes(18534..18609) }], span: bytes(18055..18623) }, Ident { sym: else, span: bytes(18624..18628) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: self, span: bytes(18647..18651) }, Punct { char: '.', spacing: Alone, span: bytes(18651..18652) }, Ident { sym: sections, span: bytes(18652..18660) }, Punct { char: '.', spacing: Alone, span: bytes(18660..18661) }, Ident { sym: extend, span: bytes(18661..18667) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: new_sections, span: bytes(18668..18680) }], span: bytes(18667..18681) }, Punct { char: ';', spacing: Alone, span: bytes(18681..18682) }, Ident { sym: self, span: bytes(18699..18703) }, Punct { char: '.', spacing: Alone, span: bytes(18703..18704) }, Ident { sym: rebuild_tree, span: bytes(18704..18716) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(18716..18718) }, Punct { char: ';', spacing: Alone, span: bytes(18718..18719) }], span: bytes(18629..18733) }], span: bytes(17662..18743) }, Ident { sym: self, span: bytes(18753..18757) }, Punct { char: '.', spacing: Alone, span: bytes(18757..18758) }, Ident { sym: rebuild_file_offsets, span: bytes(18758..18778) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(18778..18780) }, Punct { char: ';', spacing: Alone, span: bytes(18780..18781) }, Ident { sym: self, span: bytes(18790..18794) }, Punct { char: '.', spacing: Alone, span: bytes(18794..18795) }, Ident { sym: message, span: bytes(18795..18802) }, Punct { char: '=', spacing: Alone, span: bytes(18803..18804) }, Ident { sym: Some, span: bytes(18805..18809) }, Group { delimiter: Parenthesis, stream: TokenStream [Literal { lit: "Saved", span: bytes(18810..18817) }, Punct { char: '.', spacing: Alone, span: bytes(18817..18818) }, Ident { sym: to_string, span: bytes(18818..18827) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(18827..18829) }], span: bytes(18809..18830) }, Punct { char: ';', spacing: Alone, span: bytes(18830..18831) }, Ident { sym: Ok, span: bytes(18840..18842) }, Group { delimiter: Parenthesis, stream: TokenStream [Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(18843..18845) }], span: bytes(18842..18846) }], span: bytes(16318..18852) }) }), delimiter: Some(Nothing) }, Delimited<syncdoc_core::parse::ModuleItem, unsynn::fundamental::Nothing> { value: Function(FnSig { attributes: Some(Repeats<1, 18446744073709551615, syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing>([Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: doc, span: bytes(18858..18893) }, Punct { char: '=', spacing: Alone, span: bytes(18858..18893) }, Literal { lit: " Navigate to next navigable node", span: bytes(18858..18893) }], span: bytes(18858..18893) }) }, delimiter: Some(Nothing) }, Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: must_use, span: bytes(18900..18908) }], span: bytes(18899..18909) }) }, delimiter: Some(Nothing) }])), visibility: Some(Public(KPub(Cached<proc_macro2::Ident> { value: Ident { sym: pub, span: bytes(18914..18917) }, string: "pub" }))), const_kw: None, async_kw: None, unsafe_kw: None, extern_kw: None, _fn: KFn(Cached<proc_macro2::Ident> { value: Ident { sym: fn, span: bytes(18918..18920) }, string: "fn" }), name: Ident { sym: find_next_node, span: bytes(18921..18935) }, generics: None, params: ParenthesisGroupContaining < core::option::Option<unsynn::container::DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>>>(Some(DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>([Delimited<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>> { value: SelfParam(Ref(Cons<unsynn::operator::Operator<'&'>, syncdoc_core::parse::KSelf> { first: Operator<'&'>, second: KSelf(Cached<proc_macro2::Ident> { value: Ident { sym: self, span: bytes(18937..18941) }, string: "self" }) })), delimiter: None }]))), return_type: Some(ReturnTypeFn { _arrow: Operator<'->'>, return_type: Repeats<1, 18446744073709551615, unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing>([Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::group::BraceGroup>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Ident { sym: Option, span: bytes(18946..18952) })) }, delimiter: Some(Nothing) }, Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::group::BraceGroup>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>> { first: Operator<'<'>, second: [Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::operator::Operator<'>'>>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Ident { sym: usize, span: bytes(18953..18958) })) }], third: Operator<'>'> })) }, delimiter: Some(Nothing) }]) }), where_clause: None, body: BraceGroup(Group { delimiter: Brace, stream: TokenStream [Group { delimiter: Parenthesis, stream: TokenStream [Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: self, span: bytes(18972..18976) }, Punct { char: '.', spacing: Alone, span: bytes(18976..18977) }, Ident { sym: current_node_index, span: bytes(18977..18995) }, Punct { char: '+', spacing: Alone, span: bytes(18996..18997) }, Literal { lit: 1, span: bytes(18998..18999) }], span: bytes(18971..19000) }, Punct { char: '.', spacing: Joint, span: bytes(19000..19001) }, Punct { char: '.', spacing: Alone, span: bytes(19001..19002) }, Ident { sym: self, span: bytes(19002..19006) }, Punct { char: '.', spacing: Alone, span: bytes(19006..19007) }, Ident { sym: tree_nodes, span: bytes(19007..19017) }, Punct { char: '.', spacing: Alone, span: bytes(19017..19018) }, Ident { sym: len, span: bytes(19018..19021) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(19021..19023) }], span: bytes(18970..19024) }, Punct { char: '.', spacing: Alone, span: bytes(19037..19038) }, Ident { sym: find, span: bytes(19038..19042) }, Group { delimiter: Parenthesis, stream: TokenStream [Punct { char: '|', spacing: Joint, span: bytes(19043..19044) }, Punct { char: '&', spacing: Alone, span: bytes(19044..19045) }, Ident { sym: i, span: bytes(19045..19046) }, Punct { char: '|', spacing: Alone, span: bytes(19046..19047) }, Ident { sym: self, span: bytes(19048..19052) }, Punct { char: '.', spacing: Alone, span: bytes(19052..19053) }, Ident { sym: tree_nodes, span: bytes(19053..19063) }, Group { delimiter: Bracket, stream: TokenStream [Ident { sym: i, span: bytes(19064..19065) }], span: bytes(19063..19066) }, Punct { char: '.', spacing: Alone, span: bytes(19066..19067) }, Ident { sym: navigable, span: bytes(19067..19076) }], span: bytes(19042..19077) }], span: bytes(18960..19083) }) }), delimiter: Some(Nothing) }, Delimited<syncdoc_core::parse::ModuleItem, unsynn::fundamental::Nothing> { value: Function(FnSig { attributes: Some(Repeats<1, 18446744073709551615, syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing>([Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: doc, span: bytes(19089..19128) }, Punct { char: '=', spacing: Alone, span: bytes(19089..19128) }, Literal { lit: " Navigate to previous navigable node", span: bytes(19089..19128) }], span: bytes(19089..19128) }) }, delimiter: Some(Nothing) }, Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: must_use, span: bytes(19135..19143) }], span: bytes(19134..19144) }) }, delimiter: Some(Nothing) }])), visibility: Some(Public(KPub(Cached<proc_macro2::Ident> { value: Ident { sym: pub, span: bytes(19149..19152) }, string: "pub" }))), const_kw: None, async_kw: None, unsafe_kw: None, extern_kw: None, _fn: KFn(Cached<proc_macro2::Ident> { value: Ident { sym: fn, span: bytes(19153..19155) }, string: "fn" }), name: Ident { sym: find_prev_node, span: bytes(19156..19170) }, generics: None, params: ParenthesisGroupContaining < core::option::Option<unsynn::container::DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>>>(Some(DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>([Delimited<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>> { value: SelfParam(Ref(Cons<unsynn::operator::Operator<'&'>, syncdoc_core::parse::KSelf> { first: Operator<'&'>, second: KSelf(Cached<proc_macro2::Ident> { value: Ident { sym: self, span: bytes(19172..19176) }, string: "self" }) })), delimiter: None }]))), return_type: Some(ReturnTypeFn { _arrow: Operator<'->'>, return_type: Repeats<1, 18446744073709551615, unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing>([Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::group::BraceGroup>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Ident { sym: Option, span: bytes(19181..19187) })) }, delimiter: Some(Nothing) }, Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::group::BraceGroup>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>> { first: Operator<'<'>, second: [Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::operator::Operator<'>'>>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Ident { sym: usize, span: bytes(19188..19193) })) }], third: Operator<'>'> })) }, delimiter: Some(Nothing) }]) }), where_clause: None, body: BraceGroup(Group { delimiter: Brace, stream: TokenStream [Group { delimiter: Parenthesis, stream: TokenStream [Literal { lit: 0, span: bytes(19206..19207) }, Punct { char: '.', spacing: Joint, span: bytes(19207..19208) }, Punct { char: '.', spacing: Alone, span: bytes(19208..19209) }, Ident { sym: self, span: bytes(19209..19213) }, Punct { char: '.', spacing: Alone, span: bytes(19213..19214) }, Ident { sym: current_node_index, span: bytes(19214..19232) }], span: bytes(19205..19233) }, Punct { char: '.', spacing: Alone, span: bytes(19246..19247) }, Ident { sym: rev, span: bytes(19247..19250) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(19250..19252) }, Punct { char: '.', spacing: Alone, span: bytes(19265..19266) }, Ident { sym: find, span: bytes(19266..19270) }, Group { delimiter: Parenthesis, stream: TokenStream [Punct { char: '|', spacing: Joint, span: bytes(19271..19272) }, Punct { char: '&', spacing: Alone, span: bytes(19272..19273) }, Ident { sym: i, span: bytes(19273..19274) }, Punct { char: '|', spacing: Alone, span: bytes(19274..19275) }, Ident { sym: self, span: bytes(19276..19280) }, Punct { char: '.', spacing: Alone, span: bytes(19280..19281) }, Ident { sym: tree_nodes, span: bytes(19281..19291) }, Group { delimiter: Bracket, stream: TokenStream [Ident { sym: i, span: bytes(19292..19293) }], span: bytes(19291..19294) }, Punct { char: '.', spacing: Alone, span: bytes(19294..19295) }, Ident { sym: navigable, span: bytes(19295..19304) }], span: bytes(19270..19305) }], span: bytes(19195..19311) }) }), delimiter: Some(Nothing) }, Delimited<syncdoc_core::parse::ModuleItem, unsynn::fundamental::Nothing> { value: Function(FnSig { attributes: Some(Repeats<1, 18446744073709551615, syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing>([Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: doc, span: bytes(19317..19379) }, Punct { char: '=', spacing: Alone, span: bytes(19317..19379) }, Literal { lit: " Moves to the containing section in the document hierarchy.", span: bytes(19317..19379) }], span: bytes(19317..19379) }) }, delimiter: Some(Nothing) }, Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: must_use, span: bytes(19386..19394) }], span: bytes(19385..19395) }) }, delimiter: Some(Nothing) }])), visibility: Some(Public(KPub(Cached<proc_macro2::Ident> { value: Ident { sym: pub, span: bytes(19400..19403) }, string: "pub" }))), const_kw: None, async_kw: None, unsafe_kw: None, extern_kw: None, _fn: KFn(Cached<proc_macro2::Ident> { value: Ident { sym: fn, span: bytes(19404..19406) }, string: "fn" }), name: Ident { sym: navigate_to_parent, span: bytes(19407..19425) }, generics: None, params: ParenthesisGroupContaining < core::option::Option<unsynn::container::DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>>>(Some(DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>([Delimited<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>> { value: SelfParam(Ref(Cons<unsynn::operator::Operator<'&'>, syncdoc_core::parse::KSelf> { first: Operator<'&'>, second: KSelf(Cached<proc_macro2::Ident> { value: Ident { sym: self, span: bytes(19427..19431) }, string: "self" }) })), delimiter: None }]))), return_type: Some(ReturnTypeFn { _arrow: Operator<'->'>, return_type: Repeats<1, 18446744073709551615, unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing>([Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::group::BraceGroup>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Ident { sym: Option, span: bytes(19436..19442) })) }, delimiter: Some(Nothing) }, Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::group::BraceGroup>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>> { first: Operator<'<'>, second: [Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::operator::Operator<'>'>>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Ident { sym: usize, span: bytes(19443..19448) })) }], third: Operator<'>'> })) }, delimiter: Some(Nothing) }]) }), where_clause: None, body: BraceGroup(Group { delimiter: Brace, stream: TokenStream [Ident { sym: let, span: bytes(19460..19463) }, Ident { sym: section_idx, span: bytes(19464..19475) }, Punct { char: '=', spacing: Alone, span: bytes(19476..19477) }, Ident { sym: self, span: bytes(19478..19482) }, Punct { char: '.', spacing: Alone, span: bytes(19482..19483) }, Ident { sym: get_current_section_index, span: bytes(19483..19508) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(19508..19510) }, Punct { char: '?', spacing: Joint, span: bytes(19510..19511) }, Punct { char: ';', spacing: Alone, span: bytes(19511..19512) }, Ident { sym: let, span: bytes(19521..19524) }, Ident { sym: parent_section_idx, span: bytes(19525..19543) }, Punct { char: '=', spacing: Alone, span: bytes(19544..19545) }, Ident { sym: self, span: bytes(19546..19550) }, Punct { char: '.', spacing: Alone, span: bytes(19550..19551) }, Ident { sym: sections, span: bytes(19551..19559) }, Group { delimiter: Bracket, stream: TokenStream [Ident { sym: section_idx, span: bytes(19560..19571) }], span: bytes(19559..19572) }, Punct { char: '.', spacing: Alone, span: bytes(19572..19573) }, Ident { sym: parent_index, span: bytes(19573..19585) }, Punct { char: '?', spacing: Joint, span: bytes(19585..19586) }, Punct { char: ';', spacing: Alone, span: bytes(19586..19587) }, Ident { sym: self, span: bytes(19647..19651) }, Punct { char: '.', spacing: Alone, span: bytes(19651..19652) }, Ident { sym: tree_nodes, span: bytes(19652..19662) }, Punct { char: '.', spacing: Alone, span: bytes(19675..19676) }, Ident { sym: iter, span: bytes(19676..19680) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(19680..19682) }, Punct { char: '.', spacing: Alone, span: bytes(19695..19696) }, Ident { sym: position, span: bytes(19696..19704) }, Group { delimiter: Parenthesis, stream: TokenStream [Punct { char: '|', spacing: Alone, span: bytes(19705..19706) }, Ident { sym: n, span: bytes(19706..19707) }, Punct { char: '|', spacing: Alone, span: bytes(19707..19708) }, Ident { sym: n, span: bytes(19709..19710) }, Punct { char: '.', spacing: Alone, span: bytes(19710..19711) }, Ident { sym: section_index, span: bytes(19711..19724) }, Punct { char: '=', spacing: Joint, span: bytes(19725..19726) }, Punct { char: '=', spacing: Alone, span: bytes(19726..19727) }, Ident { sym: Some, span: bytes(19728..19732) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: parent_section_idx, span: bytes(19733..19751) }], span: bytes(19732..19752) }], span: bytes(19704..19753) }], span: bytes(19450..19759) }) }), delimiter: Some(Nothing) }, Delimited<syncdoc_core::parse::ModuleItem, unsynn::fundamental::Nothing> { value: Function(FnSig { attributes: Some(Repeats<1, 18446744073709551615, syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing>([Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: doc, span: bytes(19765..19831) }, Punct { char: '=', spacing: Alone, span: bytes(19765..19831) }, Literal { lit: " Descends to the first child section in the document hierarchy.", span: bytes(19765..19831) }], span: bytes(19765..19831) }) }, delimiter: Some(Nothing) }, Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: must_use, span: bytes(19838..19846) }], span: bytes(19837..19847) }) }, delimiter: Some(Nothing) }])), visibility: Some(Public(KPub(Cached<proc_macro2::Ident> { value: Ident { sym: pub, span: bytes(19852..19855) }, string: "pub" }))), const_kw: None, async_kw: None, unsafe_kw: None, extern_kw: None, _fn: KFn(Cached<proc_macro2::Ident> { value: Ident { sym: fn, span: bytes(19856..19858) }, string: "fn" }), name: Ident { sym: navigate_to_first_child, span: bytes(19859..19882) }, generics: None, params: ParenthesisGroupContaining < core::option::Option<unsynn::container::DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>>>(Some(DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>([Delimited<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>> { value: SelfParam(Ref(Cons<unsynn::operator::Operator<'&'>, syncdoc_core::parse::KSelf> { first: Operator<'&'>, second: KSelf(Cached<proc_macro2::Ident> { value: Ident { sym: self, span: bytes(19884..19888) }, string: "self" }) })), delimiter: None }]))), return_type: Some(ReturnTypeFn { _arrow: Operator<'->'>, return_type: Repeats<1, 18446744073709551615, unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing>([Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::group::BraceGroup>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Ident { sym: Option, span: bytes(19893..19899) })) }, delimiter: Some(Nothing) }, Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::group::BraceGroup>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>> { first: Operator<'<'>, second: [Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::operator::Operator<'>'>>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Ident { sym: usize, span: bytes(19900..19905) })) }], third: Operator<'>'> })) }, delimiter: Some(Nothing) }]) }), where_clause: None, body: BraceGroup(Group { delimiter: Brace, stream: TokenStream [Ident { sym: let, span: bytes(19917..19920) }, Ident { sym: section_idx, span: bytes(19921..19932) }, Punct { char: '=', spacing: Alone, span: bytes(19933..19934) }, Ident { sym: self, span: bytes(19935..19939) }, Punct { char: '.', spacing: Alone, span: bytes(19939..19940) }, Ident { sym: get_current_section_index, span: bytes(19940..19965) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(19965..19967) }, Punct { char: '?', spacing: Joint, span: bytes(19967..19968) }, Punct { char: ';', spacing: Alone, span: bytes(19968..19969) }, Ident { sym: let, span: bytes(19978..19981) }, Ident { sym: first_child_idx, span: bytes(19982..19997) }, Punct { char: '=', spacing: Alone, span: bytes(19998..19999) }, Ident { sym: self, span: bytes(20000..20004) }, Punct { char: '.', spacing: Alone, span: bytes(20004..20005) }, Ident { sym: sections, span: bytes(20005..20013) }, Group { delimiter: Bracket, stream: TokenStream [Ident { sym: section_idx, span: bytes(20014..20025) }], span: bytes(20013..20026) }, Punct { char: '.', spacing: Alone, span: bytes(20026..20027) }, Ident { sym: children_indices, span: bytes(20027..20043) }, Punct { char: '.', spacing: Alone, span: bytes(20043..20044) }, Ident { sym: first, span: bytes(20044..20049) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(20049..20051) }, Punct { char: '?', spacing: Joint, span: bytes(20051..20052) }, Punct { char: ';', spacing: Alone, span: bytes(20052..20053) }, Ident { sym: self, span: bytes(20063..20067) }, Punct { char: '.', spacing: Alone, span: bytes(20067..20068) }, Ident { sym: tree_nodes, span: bytes(20068..20078) }, Punct { char: '.', spacing: Alone, span: bytes(20091..20092) }, Ident { sym: iter, span: bytes(20092..20096) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(20096..20098) }, Punct { char: '.', spacing: Alone, span: bytes(20111..20112) }, Ident { sym: position, span: bytes(20112..20120) }, Group { delimiter: Parenthesis, stream: TokenStream [Punct { char: '|', spacing: Alone, span: bytes(20121..20122) }, Ident { sym: n, span: bytes(20122..20123) }, Punct { char: '|', spacing: Alone, span: bytes(20123..20124) }, Ident { sym: n, span: bytes(20125..20126) }, Punct { char: '.', spacing: Alone, span: bytes(20126..20127) }, Ident { sym: section_index, span: bytes(20127..20140) }, Punct { char: '=', spacing: Joint, span: bytes(20141..20142) }, Punct { char: '=', spacing: Alone, span: bytes(20142..20143) }, Ident { sym: Some, span: bytes(20144..20148) }, Group { delimiter: Parenthesis, stream: TokenStream [Punct { char: '*', spacing: Alone, span: bytes(20149..20150) }, Ident { sym: first_child_idx, span: bytes(20150..20165) }], span: bytes(20148..20166) }], span: bytes(20120..20167) }], span: bytes(19907..20173) }) }), delimiter: Some(Nothing) }, Delimited<syncdoc_core::parse::ModuleItem, unsynn::fundamental::Nothing> { value: Function(FnSig { attributes: Some(Repeats<1, 18446744073709551615, syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing>([Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: doc, span: bytes(20179..20247) }, Punct { char: '=', spacing: Alone, span: bytes(20179..20247) }, Literal { lit: " Finds the next descendant section at any depth in the hierarchy.", span: bytes(20179..20247) }], span: bytes(20179..20247) }) }, delimiter: Some(Nothing) }, Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: must_use, span: bytes(20254..20262) }], span: bytes(20253..20263) }) }, delimiter: Some(Nothing) }])), visibility: Some(Public(KPub(Cached<proc_macro2::Ident> { value: Ident { sym: pub, span: bytes(20268..20271) }, string: "pub" }))), const_kw: None, async_kw: None, unsafe_kw: None, extern_kw: None, _fn: KFn(Cached<proc_macro2::Ident> { value: Ident { sym: fn, span: bytes(20272..20274) }, string: "fn" }), name: Ident { sym: navigate_to_next_descendant, span: bytes(20275..20302) }, generics: None, params: ParenthesisGroupContaining < core::option::Option<unsynn::container::DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>>>(Some(DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>([Delimited<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>> { value: SelfParam(Ref(Cons<unsynn::operator::Operator<'&'>, syncdoc_core::parse::KSelf> { first: Operator<'&'>, second: KSelf(Cached<proc_macro2::Ident> { value: Ident { sym: self, span: bytes(20304..20308) }, string: "self" }) })), delimiter: None }]))), return_type: Some(ReturnTypeFn { _arrow: Operator<'->'>, return_type: Repeats<1, 18446744073709551615, unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing>([Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::group::BraceGroup>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Ident { sym: Option, span: bytes(20313..20319) })) }, delimiter: Some(Nothing) }, Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::group::BraceGroup>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>> { first: Operator<'<'>, second: [Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::operator::Operator<'>'>>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Ident { sym: usize, span: bytes(20320..20325) })) }], third: Operator<'>'> })) }, delimiter: Some(Nothing) }]) }), where_clause: None, body: BraceGroup(Group { delimiter: Brace, stream: TokenStream [Ident { sym: let, span: bytes(20337..20340) }, Ident { sym: section_idx, span: bytes(20341..20352) }, Punct { char: '=', spacing: Alone, span: bytes(20353..20354) }, Ident { sym: self, span: bytes(20355..20359) }, Punct { char: '.', spacing: Alone, span: bytes(20359..20360) }, Ident { sym: get_current_section_index, span: bytes(20360..20385) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(20385..20387) }, Punct { char: '?', spacing: Joint, span: bytes(20387..20388) }, Punct { char: ';', spacing: Alone, span: bytes(20388..20389) }, Ident { sym: if, span: bytes(20439..20441) }, Ident { sym: let, span: bytes(20442..20445) }, Ident { sym: Some, span: bytes(20446..20450) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: first_child, span: bytes(20451..20462) }], span: bytes(20450..20463) }, Punct { char: '=', spacing: Alone, span: bytes(20464..20465) }, Ident { sym: self, span: bytes(20466..20470) }, Punct { char: '.', spacing: Alone, span: bytes(20470..20471) }, Ident { sym: sections, span: bytes(20471..20479) }, Group { delimiter: Bracket, stream: TokenStream [Ident { sym: section_idx, span: bytes(20480..20491) }], span: bytes(20479..20492) }, Punct { char: '.', spacing: Alone, span: bytes(20492..20493) }, Ident { sym: children_indices, span: bytes(20493..20509) }, Punct { char: '.', spacing: Alone, span: bytes(20509..20510) }, Ident { sym: first, span: bytes(20510..20515) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(20515..20517) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: return, span: bytes(20532..20538) }, Ident { sym: self, span: bytes(20539..20543) }, Punct { char: '.', spacing: Alone, span: bytes(20560..20561) }, Ident { sym: tree_nodes, span: bytes(20561..20571) }, Punct { char: '.', spacing: Alone, span: bytes(20588..20589) }, Ident { sym: iter, span: bytes(20589..20593) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(20593..20595) }, Punct { char: '.', spacing: Alone, span: bytes(20612..20613) }, Ident { sym: position, span: bytes(20613..20621) }, Group { delimiter: Parenthesis, stream: TokenStream [Punct { char: '|', spacing: Alone, span: bytes(20622..20623) }, Ident { sym: n, span: bytes(20623..20624) }, Punct { char: '|', spacing: Alone, span: bytes(20624..20625) }, Ident { sym: n, span: bytes(20626..20627) }, Punct { char: '.', spacing: Alone, span: bytes(20627..20628) }, Ident { sym: section_index, span: bytes(20628..20641) }, Punct { char: '=', spacing: Joint, span: bytes(20642..20643) }, Punct { char: '=', spacing: Alone, span: bytes(20643..20644) }, Ident { sym: Some, span: bytes(20645..20649) }, Group { delimiter: Parenthesis, stream: TokenStream [Punct { char: '*', spacing: Alone, span: bytes(20650..20651) }, Ident { sym: first_child, span: bytes(20651..20662) }], span: bytes(20649..20663) }], span: bytes(20621..20664) }, Punct { char: ';', spacing: Alone, span: bytes(20664..20665) }], span: bytes(20518..20675) }, Ident { sym: for, span: bytes(20740..20743) }, Ident { sym: i, span: bytes(20744..20745) }, Ident { sym: in, span: bytes(20746..20748) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: section_idx, span: bytes(20750..20761) }, Punct { char: '+', spacing: Alone, span: bytes(20762..20763) }, Literal { lit: 1, span: bytes(20764..20765) }], span: bytes(20749..20766) }, Punct { char: '.', spacing: Joint, span: bytes(20766..20767) }, Punct { char: '.', spacing: Alone, span: bytes(20767..20768) }, Ident { sym: self, span: bytes(20768..20772) }, Punct { char: '.', spacing: Alone, span: bytes(20772..20773) }, Ident { sym: sections, span: bytes(20773..20781) }, Punct { char: '.', spacing: Alone, span: bytes(20781..20782) }, Ident { sym: len, span: bytes(20782..20785) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(20785..20787) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: if, span: bytes(20802..20804) }, Ident { sym: self, span: bytes(20805..20809) }, Punct { char: '.', spacing: Alone, span: bytes(20809..20810) }, Ident { sym: sections, span: bytes(20810..20818) }, Group { delimiter: Bracket, stream: TokenStream [Ident { sym: i, span: bytes(20819..20820) }], span: bytes(20818..20821) }, Punct { char: '.', spacing: Alone, span: bytes(20821..20822) }, Ident { sym: level, span: bytes(20822..20827) }, Punct { char: '>', spacing: Alone, span: bytes(20828..20829) }, Ident { sym: self, span: bytes(20830..20834) }, Punct { char: '.', spacing: Alone, span: bytes(20834..20835) }, Ident { sym: sections, span: bytes(20835..20843) }, Group { delimiter: Bracket, stream: TokenStream [Ident { sym: section_idx, span: bytes(20844..20855) }], span: bytes(20843..20856) }, Punct { char: '.', spacing: Alone, span: bytes(20856..20857) }, Ident { sym: level, span: bytes(20857..20862) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: return, span: bytes(20881..20887) }, Ident { sym: self, span: bytes(20888..20892) }, Punct { char: '.', spacing: Alone, span: bytes(20913..20914) }, Ident { sym: tree_nodes, span: bytes(20914..20924) }, Punct { char: '.', spacing: Alone, span: bytes(20945..20946) }, Ident { sym: iter, span: bytes(20946..20950) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(20950..20952) }, Punct { char: '.', spacing: Alone, span: bytes(20973..20974) }, Ident { sym: position, span: bytes(20974..20982) }, Group { delimiter: Parenthesis, stream: TokenStream [Punct { char: '|', spacing: Alone, span: bytes(20983..20984) }, Ident { sym: n, span: bytes(20984..20985) }, Punct { char: '|', spacing: Alone, span: bytes(20985..20986) }, Ident { sym: n, span: bytes(20987..20988) }, Punct { char: '.', spacing: Alone, span: bytes(20988..20989) }, Ident { sym: section_index, span: bytes(20989..21002) }, Punct { char: '=', spacing: Joint, span: bytes(21003..21004) }, Punct { char: '=', spacing: Alone, span: bytes(21004..21005) }, Ident { sym: Some, span: bytes(21006..21010) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: i, span: bytes(21011..21012) }], span: bytes(21010..21013) }], span: bytes(20982..21014) }, Punct { char: ';', spacing: Alone, span: bytes(21014..21015) }], span: bytes(20863..21029) }], span: bytes(20788..21039) }, Ident { sym: None, span: bytes(21049..21053) }], span: bytes(20327..21059) }) }), delimiter: Some(Nothing) }, Delimited<syncdoc_core::parse::ModuleItem, unsynn::fundamental::Nothing> { value: Function(FnSig { attributes: Some(Repeats<1, 18446744073709551615, syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing>([Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: doc, span: bytes(21065..21120) }, Punct { char: '=', spacing: Alone, span: bytes(21065..21120) }, Literal { lit: " Finds the next section at the same hierarchy level.", span: bytes(21065..21120) }], span: bytes(21065..21120) }) }, delimiter: Some(Nothing) }, Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: must_use, span: bytes(21127..21135) }], span: bytes(21126..21136) }) }, delimiter: Some(Nothing) }])), visibility: Some(Public(KPub(Cached<proc_macro2::Ident> { value: Ident { sym: pub, span: bytes(21141..21144) }, string: "pub" }))), const_kw: None, async_kw: None, unsafe_kw: None, extern_kw: None, _fn: KFn(Cached<proc_macro2::Ident> { value: Ident { sym: fn, span: bytes(21145..21147) }, string: "fn" }), name: Ident { sym: navigate_to_next_sibling, span: bytes(21148..21172) }, generics: None, params: ParenthesisGroupContaining < core::option::Option<unsynn::container::DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>>>(Some(DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>([Delimited<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>> { value: SelfParam(Ref(Cons<unsynn::operator::Operator<'&'>, syncdoc_core::parse::KSelf> { first: Operator<'&'>, second: KSelf(Cached<proc_macro2::Ident> { value: Ident { sym: self, span: bytes(21174..21178) }, string: "self" }) })), delimiter: None }]))), return_type: Some(ReturnTypeFn { _arrow: Operator<'->'>, return_type: Repeats<1, 18446744073709551615, unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing>([Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::group::BraceGroup>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Ident { sym: Option, span: bytes(21183..21189) })) }, delimiter: Some(Nothing) }, Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::group::BraceGroup>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>> { first: Operator<'<'>, second: [Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::operator::Operator<'>'>>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Ident { sym: usize, span: bytes(21190..21195) })) }], third: Operator<'>'> })) }, delimiter: Some(Nothing) }]) }), where_clause: None, body: BraceGroup(Group { delimiter: Brace, stream: TokenStream [Ident { sym: let, span: bytes(21207..21210) }, Ident { sym: section_idx, span: bytes(21211..21222) }, Punct { char: '=', spacing: Alone, span: bytes(21223..21224) }, Ident { sym: self, span: bytes(21225..21229) }, Punct { char: '.', spacing: Alone, span: bytes(21229..21230) }, Ident { sym: get_current_section_index, span: bytes(21230..21255) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(21255..21257) }, Punct { char: '?', spacing: Joint, span: bytes(21257..21258) }, Punct { char: ';', spacing: Alone, span: bytes(21258..21259) }, Ident { sym: let, span: bytes(21268..21271) }, Ident { sym: current_level, span: bytes(21272..21285) }, Punct { char: '=', spacing: Alone, span: bytes(21286..21287) }, Ident { sym: self, span: bytes(21288..21292) }, Punct { char: '.', spacing: Alone, span: bytes(21292..21293) }, Ident { sym: sections, span: bytes(21293..21301) }, Group { delimiter: Bracket, stream: TokenStream [Ident { sym: section_idx, span: bytes(21302..21313) }], span: bytes(21301..21314) }, Punct { char: '.', spacing: Alone, span: bytes(21314..21315) }, Ident { sym: level, span: bytes(21315..21320) }, Punct { char: ';', spacing: Alone, span: bytes(21320..21321) }, Ident { sym: for, span: bytes(21331..21334) }, Ident { sym: i, span: bytes(21335..21336) }, Ident { sym: in, span: bytes(21337..21339) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: section_idx, span: bytes(21341..21352) }, Punct { char: '+', spacing: Alone, span: bytes(21353..21354) }, Literal { lit: 1, span: bytes(21355..21356) }], span: bytes(21340..21357) }, Punct { char: '.', spacing: Joint, span: bytes(21357..21358) }, Punct { char: '.', spacing: Alone, span: bytes(21358..21359) }, Ident { sym: self, span: bytes(21359..21363) }, Punct { char: '.', spacing: Alone, span: bytes(21363..21364) }, Ident { sym: sections, span: bytes(21364..21372) }, Punct { char: '.', spacing: Alone, span: bytes(21372..21373) }, Ident { sym: len, span: bytes(21373..21376) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(21376..21378) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: if, span: bytes(21393..21395) }, Ident { sym: self, span: bytes(21396..21400) }, Punct { char: '.', spacing: Alone, span: bytes(21400..21401) }, Ident { sym: sections, span: bytes(21401..21409) }, Group { delimiter: Bracket, stream: TokenStream [Ident { sym: i, span: bytes(21410..21411) }], span: bytes(21409..21412) }, Punct { char: '.', spacing: Alone, span: bytes(21412..21413) }, Ident { sym: level, span: bytes(21413..21418) }, Punct { char: '=', spacing: Joint, span: bytes(21419..21420) }, Punct { char: '=', spacing: Alone, span: bytes(21420..21421) }, Ident { sym: current_level, span: bytes(21422..21435) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: return, span: bytes(21454..21460) }, Ident { sym: self, span: bytes(21461..21465) }, Punct { char: '.', spacing: Alone, span: bytes(21486..21487) }, Ident { sym: tree_nodes, span: bytes(21487..21497) }, Punct { char: '.', spacing: Alone, span: bytes(21518..21519) }, Ident { sym: iter, span: bytes(21519..21523) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(21523..21525) }, Punct { char: '.', spacing: Alone, span: bytes(21546..21547) }, Ident { sym: position, span: bytes(21547..21555) }, Group { delimiter: Parenthesis, stream: TokenStream [Punct { char: '|', spacing: Alone, span: bytes(21556..21557) }, Ident { sym: n, span: bytes(21557..21558) }, Punct { char: '|', spacing: Alone, span: bytes(21558..21559) }, Ident { sym: n, span: bytes(21560..21561) }, Punct { char: '.', spacing: Alone, span: bytes(21561..21562) }, Ident { sym: section_index, span: bytes(21562..21575) }, Punct { char: '=', spacing: Joint, span: bytes(21576..21577) }, Punct { char: '=', spacing: Alone, span: bytes(21577..21578) }, Ident { sym: Some, span: bytes(21579..21583) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: i, span: bytes(21584..21585) }], span: bytes(21583..21586) }], span: bytes(21555..21587) }, Punct { char: ';', spacing: Alone, span: bytes(21587..21588) }], span: bytes(21436..21602) }, Ident { sym: if, span: bytes(21615..21617) }, Ident { sym: self, span: bytes(21618..21622) }, Punct { char: '.', spacing: Alone, span: bytes(21622..21623) }, Ident { sym: sections, span: bytes(21623..21631) }, Group { delimiter: Bracket, stream: TokenStream [Ident { sym: i, span: bytes(21632..21633) }], span: bytes(21631..21634) }, Punct { char: '.', spacing: Alone, span: bytes(21634..21635) }, Ident { sym: level, span: bytes(21635..21640) }, Punct { char: '<', spacing: Alone, span: bytes(21641..21642) }, Ident { sym: current_level, span: bytes(21643..21656) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: break, span: bytes(21675..21680) }, Punct { char: ';', spacing: Alone, span: bytes(21680..21681) }], span: bytes(21657..21695) }], span: bytes(21379..21705) }, Ident { sym: None, span: bytes(21715..21719) }], span: bytes(21197..21725) }) }), delimiter: Some(Nothing) }, Delimited<syncdoc_core::parse::ModuleItem, unsynn::fundamental::Nothing> { value: Function(FnSig { attributes: Some(Repeats<1, 18446744073709551615, syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing>([Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: doc, span: bytes(21731..21790) }, Punct { char: '=', spacing: Alone, span: bytes(21731..21790) }, Literal { lit: " Finds the previous section at the same hierarchy level.", span: bytes(21731..21790) }], span: bytes(21731..21790) }) }, delimiter: Some(Nothing) }, Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: must_use, span: bytes(21797..21805) }], span: bytes(21796..21806) }) }, delimiter: Some(Nothing) }])), visibility: Some(Public(KPub(Cached<proc_macro2::Ident> { value: Ident { sym: pub, span: bytes(21811..21814) }, string: "pub" }))), const_kw: None, async_kw: None, unsafe_kw: None, extern_kw: None, _fn: KFn(Cached<proc_macro2::Ident> { value: Ident { sym: fn, span: bytes(21815..21817) }, string: "fn" }), name: Ident { sym: navigate_to_prev_sibling, span: bytes(21818..21842) }, generics: None, params: ParenthesisGroupContaining < core::option::Option<unsynn::container::DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>>>(Some(DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>([Delimited<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>> { value: SelfParam(Ref(Cons<unsynn::operator::Operator<'&'>, syncdoc_core::parse::KSelf> { first: Operator<'&'>, second: KSelf(Cached<proc_macro2::Ident> { value: Ident { sym: self, span: bytes(21844..21848) }, string: "self" }) })), delimiter: None }]))), return_type: Some(ReturnTypeFn { _arrow: Operator<'->'>, return_type: Repeats<1, 18446744073709551615, unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing>([Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::group::BraceGroup>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Ident { sym: Option, span: bytes(21853..21859) })) }, delimiter: Some(Nothing) }, Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::group::BraceGroup>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>> { first: Operator<'<'>, second: [Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::operator::Operator<'>'>>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Ident { sym: usize, span: bytes(21860..21865) })) }], third: Operator<'>'> })) }, delimiter: Some(Nothing) }]) }), where_clause: None, body: BraceGroup(Group { delimiter: Brace, stream: TokenStream [Ident { sym: let, span: bytes(21877..21880) }, Ident { sym: section_idx, span: bytes(21881..21892) }, Punct { char: '=', spacing: Alone, span: bytes(21893..21894) }, Ident { sym: self, span: bytes(21895..21899) }, Punct { char: '.', spacing: Alone, span: bytes(21899..21900) }, Ident { sym: get_current_section_index, span: bytes(21900..21925) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(21925..21927) }, Punct { char: '?', spacing: Joint, span: bytes(21927..21928) }, Punct { char: ';', spacing: Alone, span: bytes(21928..21929) }, Ident { sym: let, span: bytes(21938..21941) }, Ident { sym: current_level, span: bytes(21942..21955) }, Punct { char: '=', spacing: Alone, span: bytes(21956..21957) }, Ident { sym: self, span: bytes(21958..21962) }, Punct { char: '.', spacing: Alone, span: bytes(21962..21963) }, Ident { sym: sections, span: bytes(21963..21971) }, Group { delimiter: Bracket, stream: TokenStream [Ident { sym: section_idx, span: bytes(21972..21983) }], span: bytes(21971..21984) }, Punct { char: '.', spacing: Alone, span: bytes(21984..21985) }, Ident { sym: level, span: bytes(21985..21990) }, Punct { char: ';', spacing: Alone, span: bytes(21990..21991) }, Ident { sym: for, span: bytes(22001..22004) }, Ident { sym: i, span: bytes(22005..22006) }, Ident { sym: in, span: bytes(22007..22009) }, Group { delimiter: Parenthesis, stream: TokenStream [Literal { lit: 0, span: bytes(22011..22012) }, Punct { char: '.', spacing: Joint, span: bytes(22012..22013) }, Punct { char: '.', spacing: Alone, span: bytes(22013..22014) }, Ident { sym: section_idx, span: bytes(22014..22025) }], span: bytes(22010..22026) }, Punct { char: '.', spacing: Alone, span: bytes(22026..22027) }, Ident { sym: rev, span: bytes(22027..22030) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(22030..22032) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: if, span: bytes(22047..22049) }, Ident { sym: self, span: bytes(22050..22054) }, Punct { char: '.', spacing: Alone, span: bytes(22054..22055) }, Ident { sym: sections, span: bytes(22055..22063) }, Group { delimiter: Bracket, stream: TokenStream [Ident { sym: i, span: bytes(22064..22065) }], span: bytes(22063..22066) }, Punct { char: '.', spacing: Alone, span: bytes(22066..22067) }, Ident { sym: level, span: bytes(22067..22072) }, Punct { char: '=', spacing: Joint, span: bytes(22073..22074) }, Punct { char: '=', spacing: Alone, span: bytes(22074..22075) }, Ident { sym: current_level, span: bytes(22076..22089) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: return, span: bytes(22108..22114) }, Ident { sym: self, span: bytes(22115..22119) }, Punct { char: '.', spacing: Alone, span: bytes(22140..22141) }, Ident { sym: tree_nodes, span: bytes(22141..22151) }, Punct { char: '.', spacing: Alone, span: bytes(22172..22173) }, Ident { sym: iter, span: bytes(22173..22177) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(22177..22179) }, Punct { char: '.', spacing: Alone, span: bytes(22200..22201) }, Ident { sym: position, span: bytes(22201..22209) }, Group { delimiter: Parenthesis, stream: TokenStream [Punct { char: '|', spacing: Alone, span: bytes(22210..22211) }, Ident { sym: n, span: bytes(22211..22212) }, Punct { char: '|', spacing: Alone, span: bytes(22212..22213) }, Ident { sym: n, span: bytes(22214..22215) }, Punct { char: '.', spacing: Alone, span: bytes(22215..22216) }, Ident { sym: section_index, span: bytes(22216..22229) }, Punct { char: '=', spacing: Joint, span: bytes(22230..22231) }, Punct { char: '=', spacing: Alone, span: bytes(22231..22232) }, Ident { sym: Some, span: bytes(22233..22237) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: i, span: bytes(22238..22239) }], span: bytes(22237..22240) }], span: bytes(22209..22241) }, Punct { char: ';', spacing: Alone, span: bytes(22241..22242) }], span: bytes(22090..22256) }, Ident { sym: if, span: bytes(22269..22271) }, Ident { sym: self, span: bytes(22272..22276) }, Punct { char: '.', spacing: Alone, span: bytes(22276..22277) }, Ident { sym: sections, span: bytes(22277..22285) }, Group { delimiter: Bracket, stream: TokenStream [Ident { sym: i, span: bytes(22286..22287) }], span: bytes(22285..22288) }, Punct { char: '.', spacing: Alone, span: bytes(22288..22289) }, Ident { sym: level, span: bytes(22289..22294) }, Punct { char: '<', spacing: Alone, span: bytes(22295..22296) }, Ident { sym: current_level, span: bytes(22297..22310) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: break, span: bytes(22329..22334) }, Punct { char: ';', spacing: Alone, span: bytes(22334..22335) }], span: bytes(22311..22349) }], span: bytes(22033..22359) }, Ident { sym: None, span: bytes(22369..22373) }], span: bytes(21867..22379) }) }), delimiter: Some(Nothing) }, Delimited<syncdoc_core::parse::ModuleItem, unsynn::fundamental::Nothing> { value: Function(FnSig { attributes: Some(Repeats<1, 18446744073709551615, syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing>([Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: doc, span: bytes(22385..22423) }, Punct { char: '=', spacing: Alone, span: bytes(22385..22423) }, Literal { lit: " Jumps to the first navigable node.", span: bytes(22385..22423) }], span: bytes(22385..22423) }) }, delimiter: Some(Nothing) }, Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: must_use, span: bytes(22430..22438) }], span: bytes(22429..22439) }) }, delimiter: Some(Nothing) }])), visibility: Some(Public(KPub(Cached<proc_macro2::Ident> { value: Ident { sym: pub, span: bytes(22444..22447) }, string: "pub" }))), const_kw: None, async_kw: None, unsafe_kw: None, extern_kw: None, _fn: KFn(Cached<proc_macro2::Ident> { value: Ident { sym: fn, span: bytes(22448..22450) }, string: "fn" }), name: Ident { sym: navigate_to_first, span: bytes(22451..22468) }, generics: None, params: ParenthesisGroupContaining < core::option::Option<unsynn::container::DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>>>(Some(DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>([Delimited<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>> { value: SelfParam(Ref(Cons<unsynn::operator::Operator<'&'>, syncdoc_core::parse::KSelf> { first: Operator<'&'>, second: KSelf(Cached<proc_macro2::Ident> { value: Ident { sym: self, span: bytes(22470..22474) }, string: "self" }) })), delimiter: None }]))), return_type: Some(ReturnTypeFn { _arrow: Operator<'->'>, return_type: Repeats<1, 18446744073709551615, unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing>([Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::group::BraceGroup>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Ident { sym: Option, span: bytes(22479..22485) })) }, delimiter: Some(Nothing) }, Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::group::BraceGroup>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>> { first: Operator<'<'>, second: [Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::operator::Operator<'>'>>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Ident { sym: usize, span: bytes(22486..22491) })) }], third: Operator<'>'> })) }, delimiter: Some(Nothing) }]) }), where_clause: None, body: BraceGroup(Group { delimiter: Brace, stream: TokenStream [Ident { sym: self, span: bytes(22503..22507) }, Punct { char: '.', spacing: Alone, span: bytes(22507..22508) }, Ident { sym: tree_nodes, span: bytes(22508..22518) }, Punct { char: '.', spacing: Alone, span: bytes(22518..22519) }, Ident { sym: iter, span: bytes(22519..22523) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(22523..22525) }, Punct { char: '.', spacing: Alone, span: bytes(22525..22526) }, Ident { sym: position, span: bytes(22526..22534) }, Group { delimiter: Parenthesis, stream: TokenStream [Punct { char: '|', spacing: Alone, span: bytes(22535..22536) }, Ident { sym: n, span: bytes(22536..22537) }, Punct { char: '|', spacing: Alone, span: bytes(22537..22538) }, Ident { sym: n, span: bytes(22539..22540) }, Punct { char: '.', spacing: Alone, span: bytes(22540..22541) }, Ident { sym: navigable, span: bytes(22541..22550) }], span: bytes(22534..22551) }], span: bytes(22493..22557) }) }), delimiter: Some(Nothing) }, Delimited<syncdoc_core::parse::ModuleItem, unsynn::fundamental::Nothing> { value: Function(FnSig { attributes: Some(Repeats<1, 18446744073709551615, syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing>([Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: doc, span: bytes(22563..22600) }, Punct { char: '=', spacing: Alone, span: bytes(22563..22600) }, Literal { lit: " Jumps to the last navigable node.", span: bytes(22563..22600) }], span: bytes(22563..22600) }) }, delimiter: Some(Nothing) }, Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: must_use, span: bytes(22607..22615) }], span: bytes(22606..22616) }) }, delimiter: Some(Nothing) }])), visibility: Some(Public(KPub(Cached<proc_macro2::Ident> { value: Ident { sym: pub, span: bytes(22621..22624) }, string: "pub" }))), const_kw: None, async_kw: None, unsafe_kw: None, extern_kw: None, _fn: KFn(Cached<proc_macro2::Ident> { value: Ident { sym: fn, span: bytes(22625..22627) }, string: "fn" }), name: Ident { sym: navigate_to_last, span: bytes(22628..22644) }, generics: None, params: ParenthesisGroupContaining < core::option::Option<unsynn::container::DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>>>(Some(DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>([Delimited<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>> { value: SelfParam(Ref(Cons<unsynn::operator::Operator<'&'>, syncdoc_core::parse::KSelf> { first: Operator<'&'>, second: KSelf(Cached<proc_macro2::Ident> { value: Ident { sym: self, span: bytes(22646..22650) }, string: "self" }) })), delimiter: None }]))), return_type: Some(ReturnTypeFn { _arrow: Operator<'->'>, return_type: Repeats<1, 18446744073709551615, unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing>([Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::group::BraceGroup>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Ident { sym: Option, span: bytes(22655..22661) })) }, delimiter: Some(Nothing) }, Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::group::BraceGroup>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>> { first: Operator<'<'>, second: [Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::operator::Operator<'>'>>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Ident { sym: usize, span: bytes(22662..22667) })) }], third: Operator<'>'> })) }, delimiter: Some(Nothing) }]) }), where_clause: None, body: BraceGroup(Group { delimiter: Brace, stream: TokenStream [Ident { sym: self, span: bytes(22679..22683) }, Punct { char: '.', spacing: Alone, span: bytes(22683..22684) }, Ident { sym: tree_nodes, span: bytes(22684..22694) }, Punct { char: '.', spacing: Alone, span: bytes(22694..22695) }, Ident { sym: iter, span: bytes(22695..22699) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(22699..22701) }, Punct { char: '.', spacing: Alone, span: bytes(22701..22702) }, Ident { sym: rposition, span: bytes(22702..22711) }, Group { delimiter: Parenthesis, stream: TokenStream [Punct { char: '|', spacing: Alone, span: bytes(22712..22713) }, Ident { sym: n, span: bytes(22713..22714) }, Punct { char: '|', spacing: Alone, span: bytes(22714..22715) }, Ident { sym: n, span: bytes(22716..22717) }, Punct { char: '.', spacing: Alone, span: bytes(22717..22718) }, Ident { sym: navigable, span: bytes(22718..22727) }], span: bytes(22711..22728) }], span: bytes(22669..22734) }) }), delimiter: Some(Nothing) }, Delimited<syncdoc_core::parse::ModuleItem, unsynn::fundamental::Nothing> { value: Function(FnSig { attributes: Some(Repeats<1, 18446744073709551615, syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing>([Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: doc, span: bytes(22740..22796) }, Punct { char: '=', spacing: Alone, span: bytes(22740..22796) }, Literal { lit: " Finds the first section at the same hierarchy level.", span: bytes(22740..22796) }], span: bytes(22740..22796) }) }, delimiter: Some(Nothing) }, Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: must_use, span: bytes(22803..22811) }], span: bytes(22802..22812) }) }, delimiter: Some(Nothing) }])), visibility: Some(Public(KPub(Cached<proc_macro2::Ident> { value: Ident { sym: pub, span: bytes(22817..22820) }, string: "pub" }))), const_kw: None, async_kw: None, unsafe_kw: None, extern_kw: None, _fn: KFn(Cached<proc_macro2::Ident> { value: Ident { sym: fn, span: bytes(22821..22823) }, string: "fn" }), name: Ident { sym: navigate_to_first_at_level, span: bytes(22824..22850) }, generics: None, params: ParenthesisGroupContaining < core::option::Option<unsynn::container::DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>>>(Some(DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>([Delimited<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>> { value: SelfParam(Ref(Cons<unsynn::operator::Operator<'&'>, syncdoc_core::parse::KSelf> { first: Operator<'&'>, second: KSelf(Cached<proc_macro2::Ident> { value: Ident { sym: self, span: bytes(22852..22856) }, string: "self" }) })), delimiter: None }]))), return_type: Some(ReturnTypeFn { _arrow: Operator<'->'>, return_type: Repeats<1, 18446744073709551615, unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing>([Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::group::BraceGroup>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Ident { sym: Option, span: bytes(22861..22867) })) }, delimiter: Some(Nothing) }, Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::group::BraceGroup>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>> { first: Operator<'<'>, second: [Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::operator::Operator<'>'>>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Ident { sym: usize, span: bytes(22868..22873) })) }], third: Operator<'>'> })) }, delimiter: Some(Nothing) }]) }), where_clause: None, body: BraceGroup(Group { delimiter: Brace, stream: TokenStream [Ident { sym: let, span: bytes(22885..22888) }, Ident { sym: section_idx, span: bytes(22889..22900) }, Punct { char: '=', spacing: Alone, span: bytes(22901..22902) }, Ident { sym: self, span: bytes(22903..22907) }, Punct { char: '.', spacing: Alone, span: bytes(22907..22908) }, Ident { sym: get_current_section_index, span: bytes(22908..22933) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(22933..22935) }, Punct { char: '?', spacing: Joint, span: bytes(22935..22936) }, Punct { char: ';', spacing: Alone, span: bytes(22936..22937) }, Ident { sym: let, span: bytes(22946..22949) }, Ident { sym: current_level, span: bytes(22950..22963) }, Punct { char: '=', spacing: Alone, span: bytes(22964..22965) }, Ident { sym: self, span: bytes(22966..22970) }, Punct { char: '.', spacing: Alone, span: bytes(22970..22971) }, Ident { sym: sections, span: bytes(22971..22979) }, Group { delimiter: Bracket, stream: TokenStream [Ident { sym: section_idx, span: bytes(22980..22991) }], span: bytes(22979..22992) }, Punct { char: '.', spacing: Alone, span: bytes(22992..22993) }, Ident { sym: level, span: bytes(22993..22998) }, Punct { char: ';', spacing: Alone, span: bytes(22998..22999) }, Ident { sym: for, span: bytes(23009..23012) }, Ident { sym: i, span: bytes(23013..23014) }, Ident { sym: in, span: bytes(23015..23017) }, Literal { lit: 0, span: bytes(23018..23019) }, Punct { char: '.', spacing: Joint, span: bytes(23019..23020) }, Punct { char: '.', spacing: Alone, span: bytes(23020..23021) }, Ident { sym: self, span: bytes(23021..23025) }, Punct { char: '.', spacing: Alone, span: bytes(23025..23026) }, Ident { sym: sections, span: bytes(23026..23034) }, Punct { char: '.', spacing: Alone, span: bytes(23034..23035) }, Ident { sym: len, span: bytes(23035..23038) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(23038..23040) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: if, span: bytes(23055..23057) }, Ident { sym: self, span: bytes(23058..23062) }, Punct { char: '.', spacing: Alone, span: bytes(23062..23063) }, Ident { sym: sections, span: bytes(23063..23071) }, Group { delimiter: Bracket, stream: TokenStream [Ident { sym: i, span: bytes(23072..23073) }], span: bytes(23071..23074) }, Punct { char: '.', spacing: Alone, span: bytes(23074..23075) }, Ident { sym: level, span: bytes(23075..23080) }, Punct { char: '=', spacing: Joint, span: bytes(23081..23082) }, Punct { char: '=', spacing: Alone, span: bytes(23082..23083) }, Ident { sym: current_level, span: bytes(23084..23097) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: return, span: bytes(23116..23122) }, Ident { sym: self, span: bytes(23123..23127) }, Punct { char: '.', spacing: Alone, span: bytes(23148..23149) }, Ident { sym: tree_nodes, span: bytes(23149..23159) }, Punct { char: '.', spacing: Alone, span: bytes(23180..23181) }, Ident { sym: iter, span: bytes(23181..23185) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(23185..23187) }, Punct { char: '.', spacing: Alone, span: bytes(23208..23209) }, Ident { sym: position, span: bytes(23209..23217) }, Group { delimiter: Parenthesis, stream: TokenStream [Punct { char: '|', spacing: Alone, span: bytes(23218..23219) }, Ident { sym: n, span: bytes(23219..23220) }, Punct { char: '|', spacing: Alone, span: bytes(23220..23221) }, Ident { sym: n, span: bytes(23222..23223) }, Punct { char: '.', spacing: Alone, span: bytes(23223..23224) }, Ident { sym: section_index, span: bytes(23224..23237) }, Punct { char: '=', spacing: Joint, span: bytes(23238..23239) }, Punct { char: '=', spacing: Alone, span: bytes(23239..23240) }, Ident { sym: Some, span: bytes(23241..23245) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: i, span: bytes(23246..23247) }], span: bytes(23245..23248) }], span: bytes(23217..23249) }, Punct { char: ';', spacing: Alone, span: bytes(23249..23250) }], span: bytes(23098..23264) }], span: bytes(23041..23274) }, Ident { sym: None, span: bytes(23284..23288) }], span: bytes(22875..23294) }) }), delimiter: Some(Nothing) }, Delimited<syncdoc_core::parse::ModuleItem, unsynn::fundamental::Nothing> { value: Function(FnSig { attributes: Some(Repeats<1, 18446744073709551615, syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing>([Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: doc, span: bytes(23300..23355) }, Punct { char: '=', spacing: Alone, span: bytes(23300..23355) }, Literal { lit: " Finds the last section at the same hierarchy level.", span: bytes(23300..23355) }], span: bytes(23300..23355) }) }, delimiter: Some(Nothing) }, Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: must_use, span: bytes(23362..23370) }], span: bytes(23361..23371) }) }, delimiter: Some(Nothing) }])), visibility: Some(Public(KPub(Cached<proc_macro2::Ident> { value: Ident { sym: pub, span: bytes(23376..23379) }, string: "pub" }))), const_kw: None, async_kw: None, unsafe_kw: None, extern_kw: None, _fn: KFn(Cached<proc_macro2::Ident> { value: Ident { sym: fn, span: bytes(23380..23382) }, string: "fn" }), name: Ident { sym: navigate_to_last_at_level, span: bytes(23383..23408) }, generics: None, params: ParenthesisGroupContaining < core::option::Option<unsynn::container::DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>>>(Some(DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>([Delimited<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>> { value: SelfParam(Ref(Cons<unsynn::operator::Operator<'&'>, syncdoc_core::parse::KSelf> { first: Operator<'&'>, second: KSelf(Cached<proc_macro2::Ident> { value: Ident { sym: self, span: bytes(23410..23414) }, string: "self" }) })), delimiter: None }]))), return_type: Some(ReturnTypeFn { _arrow: Operator<'->'>, return_type: Repeats<1, 18446744073709551615, unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing>([Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::group::BraceGroup>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Ident { sym: Option, span: bytes(23419..23425) })) }, delimiter: Some(Nothing) }, Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::group::BraceGroup>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>> { first: Operator<'<'>, second: [Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::operator::Operator<'>'>>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Ident { sym: usize, span: bytes(23426..23431) })) }], third: Operator<'>'> })) }, delimiter: Some(Nothing) }]) }), where_clause: None, body: BraceGroup(Group { delimiter: Brace, stream: TokenStream [Ident { sym: let, span: bytes(23443..23446) }, Ident { sym: section_idx, span: bytes(23447..23458) }, Punct { char: '=', spacing: Alone, span: bytes(23459..23460) }, Ident { sym: self, span: bytes(23461..23465) }, Punct { char: '.', spacing: Alone, span: bytes(23465..23466) }, Ident { sym: get_current_section_index, span: bytes(23466..23491) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(23491..23493) }, Punct { char: '?', spacing: Joint, span: bytes(23493..23494) }, Punct { char: ';', spacing: Alone, span: bytes(23494..23495) }, Ident { sym: let, span: bytes(23504..23507) }, Ident { sym: current_level, span: bytes(23508..23521) }, Punct { char: '=', spacing: Alone, span: bytes(23522..23523) }, Ident { sym: self, span: bytes(23524..23528) }, Punct { char: '.', spacing: Alone, span: bytes(23528..23529) }, Ident { sym: sections, span: bytes(23529..23537) }, Group { delimiter: Bracket, stream: TokenStream [Ident { sym: section_idx, span: bytes(23538..23549) }], span: bytes(23537..23550) }, Punct { char: '.', spacing: Alone, span: bytes(23550..23551) }, Ident { sym: level, span: bytes(23551..23556) }, Punct { char: ';', spacing: Alone, span: bytes(23556..23557) }, Ident { sym: for, span: bytes(23567..23570) }, Ident { sym: i, span: bytes(23571..23572) }, Ident { sym: in, span: bytes(23573..23575) }, Group { delimiter: Parenthesis, stream: TokenStream [Literal { lit: 0, span: bytes(23577..23578) }, Punct { char: '.', spacing: Joint, span: bytes(23578..23579) }, Punct { char: '.', spacing: Alone, span: bytes(23579..23580) }, Ident { sym: self, span: bytes(23580..23584) }, Punct { char: '.', spacing: Alone, span: bytes(23584..23585) }, Ident { sym: sections, span: bytes(23585..23593) }, Punct { char: '.', spacing: Alone, span: bytes(23593..23594) }, Ident { sym: len, span: bytes(23594..23597) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(23597..23599) }], span: bytes(23576..23600) }, Punct { char: '.', spacing: Alone, span: bytes(23600..23601) }, Ident { sym: rev, span: bytes(23601..23604) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(23604..23606) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: if, span: bytes(23621..23623) }, Ident { sym: self, span: bytes(23624..23628) }, Punct { char: '.', spacing: Alone, span: bytes(23628..23629) }, Ident { sym: sections, span: bytes(23629..23637) }, Group { delimiter: Bracket, stream: TokenStream [Ident { sym: i, span: bytes(23638..23639) }], span: bytes(23637..23640) }, Punct { char: '.', spacing: Alone, span: bytes(23640..23641) }, Ident { sym: level, span: bytes(23641..23646) }, Punct { char: '=', spacing: Joint, span: bytes(23647..23648) }, Punct { char: '=', spacing: Alone, span: bytes(23648..23649) }, Ident { sym: current_level, span: bytes(23650..23663) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: return, span: bytes(23682..23688) }, Ident { sym: self, span: bytes(23689..23693) }, Punct { char: '.', spacing: Alone, span: bytes(23714..23715) }, Ident { sym: tree_nodes, span: bytes(23715..23725) }, Punct { char: '.', spacing: Alone, span: bytes(23746..23747) }, Ident { sym: iter, span: bytes(23747..23751) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(23751..23753) }, Punct { char: '.', spacing: Alone, span: bytes(23774..23775) }, Ident { sym: position, span: bytes(23775..23783) }, Group { delimiter: Parenthesis, stream: TokenStream [Punct { char: '|', spacing: Alone, span: bytes(23784..23785) }, Ident { sym: n, span: bytes(23785..23786) }, Punct { char: '|', spacing: Alone, span: bytes(23786..23787) }, Ident { sym: n, span: bytes(23788..23789) }, Punct { char: '.', spacing: Alone, span: bytes(23789..23790) }, Ident { sym: section_index, span: bytes(23790..23803) }, Punct { char: '=', spacing: Joint, span: bytes(23804..23805) }, Punct { char: '=', spacing: Alone, span: bytes(23805..23806) }, Ident { sym: Some, span: bytes(23807..23811) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: i, span: bytes(23812..23813) }], span: bytes(23811..23814) }], span: bytes(23783..23815) }, Punct { char: ';', spacing: Alone, span: bytes(23815..23816) }], span: bytes(23664..23830) }], span: bytes(23607..23840) }, Ident { sym: None, span: bytes(23850..23854) }], span: bytes(23433..23860) }) }), delimiter: Some(Nothing) }, Delimited<syncdoc_core::parse::ModuleItem, unsynn::fundamental::Nothing> { value: Function(FnSig { attributes: Some(Repeats<1, 18446744073709551615, syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing>([Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: doc, span: bytes(23866..23930) }, Punct { char: '=', spacing: Alone, span: bytes(23866..23930) }, Literal { lit: " Calculates indentation width based on section nesting level.", span: bytes(23866..23930) }], span: bytes(23866..23930) }) }, delimiter: Some(Nothing) }, Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: must_use, span: bytes(23937..23945) }], span: bytes(23936..23946) }) }, delimiter: Some(Nothing) }])), visibility: Some(Public(KPub(Cached<proc_macro2::Ident> { value: Ident { sym: pub, span: bytes(23951..23954) }, string: "pub" }))), const_kw: None, async_kw: None, unsafe_kw: None, extern_kw: None, _fn: KFn(Cached<proc_macro2::Ident> { value: Ident { sym: fn, span: bytes(23955..23957) }, string: "fn" }), name: Ident { sym: get_indent, span: bytes(23958..23968) }, generics: None, params: ParenthesisGroupContaining < core::option::Option<unsynn::container::DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>>>(Some(DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>([Delimited<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>> { value: SelfParam(Ref(Cons<unsynn::operator::Operator<'&'>, syncdoc_core::parse::KSelf> { first: Operator<'&'>, second: KSelf(Cached<proc_macro2::Ident> { value: Ident { sym: self, span: bytes(23970..23974) }, string: "self" }) })), delimiter: None }]))), return_type: Some(ReturnTypeFn { _arrow: Operator<'->'>, return_type: Repeats<1, 18446744073709551615, unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing>([Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::group::BraceGroup>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Ident { sym: usize, span: bytes(23979..23984) })) }, delimiter: Some(Nothing) }]) }), where_clause: None, body: BraceGroup(Group { delimiter: Brace, stream: TokenStream [Ident { sym: if, span: bytes(23995..23997) }, Ident { sym: let, span: bytes(23998..24001) }, Ident { sym: Some, span: bytes(24002..24006) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: section, span: bytes(24007..24014) }], span: bytes(24006..24015) }, Punct { char: '=', spacing: Alone, span: bytes(24016..24017) }, Ident { sym: self, span: bytes(24018..24022) }, Punct { char: '.', spacing: Alone, span: bytes(24022..24023) }, Ident { sym: get_current_section, span: bytes(24023..24042) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(24042..24044) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: section, span: bytes(24059..24066) }, Punct { char: '.', spacing: Alone, span: bytes(24066..24067) }, Ident { sym: level, span: bytes(24067..24072) }, Punct { char: '*', spacing: Alone, span: bytes(24073..24074) }, Literal { lit: 2, span: bytes(24075..24076) }], span: bytes(24045..24086) }, Ident { sym: else, span: bytes(24087..24091) }, Group { delimiter: Brace, stream: TokenStream [Literal { lit: 0, span: bytes(24106..24107) }], span: bytes(24092..24117) }], span: bytes(23985..24123) }) }), delimiter: Some(Nothing) }, Delimited<syncdoc_core::parse::ModuleItem, unsynn::fundamental::Nothing> { value: Function(FnSig { attributes: Some(Repeats<1, 18446744073709551615, syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing>([Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: doc, span: bytes(24129..24202) }, Punct { char: '=', spacing: Alone, span: bytes(24129..24202) }, Literal { lit: " Determines available width for text after accounting for indentation.", span: bytes(24129..24202) }], span: bytes(24129..24202) }) }, delimiter: Some(Nothing) }, Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: must_use, span: bytes(24209..24217) }], span: bytes(24208..24218) }) }, delimiter: Some(Nothing) }])), visibility: Some(Public(KPub(Cached<proc_macro2::Ident> { value: Ident { sym: pub, span: bytes(24223..24226) }, string: "pub" }))), const_kw: None, async_kw: None, unsafe_kw: None, extern_kw: None, _fn: KFn(Cached<proc_macro2::Ident> { value: Ident { sym: fn, span: bytes(24227..24229) }, string: "fn" }), name: Ident { sym: get_max_line_width, span: bytes(24230..24248) }, generics: None, params: ParenthesisGroupContaining < core::option::Option<unsynn::container::DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>>>(Some(DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>([Delimited<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>> { value: SelfParam(Ref(Cons<unsynn::operator::Operator<'&'>, syncdoc_core::parse::KSelf> { first: Operator<'&'>, second: KSelf(Cached<proc_macro2::Ident> { value: Ident { sym: self, span: bytes(24250..24254) }, string: "self" }) })), delimiter: None }]))), return_type: Some(ReturnTypeFn { _arrow: Operator<'->'>, return_type: Repeats<1, 18446744073709551615, unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing>([Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::group::BraceGroup>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Ident { sym: usize, span: bytes(24259..24264) })) }, delimiter: Some(Nothing) }]) }), where_clause: None, body: BraceGroup(Group { delimiter: Brace, stream: TokenStream [Ident { sym: let, span: bytes(24275..24278) }, Ident { sym: indent, span: bytes(24279..24285) }, Punct { char: '=', spacing: Alone, span: bytes(24286..24287) }, Ident { sym: self, span: bytes(24288..24292) }, Punct { char: '.', spacing: Alone, span: bytes(24292..24293) }, Ident { sym: get_indent, span: bytes(24293..24303) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(24303..24305) }, Punct { char: ';', spacing: Alone, span: bytes(24305..24306) }, Ident { sym: self, span: bytes(24315..24319) }, Punct { char: '.', spacing: Alone, span: bytes(24319..24320) }, Ident { sym: wrap_width, span: bytes(24320..24330) }, Punct { char: '.', spacing: Alone, span: bytes(24330..24331) }, Ident { sym: saturating_sub, span: bytes(24331..24345) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: indent, span: bytes(24346..24352) }], span: bytes(24345..24353) }], span: bytes(24265..24359) }) }), delimiter: Some(Nothing) }, Delimited<syncdoc_core::parse::ModuleItem, unsynn::fundamental::Nothing> { value: Function(FnSig { attributes: Some(Repeats<1, 18446744073709551615, syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing>([Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: doc, span: bytes(24403..24439) }, Punct { char: '=', spacing: Alone, span: bytes(24403..24439) }, Literal { lit: " Start moving the current section", span: bytes(24403..24439) }], span: bytes(24403..24439) }) }, delimiter: Some(Nothing) }])), visibility: Some(Public(KPub(Cached<proc_macro2::Ident> { value: Ident { sym: pub, span: bytes(24444..24447) }, string: "pub" }))), const_kw: None, async_kw: None, unsafe_kw: None, extern_kw: None, _fn: KFn(Cached<proc_macro2::Ident> { value: Ident { sym: fn, span: bytes(24448..24450) }, string: "fn" }), name: Ident { sym: start_move, span: bytes(24451..24461) }, generics: None, params: ParenthesisGroupContaining < core::option::Option<unsynn::container::DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>>>(Some(DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>([Delimited<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>> { value: SelfParam(RefMut(Cons<unsynn::operator::Operator<'&'>, unsynn::combinator::Cons<syncdoc_core::parse::KMut, syncdoc_core::parse::KSelf>> { first: Operator<'&'>, second: Cons<syncdoc_core::parse::KMut, syncdoc_core::parse::KSelf> { first: KMut(Cached<proc_macro2::Ident> { value: Ident { sym: mut, span: bytes(24463..24466) }, string: "mut" }), second: KSelf(Cached<proc_macro2::Ident> { value: Ident { sym: self, span: bytes(24467..24471) }, string: "self" }) } })), delimiter: None }]))), return_type: None, where_clause: None, body: BraceGroup(Group { delimiter: Brace, stream: TokenStream [Ident { sym: if, span: bytes(24483..24485) }, Ident { sym: let, span: bytes(24486..24489) }, Ident { sym: Some, span: bytes(24490..24494) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: section_idx, span: bytes(24495..24506) }], span: bytes(24494..24507) }, Punct { char: '=', spacing: Alone, span: bytes(24508..24509) }, Ident { sym: self, span: bytes(24510..24514) }, Punct { char: '.', spacing: Alone, span: bytes(24514..24515) }, Ident { sym: get_current_section_index, span: bytes(24515..24540) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(24540..24542) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: self, span: bytes(24557..24561) }, Punct { char: '.', spacing: Alone, span: bytes(24561..24562) }, Ident { sym: moving_section_index, span: bytes(24562..24582) }, Punct { char: '=', spacing: Alone, span: bytes(24583..24584) }, Ident { sym: Some, span: bytes(24585..24589) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: section_idx, span: bytes(24590..24601) }], span: bytes(24589..24602) }, Punct { char: ';', spacing: Alone, span: bytes(24602..24603) }, Ident { sym: self, span: bytes(24616..24620) }, Punct { char: '.', spacing: Alone, span: bytes(24620..24621) }, Ident { sym: move_state, span: bytes(24621..24631) }, Punct { char: '=', spacing: Alone, span: bytes(24632..24633) }, Ident { sym: MoveState, span: bytes(24634..24643) }, Punct { char: ':', spacing: Joint, span: bytes(24643..24644) }, Punct { char: ':', spacing: Alone, span: bytes(24644..24645) }, Ident { sym: Selected, span: bytes(24645..24653) }, Punct { char: ';', spacing: Alone, span: bytes(24653..24654) }], span: bytes(24543..24664) }], span: bytes(24473..24670) }) }), delimiter: Some(Nothing) }, Delimited<syncdoc_core::parse::ModuleItem, unsynn::fundamental::Nothing> { value: Function(FnSig { attributes: Some(Repeats<1, 18446744073709551615, syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing>([Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: doc, span: bytes(24676..24713) }, Punct { char: '=', spacing: Alone, span: bytes(24676..24713) }, Literal { lit: " Cancel the current move operation", span: bytes(24676..24713) }], span: bytes(24676..24713) }) }, delimiter: Some(Nothing) }])), visibility: Some(Public(KPub(Cached<proc_macro2::Ident> { value: Ident { sym: pub, span: bytes(24718..24721) }, string: "pub" }))), const_kw: None, async_kw: None, unsafe_kw: None, extern_kw: None, _fn: KFn(Cached<proc_macro2::Ident> { value: Ident { sym: fn, span: bytes(24722..24724) }, string: "fn" }), name: Ident { sym: cancel_move, span: bytes(24725..24736) }, generics: None, params: ParenthesisGroupContaining < core::option::Option<unsynn::container::DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>>>(Some(DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>([Delimited<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>> { value: SelfParam(RefMut(Cons<unsynn::operator::Operator<'&'>, unsynn::combinator::Cons<syncdoc_core::parse::KMut, syncdoc_core::parse::KSelf>> { first: Operator<'&'>, second: Cons<syncdoc_core::parse::KMut, syncdoc_core::parse::KSelf> { first: KMut(Cached<proc_macro2::Ident> { value: Ident { sym: mut, span: bytes(24738..24741) }, string: "mut" }), second: KSelf(Cached<proc_macro2::Ident> { value: Ident { sym: self, span: bytes(24742..24746) }, string: "self" }) } })), delimiter: None }]))), return_type: None, where_clause: None, body: BraceGroup(Group { delimiter: Brace, stream: TokenStream [Ident { sym: self, span: bytes(24758..24762) }, Punct { char: '.', spacing: Alone, span: bytes(24762..24763) }, Ident { sym: moving_section_index, span: bytes(24763..24783) }, Punct { char: '=', spacing: Alone, span: bytes(24784..24785) }, Ident { sym: None, span: bytes(24786..24790) }, Punct { char: ';', spacing: Alone, span: bytes(24790..24791) }, Ident { sym: self, span: bytes(24800..24804) }, Punct { char: '.', spacing: Alone, span: bytes(24804..24805) }, Ident { sym: move_state, span: bytes(24805..24815) }, Punct { char: '=', spacing: Alone, span: bytes(24816..24817) }, Ident { sym: MoveState, span: bytes(24818..24827) }, Punct { char: ':', spacing: Joint, span: bytes(24827..24828) }, Punct { char: ':', spacing: Alone, span: bytes(24828..24829) }, Ident { sym: None, span: bytes(24829..24833) }, Punct { char: ';', spacing: Alone, span: bytes(24833..24834) }], span: bytes(24748..24840) }) }), delimiter: Some(Nothing) }, Delimited<syncdoc_core::parse::ModuleItem, unsynn::fundamental::Nothing> { value: Function(FnSig { attributes: Some(Repeats<1, 18446744073709551615, syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing>([Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: doc, span: bytes(24846..24889) }, Punct { char: '=', spacing: Alone, span: bytes(24846..24889) }, Literal { lit: " Mark section as moved but not yet saved", span: bytes(24846..24889) }], span: bytes(24846..24889) }) }, delimiter: Some(Nothing) }])), visibility: Some(Public(KPub(Cached<proc_macro2::Ident> { value: Ident { sym: pub, span: bytes(24894..24897) }, string: "pub" }))), const_kw: None, async_kw: None, unsafe_kw: None, extern_kw: None, _fn: KFn(Cached<proc_macro2::Ident> { value: Ident { sym: fn, span: bytes(24898..24900) }, string: "fn" }), name: Ident { sym: mark_moved, span: bytes(24901..24911) }, generics: None, params: ParenthesisGroupContaining < core::option::Option<unsynn::container::DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>>>(Some(DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>([Delimited<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>> { value: SelfParam(RefMut(Cons<unsynn::operator::Operator<'&'>, unsynn::combinator::Cons<syncdoc_core::parse::KMut, syncdoc_core::parse::KSelf>> { first: Operator<'&'>, second: Cons<syncdoc_core::parse::KMut, syncdoc_core::parse::KSelf> { first: KMut(Cached<proc_macro2::Ident> { value: Ident { sym: mut, span: bytes(24913..24916) }, string: "mut" }), second: KSelf(Cached<proc_macro2::Ident> { value: Ident { sym: self, span: bytes(24917..24921) }, string: "self" }) } })), delimiter: None }]))), return_type: None, where_clause: None, body: BraceGroup(Group { delimiter: Brace, stream: TokenStream [Ident { sym: self, span: bytes(24933..24937) }, Punct { char: '.', spacing: Alone, span: bytes(24937..24938) }, Ident { sym: move_state, span: bytes(24938..24948) }, Punct { char: '=', spacing: Alone, span: bytes(24949..24950) }, Ident { sym: MoveState, span: bytes(24951..24960) }, Punct { char: ':', spacing: Joint, span: bytes(24960..24961) }, Punct { char: ':', spacing: Alone, span: bytes(24961..24962) }, Ident { sym: Moved, span: bytes(24962..24967) }, Punct { char: ';', spacing: Alone, span: bytes(24967..24968) }], span: bytes(24923..24974) }) }), delimiter: Some(Nothing) }, Delimited<syncdoc_core::parse::ModuleItem, unsynn::fundamental::Nothing> { value: Function(FnSig { attributes: Some(Repeats<1, 18446744073709551615, syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing>([Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: doc, span: bytes(24980..25015) }, Punct { char: '=', spacing: Alone, span: bytes(24980..25015) }, Literal { lit: " Move section up by one position", span: bytes(24980..25015) }], span: bytes(24980..25015) }) }, delimiter: Some(Nothing) }])), visibility: Some(Public(KPub(Cached<proc_macro2::Ident> { value: Ident { sym: pub, span: bytes(25020..25023) }, string: "pub" }))), const_kw: None, async_kw: None, unsafe_kw: None, extern_kw: None, _fn: KFn(Cached<proc_macro2::Ident> { value: Ident { sym: fn, span: bytes(25024..25026) }, string: "fn" }), name: Ident { sym: move_section_up, span: bytes(25027..25042) }, generics: None, params: ParenthesisGroupContaining < core::option::Option<unsynn::container::DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>>>(Some(DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>([Delimited<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>> { value: SelfParam(RefMut(Cons<unsynn::operator::Operator<'&'>, unsynn::combinator::Cons<syncdoc_core::parse::KMut, syncdoc_core::parse::KSelf>> { first: Operator<'&'>, second: Cons<syncdoc_core::parse::KMut, syncdoc_core::parse::KSelf> { first: KMut(Cached<proc_macro2::Ident> { value: Ident { sym: mut, span: bytes(25044..25047) }, string: "mut" }), second: KSelf(Cached<proc_macro2::Ident> { value: Ident { sym: self, span: bytes(25048..25052) }, string: "self" }) } })), delimiter: None }]))), return_type: Some(ReturnTypeFn { _arrow: Operator<'->'>, return_type: Repeats<1, 18446744073709551615, unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing>([Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::group::BraceGroup>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Ident { sym: bool, span: bytes(25057..25061) })) }, delimiter: Some(Nothing) }]) }), where_clause: None, body: BraceGroup(Group { delimiter: Brace, stream: TokenStream [Ident { sym: if, span: bytes(25072..25074) }, Ident { sym: let, span: bytes(25075..25078) }, Ident { sym: Some, span: bytes(25079..25083) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: moving_idx, span: bytes(25084..25094) }], span: bytes(25083..25095) }, Punct { char: '=', spacing: Alone, span: bytes(25096..25097) }, Ident { sym: self, span: bytes(25098..25102) }, Punct { char: '.', spacing: Alone, span: bytes(25102..25103) }, Ident { sym: moving_section_index, span: bytes(25103..25123) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: if, span: bytes(25138..25140) }, Ident { sym: moving_idx, span: bytes(25141..25151) }, Punct { char: '>', spacing: Alone, span: bytes(25152..25153) }, Literal { lit: 0, span: bytes(25154..25155) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: self, span: bytes(25174..25178) }, Punct { char: '.', spacing: Alone, span: bytes(25178..25179) }, Ident { sym: sections, span: bytes(25179..25187) }, Punct { char: '.', spacing: Alone, span: bytes(25187..25188) }, Ident { sym: swap, span: bytes(25188..25192) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: moving_idx, span: bytes(25193..25203) }, Punct { char: ',', spacing: Alone, span: bytes(25203..25204) }, Ident { sym: moving_idx, span: bytes(25205..25215) }, Punct { char: '-', spacing: Alone, span: bytes(25216..25217) }, Literal { lit: 1, span: bytes(25218..25219) }], span: bytes(25192..25220) }, Punct { char: ';', spacing: Alone, span: bytes(25220..25221) }, Ident { sym: self, span: bytes(25238..25242) }, Punct { char: '.', spacing: Alone, span: bytes(25242..25243) }, Ident { sym: moving_section_index, span: bytes(25243..25263) }, Punct { char: '=', spacing: Alone, span: bytes(25264..25265) }, Ident { sym: Some, span: bytes(25266..25270) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: moving_idx, span: bytes(25271..25281) }, Punct { char: '-', spacing: Alone, span: bytes(25282..25283) }, Literal { lit: 1, span: bytes(25284..25285) }], span: bytes(25270..25286) }, Punct { char: ';', spacing: Alone, span: bytes(25286..25287) }, Ident { sym: self, span: bytes(25304..25308) }, Punct { char: '.', spacing: Alone, span: bytes(25308..25309) }, Ident { sym: rebuild_tree, span: bytes(25309..25321) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(25321..25323) }, Punct { char: ';', spacing: Alone, span: bytes(25323..25324) }, Ident { sym: if, span: bytes(25409..25411) }, Ident { sym: let, span: bytes(25412..25415) }, Ident { sym: Some, span: bytes(25416..25420) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: node_idx, span: bytes(25421..25429) }], span: bytes(25420..25430) }, Punct { char: '=', spacing: Alone, span: bytes(25431..25432) }, Ident { sym: self, span: bytes(25433..25437) }, Punct { char: '.', spacing: Alone, span: bytes(25458..25459) }, Ident { sym: tree_nodes, span: bytes(25459..25469) }, Punct { char: '.', spacing: Alone, span: bytes(25490..25491) }, Ident { sym: iter, span: bytes(25491..25495) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(25495..25497) }, Punct { char: '.', spacing: Alone, span: bytes(25518..25519) }, Ident { sym: position, span: bytes(25519..25527) }, Group { delimiter: Parenthesis, stream: TokenStream [Punct { char: '|', spacing: Alone, span: bytes(25528..25529) }, Ident { sym: n, span: bytes(25529..25530) }, Punct { char: '|', spacing: Alone, span: bytes(25530..25531) }, Ident { sym: n, span: bytes(25532..25533) }, Punct { char: '.', spacing: Alone, span: bytes(25533..25534) }, Ident { sym: section_index, span: bytes(25534..25547) }, Punct { char: '=', spacing: Joint, span: bytes(25548..25549) }, Punct { char: '=', spacing: Alone, span: bytes(25549..25550) }, Ident { sym: Some, span: bytes(25551..25555) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: moving_idx, span: bytes(25556..25566) }, Punct { char: '-', spacing: Alone, span: bytes(25567..25568) }, Literal { lit: 1, span: bytes(25569..25570) }], span: bytes(25555..25571) }], span: bytes(25527..25572) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: self, span: bytes(25611..25615) }, Punct { char: '.', spacing: Alone, span: bytes(25615..25616) }, Ident { sym: current_node_index, span: bytes(25616..25634) }, Punct { char: '=', spacing: Alone, span: bytes(25635..25636) }, Ident { sym: node_idx, span: bytes(25637..25645) }, Punct { char: ';', spacing: Alone, span: bytes(25645..25646) }], span: bytes(25589..25664) }, Ident { sym: self, span: bytes(25682..25686) }, Punct { char: '.', spacing: Alone, span: bytes(25686..25687) }, Ident { sym: mark_moved, span: bytes(25687..25697) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(25697..25699) }, Punct { char: ';', spacing: Alone, span: bytes(25699..25700) }, Ident { sym: return, span: bytes(25717..25723) }, Ident { sym: true, span: bytes(25724..25728) }, Punct { char: ';', spacing: Alone, span: bytes(25728..25729) }], span: bytes(25156..25743) }], span: bytes(25124..25753) }, Ident { sym: false, span: bytes(25762..25767) }], span: bytes(25062..25773) }) }), delimiter: Some(Nothing) }, Delimited<syncdoc_core::parse::ModuleItem, unsynn::fundamental::Nothing> { value: Function(FnSig { attributes: Some(Repeats<1, 18446744073709551615, syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing>([Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: doc, span: bytes(25779..25816) }, Punct { char: '=', spacing: Alone, span: bytes(25779..25816) }, Literal { lit: " Move section down by one position", span: bytes(25779..25816) }], span: bytes(25779..25816) }) }, delimiter: Some(Nothing) }])), visibility: Some(Public(KPub(Cached<proc_macro2::Ident> { value: Ident { sym: pub, span: bytes(25821..25824) }, string: "pub" }))), const_kw: None, async_kw: None, unsafe_kw: None, extern_kw: None, _fn: KFn(Cached<proc_macro2::Ident> { value: Ident { sym: fn, span: bytes(25825..25827) }, string: "fn" }), name: Ident { sym: move_section_down, span: bytes(25828..25845) }, generics: None, params: ParenthesisGroupContaining < core::option::Option<unsynn::container::DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>>>(Some(DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>([Delimited<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>> { value: SelfParam(RefMut(Cons<unsynn::operator::Operator<'&'>, unsynn::combinator::Cons<syncdoc_core::parse::KMut, syncdoc_core::parse::KSelf>> { first: Operator<'&'>, second: Cons<syncdoc_core::parse::KMut, syncdoc_core::parse::KSelf> { first: KMut(Cached<proc_macro2::Ident> { value: Ident { sym: mut, span: bytes(25847..25850) }, string: "mut" }), second: KSelf(Cached<proc_macro2::Ident> { value: Ident { sym: self, span: bytes(25851..25855) }, string: "self" }) } })), delimiter: None }]))), return_type: Some(ReturnTypeFn { _arrow: Operator<'->'>, return_type: Repeats<1, 18446744073709551615, unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing>([Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::group::BraceGroup>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Ident { sym: bool, span: bytes(25860..25864) })) }, delimiter: Some(Nothing) }]) }), where_clause: None, body: BraceGroup(Group { delimiter: Brace, stream: TokenStream [Ident { sym: if, span: bytes(25875..25877) }, Ident { sym: let, span: bytes(25878..25881) }, Ident { sym: Some, span: bytes(25882..25886) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: moving_idx, span: bytes(25887..25897) }], span: bytes(25886..25898) }, Punct { char: '=', spacing: Alone, span: bytes(25899..25900) }, Ident { sym: self, span: bytes(25901..25905) }, Punct { char: '.', spacing: Alone, span: bytes(25905..25906) }, Ident { sym: moving_section_index, span: bytes(25906..25926) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: if, span: bytes(25941..25943) }, Ident { sym: moving_idx, span: bytes(25944..25954) }, Punct { char: '<', spacing: Alone, span: bytes(25955..25956) }, Ident { sym: self, span: bytes(25957..25961) }, Punct { char: '.', spacing: Alone, span: bytes(25961..25962) }, Ident { sym: sections, span: bytes(25962..25970) }, Punct { char: '.', spacing: Alone, span: bytes(25970..25971) }, Ident { sym: len, span: bytes(25971..25974) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(25974..25976) }, Punct { char: '-', spacing: Alone, span: bytes(25977..25978) }, Literal { lit: 1, span: bytes(25979..25980) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: self, span: bytes(25999..26003) }, Punct { char: '.', spacing: Alone, span: bytes(26003..26004) }, Ident { sym: sections, span: bytes(26004..26012) }, Punct { char: '.', spacing: Alone, span: bytes(26012..26013) }, Ident { sym: swap, span: bytes(26013..26017) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: moving_idx, span: bytes(26018..26028) }, Punct { char: ',', spacing: Alone, span: bytes(26028..26029) }, Ident { sym: moving_idx, span: bytes(26030..26040) }, Punct { char: '+', spacing: Alone, span: bytes(26041..26042) }, Literal { lit: 1, span: bytes(26043..26044) }], span: bytes(26017..26045) }, Punct { char: ';', spacing: Alone, span: bytes(26045..26046) }, Ident { sym: self, span: bytes(26063..26067) }, Punct { char: '.', spacing: Alone, span: bytes(26067..26068) }, Ident { sym: moving_section_index, span: bytes(26068..26088) }, Punct { char: '=', spacing: Alone, span: bytes(26089..26090) }, Ident { sym: Some, span: bytes(26091..26095) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: moving_idx, span: bytes(26096..26106) }, Punct { char: '+', spacing: Alone, span: bytes(26107..26108) }, Literal { lit: 1, span: bytes(26109..26110) }], span: bytes(26095..26111) }, Punct { char: ';', spacing: Alone, span: bytes(26111..26112) }, Ident { sym: self, span: bytes(26129..26133) }, Punct { char: '.', spacing: Alone, span: bytes(26133..26134) }, Ident { sym: rebuild_tree, span: bytes(26134..26146) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(26146..26148) }, Punct { char: ';', spacing: Alone, span: bytes(26148..26149) }, Ident { sym: if, span: bytes(26167..26169) }, Ident { sym: let, span: bytes(26170..26173) }, Ident { sym: Some, span: bytes(26174..26178) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: node_idx, span: bytes(26179..26187) }], span: bytes(26178..26188) }, Punct { char: '=', spacing: Alone, span: bytes(26189..26190) }, Ident { sym: self, span: bytes(26191..26195) }, Punct { char: '.', spacing: Alone, span: bytes(26216..26217) }, Ident { sym: tree_nodes, span: bytes(26217..26227) }, Punct { char: '.', spacing: Alone, span: bytes(26248..26249) }, Ident { sym: iter, span: bytes(26249..26253) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(26253..26255) }, Punct { char: '.', spacing: Alone, span: bytes(26276..26277) }, Ident { sym: position, span: bytes(26277..26285) }, Group { delimiter: Parenthesis, stream: TokenStream [Punct { char: '|', spacing: Alone, span: bytes(26286..26287) }, Ident { sym: n, span: bytes(26287..26288) }, Punct { char: '|', spacing: Alone, span: bytes(26288..26289) }, Ident { sym: n, span: bytes(26290..26291) }, Punct { char: '.', spacing: Alone, span: bytes(26291..26292) }, Ident { sym: section_index, span: bytes(26292..26305) }, Punct { char: '=', spacing: Joint, span: bytes(26306..26307) }, Punct { char: '=', spacing: Alone, span: bytes(26307..26308) }, Ident { sym: Some, span: bytes(26309..26313) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: moving_idx, span: bytes(26314..26324) }, Punct { char: '+', spacing: Alone, span: bytes(26325..26326) }, Literal { lit: 1, span: bytes(26327..26328) }], span: bytes(26313..26329) }], span: bytes(26285..26330) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: self, span: bytes(26369..26373) }, Punct { char: '.', spacing: Alone, span: bytes(26373..26374) }, Ident { sym: current_node_index, span: bytes(26374..26392) }, Punct { char: '=', spacing: Alone, span: bytes(26393..26394) }, Ident { sym: node_idx, span: bytes(26395..26403) }, Punct { char: ';', spacing: Alone, span: bytes(26403..26404) }], span: bytes(26347..26422) }, Ident { sym: self, span: bytes(26440..26444) }, Punct { char: '.', spacing: Alone, span: bytes(26444..26445) }, Ident { sym: mark_moved, span: bytes(26445..26455) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(26455..26457) }, Punct { char: ';', spacing: Alone, span: bytes(26457..26458) }, Ident { sym: return, span: bytes(26475..26481) }, Ident { sym: true, span: bytes(26482..26486) }, Punct { char: ';', spacing: Alone, span: bytes(26486..26487) }], span: bytes(25981..26501) }], span: bytes(25927..26511) }, Ident { sym: false, span: bytes(26520..26525) }], span: bytes(25865..26531) }) }), delimiter: Some(Nothing) }, Delimited<syncdoc_core::parse::ModuleItem, unsynn::fundamental::Nothing> { value: Function(FnSig { attributes: Some(Repeats<1, 18446744073709551615, syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing>([Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: doc, span: bytes(26537..26572) }, Punct { char: '=', spacing: Alone, span: bytes(26537..26572) }, Literal { lit: " Move section to top of document", span: bytes(26537..26572) }], span: bytes(26537..26572) }) }, delimiter: Some(Nothing) }])), visibility: Some(Public(KPub(Cached<proc_macro2::Ident> { value: Ident { sym: pub, span: bytes(26577..26580) }, string: "pub" }))), const_kw: None, async_kw: None, unsafe_kw: None, extern_kw: None, _fn: KFn(Cached<proc_macro2::Ident> { value: Ident { sym: fn, span: bytes(26581..26583) }, string: "fn" }), name: Ident { sym: move_section_to_top, span: bytes(26584..26603) }, generics: None, params: ParenthesisGroupContaining < core::option::Option<unsynn::container::DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>>>(Some(DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>([Delimited<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>> { value: SelfParam(RefMut(Cons<unsynn::operator::Operator<'&'>, unsynn::combinator::Cons<syncdoc_core::parse::KMut, syncdoc_core::parse::KSelf>> { first: Operator<'&'>, second: Cons<syncdoc_core::parse::KMut, syncdoc_core::parse::KSelf> { first: KMut(Cached<proc_macro2::Ident> { value: Ident { sym: mut, span: bytes(26605..26608) }, string: "mut" }), second: KSelf(Cached<proc_macro2::Ident> { value: Ident { sym: self, span: bytes(26609..26613) }, string: "self" }) } })), delimiter: None }]))), return_type: Some(ReturnTypeFn { _arrow: Operator<'->'>, return_type: Repeats<1, 18446744073709551615, unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing>([Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::group::BraceGroup>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Ident { sym: bool, span: bytes(26618..26622) })) }, delimiter: Some(Nothing) }]) }), where_clause: None, body: BraceGroup(Group { delimiter: Brace, stream: TokenStream [Ident { sym: if, span: bytes(26633..26635) }, Ident { sym: let, span: bytes(26636..26639) }, Ident { sym: Some, span: bytes(26640..26644) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: moving_idx, span: bytes(26645..26655) }], span: bytes(26644..26656) }, Punct { char: '=', spacing: Alone, span: bytes(26657..26658) }, Ident { sym: self, span: bytes(26659..26663) }, Punct { char: '.', spacing: Alone, span: bytes(26663..26664) }, Ident { sym: moving_section_index, span: bytes(26664..26684) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: if, span: bytes(26699..26701) }, Ident { sym: moving_idx, span: bytes(26702..26712) }, Punct { char: '>', spacing: Alone, span: bytes(26713..26714) }, Literal { lit: 0, span: bytes(26715..26716) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: let, span: bytes(26735..26738) }, Ident { sym: section, span: bytes(26739..26746) }, Punct { char: '=', spacing: Alone, span: bytes(26747..26748) }, Ident { sym: self, span: bytes(26749..26753) }, Punct { char: '.', spacing: Alone, span: bytes(26753..26754) }, Ident { sym: sections, span: bytes(26754..26762) }, Punct { char: '.', spacing: Alone, span: bytes(26762..26763) }, Ident { sym: remove, span: bytes(26763..26769) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: moving_idx, span: bytes(26770..26780) }], span: bytes(26769..26781) }, Punct { char: ';', spacing: Alone, span: bytes(26781..26782) }, Ident { sym: self, span: bytes(26799..26803) }, Punct { char: '.', spacing: Alone, span: bytes(26803..26804) }, Ident { sym: sections, span: bytes(26804..26812) }, Punct { char: '.', spacing: Alone, span: bytes(26812..26813) }, Ident { sym: insert, span: bytes(26813..26819) }, Group { delimiter: Parenthesis, stream: TokenStream [Literal { lit: 0, span: bytes(26820..26821) }, Punct { char: ',', spacing: Alone, span: bytes(26821..26822) }, Ident { sym: section, span: bytes(26823..26830) }], span: bytes(26819..26831) }, Punct { char: ';', spacing: Alone, span: bytes(26831..26832) }, Ident { sym: self, span: bytes(26849..26853) }, Punct { char: '.', spacing: Alone, span: bytes(26853..26854) }, Ident { sym: moving_section_index, span: bytes(26854..26874) }, Punct { char: '=', spacing: Alone, span: bytes(26875..26876) }, Ident { sym: Some, span: bytes(26877..26881) }, Group { delimiter: Parenthesis, stream: TokenStream [Literal { lit: 0, span: bytes(26882..26883) }], span: bytes(26881..26884) }, Punct { char: ';', spacing: Alone, span: bytes(26884..26885) }, Ident { sym: self, span: bytes(26902..26906) }, Punct { char: '.', spacing: Alone, span: bytes(26906..26907) }, Ident { sym: rebuild_tree, span: bytes(26907..26919) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(26919..26921) }, Punct { char: ';', spacing: Alone, span: bytes(26921..26922) }, Ident { sym: if, span: bytes(26940..26942) }, Ident { sym: let, span: bytes(26943..26946) }, Ident { sym: Some, span: bytes(26947..26951) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: node_idx, span: bytes(26952..26960) }], span: bytes(26951..26961) }, Punct { char: '=', spacing: Alone, span: bytes(26962..26963) }, Ident { sym: self, span: bytes(26964..26968) }, Punct { char: '.', spacing: Alone, span: bytes(26989..26990) }, Ident { sym: tree_nodes, span: bytes(26990..27000) }, Punct { char: '.', spacing: Alone, span: bytes(27021..27022) }, Ident { sym: iter, span: bytes(27022..27026) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(27026..27028) }, Punct { char: '.', spacing: Alone, span: bytes(27049..27050) }, Ident { sym: position, span: bytes(27050..27058) }, Group { delimiter: Parenthesis, stream: TokenStream [Punct { char: '|', spacing: Alone, span: bytes(27059..27060) }, Ident { sym: n, span: bytes(27060..27061) }, Punct { char: '|', spacing: Alone, span: bytes(27061..27062) }, Ident { sym: n, span: bytes(27063..27064) }, Punct { char: '.', spacing: Alone, span: bytes(27064..27065) }, Ident { sym: section_index, span: bytes(27065..27078) }, Punct { char: '=', spacing: Joint, span: bytes(27079..27080) }, Punct { char: '=', spacing: Alone, span: bytes(27080..27081) }, Ident { sym: Some, span: bytes(27082..27086) }, Group { delimiter: Parenthesis, stream: TokenStream [Literal { lit: 0, span: bytes(27087..27088) }], span: bytes(27086..27089) }], span: bytes(27058..27090) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: self, span: bytes(27129..27133) }, Punct { char: '.', spacing: Alone, span: bytes(27133..27134) }, Ident { sym: current_node_index, span: bytes(27134..27152) }, Punct { char: '=', spacing: Alone, span: bytes(27153..27154) }, Ident { sym: node_idx, span: bytes(27155..27163) }, Punct { char: ';', spacing: Alone, span: bytes(27163..27164) }], span: bytes(27107..27182) }, Ident { sym: self, span: bytes(27200..27204) }, Punct { char: '.', spacing: Alone, span: bytes(27204..27205) }, Ident { sym: mark_moved, span: bytes(27205..27215) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(27215..27217) }, Punct { char: ';', spacing: Alone, span: bytes(27217..27218) }, Ident { sym: return, span: bytes(27235..27241) }, Ident { sym: true, span: bytes(27242..27246) }, Punct { char: ';', spacing: Alone, span: bytes(27246..27247) }], span: bytes(26717..27261) }], span: bytes(26685..27271) }, Ident { sym: false, span: bytes(27280..27285) }], span: bytes(26623..27291) }) }), delimiter: Some(Nothing) }, Delimited<syncdoc_core::parse::ModuleItem, unsynn::fundamental::Nothing> { value: Function(FnSig { attributes: Some(Repeats<1, 18446744073709551615, syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing>([Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: doc, span: bytes(27297..27335) }, Punct { char: '=', spacing: Alone, span: bytes(27297..27335) }, Literal { lit: " Move section to bottom of document", span: bytes(27297..27335) }], span: bytes(27297..27335) }) }, delimiter: Some(Nothing) }])), visibility: Some(Public(KPub(Cached<proc_macro2::Ident> { value: Ident { sym: pub, span: bytes(27340..27343) }, string: "pub" }))), const_kw: None, async_kw: None, unsafe_kw: None, extern_kw: None, _fn: KFn(Cached<proc_macro2::Ident> { value: Ident { sym: fn, span: bytes(27344..27346) }, string: "fn" }), name: Ident { sym: move_section_to_bottom, span: bytes(27347..27369) }, generics: None, params: ParenthesisGroupContaining < core::option::Option<unsynn::container::DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>>>(Some(DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>([Delimited<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>> { value: SelfParam(RefMut(Cons<unsynn::operator::Operator<'&'>, unsynn::combinator::Cons<syncdoc_core::parse::KMut, syncdoc_core::parse::KSelf>> { first: Operator<'&'>, second: Cons<syncdoc_core::parse::KMut, syncdoc_core::parse::KSelf> { first: KMut(Cached<proc_macro2::Ident> { value: Ident { sym: mut, span: bytes(27371..27374) }, string: "mut" }), second: KSelf(Cached<proc_macro2::Ident> { value: Ident { sym: self, span: bytes(27375..27379) }, string: "self" }) } })), delimiter: None }]))), return_type: Some(ReturnTypeFn { _arrow: Operator<'->'>, return_type: Repeats<1, 18446744073709551615, unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing>([Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::group::BraceGroup>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Ident { sym: bool, span: bytes(27384..27388) })) }, delimiter: Some(Nothing) }]) }), where_clause: None, body: BraceGroup(Group { delimiter: Brace, stream: TokenStream [Ident { sym: if, span: bytes(27399..27401) }, Ident { sym: let, span: bytes(27402..27405) }, Ident { sym: Some, span: bytes(27406..27410) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: moving_idx, span: bytes(27411..27421) }], span: bytes(27410..27422) }, Punct { char: '=', spacing: Alone, span: bytes(27423..27424) }, Ident { sym: self, span: bytes(27425..27429) }, Punct { char: '.', spacing: Alone, span: bytes(27429..27430) }, Ident { sym: moving_section_index, span: bytes(27430..27450) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: let, span: bytes(27465..27468) }, Ident { sym: last_idx, span: bytes(27469..27477) }, Punct { char: '=', spacing: Alone, span: bytes(27478..27479) }, Ident { sym: self, span: bytes(27480..27484) }, Punct { char: '.', spacing: Alone, span: bytes(27484..27485) }, Ident { sym: sections, span: bytes(27485..27493) }, Punct { char: '.', spacing: Alone, span: bytes(27493..27494) }, Ident { sym: len, span: bytes(27494..27497) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(27497..27499) }, Punct { char: '-', spacing: Alone, span: bytes(27500..27501) }, Literal { lit: 1, span: bytes(27502..27503) }, Punct { char: ';', spacing: Alone, span: bytes(27503..27504) }, Ident { sym: if, span: bytes(27517..27519) }, Ident { sym: moving_idx, span: bytes(27520..27530) }, Punct { char: '<', spacing: Alone, span: bytes(27531..27532) }, Ident { sym: last_idx, span: bytes(27533..27541) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: let, span: bytes(27560..27563) }, Ident { sym: section, span: bytes(27564..27571) }, Punct { char: '=', spacing: Alone, span: bytes(27572..27573) }, Ident { sym: self, span: bytes(27574..27578) }, Punct { char: '.', spacing: Alone, span: bytes(27578..27579) }, Ident { sym: sections, span: bytes(27579..27587) }, Punct { char: '.', spacing: Alone, span: bytes(27587..27588) }, Ident { sym: remove, span: bytes(27588..27594) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: moving_idx, span: bytes(27595..27605) }], span: bytes(27594..27606) }, Punct { char: ';', spacing: Alone, span: bytes(27606..27607) }, Ident { sym: self, span: bytes(27624..27628) }, Punct { char: '.', spacing: Alone, span: bytes(27628..27629) }, Ident { sym: sections, span: bytes(27629..27637) }, Punct { char: '.', spacing: Alone, span: bytes(27637..27638) }, Ident { sym: push, span: bytes(27638..27642) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: section, span: bytes(27643..27650) }], span: bytes(27642..27651) }, Punct { char: ';', spacing: Alone, span: bytes(27651..27652) }, Ident { sym: self, span: bytes(27669..27673) }, Punct { char: '.', spacing: Alone, span: bytes(27673..27674) }, Ident { sym: moving_section_index, span: bytes(27674..27694) }, Punct { char: '=', spacing: Alone, span: bytes(27695..27696) }, Ident { sym: Some, span: bytes(27697..27701) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: last_idx, span: bytes(27702..27710) }], span: bytes(27701..27711) }, Punct { char: ';', spacing: Alone, span: bytes(27711..27712) }, Ident { sym: self, span: bytes(27729..27733) }, Punct { char: '.', spacing: Alone, span: bytes(27733..27734) }, Ident { sym: rebuild_tree, span: bytes(27734..27746) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(27746..27748) }, Punct { char: ';', spacing: Alone, span: bytes(27748..27749) }, Ident { sym: if, span: bytes(27767..27769) }, Ident { sym: let, span: bytes(27770..27773) }, Ident { sym: Some, span: bytes(27774..27778) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: node_idx, span: bytes(27779..27787) }], span: bytes(27778..27788) }, Punct { char: '=', spacing: Alone, span: bytes(27789..27790) }, Ident { sym: self, span: bytes(27791..27795) }, Punct { char: '.', spacing: Alone, span: bytes(27816..27817) }, Ident { sym: tree_nodes, span: bytes(27817..27827) }, Punct { char: '.', spacing: Alone, span: bytes(27848..27849) }, Ident { sym: iter, span: bytes(27849..27853) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(27853..27855) }, Punct { char: '.', spacing: Alone, span: bytes(27876..27877) }, Ident { sym: position, span: bytes(27877..27885) }, Group { delimiter: Parenthesis, stream: TokenStream [Punct { char: '|', spacing: Alone, span: bytes(27886..27887) }, Ident { sym: n, span: bytes(27887..27888) }, Punct { char: '|', spacing: Alone, span: bytes(27888..27889) }, Ident { sym: n, span: bytes(27890..27891) }, Punct { char: '.', spacing: Alone, span: bytes(27891..27892) }, Ident { sym: section_index, span: bytes(27892..27905) }, Punct { char: '=', spacing: Joint, span: bytes(27906..27907) }, Punct { char: '=', spacing: Alone, span: bytes(27907..27908) }, Ident { sym: Some, span: bytes(27909..27913) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: last_idx, span: bytes(27914..27922) }], span: bytes(27913..27923) }], span: bytes(27885..27924) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: self, span: bytes(27963..27967) }, Punct { char: '.', spacing: Alone, span: bytes(27967..27968) }, Ident { sym: current_node_index, span: bytes(27968..27986) }, Punct { char: '=', spacing: Alone, span: bytes(27987..27988) }, Ident { sym: node_idx, span: bytes(27989..27997) }, Punct { char: ';', spacing: Alone, span: bytes(27997..27998) }], span: bytes(27941..28016) }, Ident { sym: self, span: bytes(28034..28038) }, Punct { char: '.', spacing: Alone, span: bytes(28038..28039) }, Ident { sym: mark_moved, span: bytes(28039..28049) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(28049..28051) }, Punct { char: ';', spacing: Alone, span: bytes(28051..28052) }, Ident { sym: return, span: bytes(28069..28075) }, Ident { sym: true, span: bytes(28076..28080) }, Punct { char: ';', spacing: Alone, span: bytes(28080..28081) }], span: bytes(27542..28095) }], span: bytes(27451..28105) }, Ident { sym: false, span: bytes(28114..28119) }], span: bytes(27389..28125) }) }), delimiter: Some(Nothing) }, Delimited<syncdoc_core::parse::ModuleItem, unsynn::fundamental::Nothing> { value: Function(FnSig { attributes: Some(Repeats<1, 18446744073709551615, syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing>([Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: doc, span: bytes(28131..28188) }, Punct { char: '=', spacing: Alone, span: bytes(28131..28188) }, Literal { lit: " Increase section level (move in - lower level number)", span: bytes(28131..28188) }], span: bytes(28131..28188) }) }, delimiter: Some(Nothing) }])), visibility: Some(Public(KPub(Cached<proc_macro2::Ident> { value: Ident { sym: pub, span: bytes(28193..28196) }, string: "pub" }))), const_kw: None, async_kw: None, unsafe_kw: None, extern_kw: None, _fn: KFn(Cached<proc_macro2::Ident> { value: Ident { sym: fn, span: bytes(28197..28199) }, string: "fn" }), name: Ident { sym: move_section_in, span: bytes(28200..28215) }, generics: None, params: ParenthesisGroupContaining < core::option::Option<unsynn::container::DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>>>(Some(DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>([Delimited<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>> { value: SelfParam(RefMut(Cons<unsynn::operator::Operator<'&'>, unsynn::combinator::Cons<syncdoc_core::parse::KMut, syncdoc_core::parse::KSelf>> { first: Operator<'&'>, second: Cons<syncdoc_core::parse::KMut, syncdoc_core::parse::KSelf> { first: KMut(Cached<proc_macro2::Ident> { value: Ident { sym: mut, span: bytes(28217..28220) }, string: "mut" }), second: KSelf(Cached<proc_macro2::Ident> { value: Ident { sym: self, span: bytes(28221..28225) }, string: "self" }) } })), delimiter: None }]))), return_type: Some(ReturnTypeFn { _arrow: Operator<'->'>, return_type: Repeats<1, 18446744073709551615, unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing>([Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::group::BraceGroup>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Ident { sym: bool, span: bytes(28230..28234) })) }, delimiter: Some(Nothing) }]) }), where_clause: None, body: BraceGroup(Group { delimiter: Brace, stream: TokenStream [Ident { sym: if, span: bytes(28245..28247) }, Ident { sym: let, span: bytes(28248..28251) }, Ident { sym: Some, span: bytes(28252..28256) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: moving_idx, span: bytes(28257..28267) }], span: bytes(28256..28268) }, Punct { char: '=', spacing: Alone, span: bytes(28269..28270) }, Ident { sym: self, span: bytes(28271..28275) }, Punct { char: '.', spacing: Alone, span: bytes(28275..28276) }, Ident { sym: moving_section_index, span: bytes(28276..28296) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: if, span: bytes(28311..28313) }, Ident { sym: self, span: bytes(28314..28318) }, Punct { char: '.', spacing: Alone, span: bytes(28318..28319) }, Ident { sym: sections, span: bytes(28319..28327) }, Group { delimiter: Bracket, stream: TokenStream [Ident { sym: moving_idx, span: bytes(28328..28338) }], span: bytes(28327..28339) }, Punct { char: '.', spacing: Alone, span: bytes(28339..28340) }, Ident { sym: level, span: bytes(28340..28345) }, Punct { char: '>', spacing: Alone, span: bytes(28346..28347) }, Literal { lit: 1, span: bytes(28348..28349) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: self, span: bytes(28368..28372) }, Punct { char: '.', spacing: Alone, span: bytes(28372..28373) }, Ident { sym: sections, span: bytes(28373..28381) }, Group { delimiter: Bracket, stream: TokenStream [Ident { sym: moving_idx, span: bytes(28382..28392) }], span: bytes(28381..28393) }, Punct { char: '.', spacing: Alone, span: bytes(28393..28394) }, Ident { sym: level, span: bytes(28394..28399) }, Punct { char: '-', spacing: Joint, span: bytes(28400..28401) }, Punct { char: '=', spacing: Alone, span: bytes(28401..28402) }, Literal { lit: 1, span: bytes(28403..28404) }, Punct { char: ';', spacing: Alone, span: bytes(28404..28405) }, Ident { sym: self, span: bytes(28422..28426) }, Punct { char: '.', spacing: Alone, span: bytes(28426..28427) }, Ident { sym: rebuild_tree, span: bytes(28427..28439) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(28439..28441) }, Punct { char: ';', spacing: Alone, span: bytes(28441..28442) }, Ident { sym: self, span: bytes(28459..28463) }, Punct { char: '.', spacing: Alone, span: bytes(28463..28464) }, Ident { sym: mark_moved, span: bytes(28464..28474) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(28474..28476) }, Punct { char: ';', spacing: Alone, span: bytes(28476..28477) }, Ident { sym: return, span: bytes(28494..28500) }, Ident { sym: true, span: bytes(28501..28505) }, Punct { char: ';', spacing: Alone, span: bytes(28505..28506) }], span: bytes(28350..28520) }], span: bytes(28297..28530) }, Ident { sym: false, span: bytes(28539..28544) }], span: bytes(28235..28550) }) }), delimiter: Some(Nothing) }, Delimited<syncdoc_core::parse::ModuleItem, unsynn::fundamental::Nothing> { value: Function(FnSig { attributes: Some(Repeats<1, 18446744073709551615, syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing>([Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: doc, span: bytes(28556..28615) }, Punct { char: '=', spacing: Alone, span: bytes(28556..28615) }, Literal { lit: " Decrease section level (move out - higher level number)", span: bytes(28556..28615) }], span: bytes(28556..28615) }) }, delimiter: Some(Nothing) }])), visibility: Some(Public(KPub(Cached<proc_macro2::Ident> { value: Ident { sym: pub, span: bytes(28620..28623) }, string: "pub" }))), const_kw: None, async_kw: None, unsafe_kw: None, extern_kw: None, _fn: KFn(Cached<proc_macro2::Ident> { value: Ident { sym: fn, span: bytes(28624..28626) }, string: "fn" }), name: Ident { sym: move_section_out, span: bytes(28627..28643) }, generics: None, params: ParenthesisGroupContaining < core::option::Option<unsynn::container::DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>>>(Some(DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>([Delimited<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>> { value: SelfParam(RefMut(Cons<unsynn::operator::Operator<'&'>, unsynn::combinator::Cons<syncdoc_core::parse::KMut, syncdoc_core::parse::KSelf>> { first: Operator<'&'>, second: Cons<syncdoc_core::parse::KMut, syncdoc_core::parse::KSelf> { first: KMut(Cached<proc_macro2::Ident> { value: Ident { sym: mut, span: bytes(28645..28648) }, string: "mut" }), second: KSelf(Cached<proc_macro2::Ident> { value: Ident { sym: self, span: bytes(28649..28653) }, string: "self" }) } })), delimiter: None }]))), return_type: Some(ReturnTypeFn { _arrow: Operator<'->'>, return_type: Repeats<1, 18446744073709551615, unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing>([Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::group::BraceGroup>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Ident { sym: bool, span: bytes(28658..28662) })) }, delimiter: Some(Nothing) }]) }), where_clause: None, body: BraceGroup(Group { delimiter: Brace, stream: TokenStream [Ident { sym: if, span: bytes(28673..28675) }, Ident { sym: let, span: bytes(28676..28679) }, Ident { sym: Some, span: bytes(28680..28684) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: moving_idx, span: bytes(28685..28695) }], span: bytes(28684..28696) }, Punct { char: '=', spacing: Alone, span: bytes(28697..28698) }, Ident { sym: self, span: bytes(28699..28703) }, Punct { char: '.', spacing: Alone, span: bytes(28703..28704) }, Ident { sym: moving_section_index, span: bytes(28704..28724) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: if, span: bytes(28739..28741) }, Ident { sym: self, span: bytes(28742..28746) }, Punct { char: '.', spacing: Alone, span: bytes(28746..28747) }, Ident { sym: sections, span: bytes(28747..28755) }, Group { delimiter: Bracket, stream: TokenStream [Ident { sym: moving_idx, span: bytes(28756..28766) }], span: bytes(28755..28767) }, Punct { char: '.', spacing: Alone, span: bytes(28767..28768) }, Ident { sym: level, span: bytes(28768..28773) }, Punct { char: '<', spacing: Alone, span: bytes(28774..28775) }, Literal { lit: 6, span: bytes(28776..28777) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: self, span: bytes(28796..28800) }, Punct { char: '.', spacing: Alone, span: bytes(28800..28801) }, Ident { sym: sections, span: bytes(28801..28809) }, Group { delimiter: Bracket, stream: TokenStream [Ident { sym: moving_idx, span: bytes(28810..28820) }], span: bytes(28809..28821) }, Punct { char: '.', spacing: Alone, span: bytes(28821..28822) }, Ident { sym: level, span: bytes(28822..28827) }, Punct { char: '+', spacing: Joint, span: bytes(28828..28829) }, Punct { char: '=', spacing: Alone, span: bytes(28829..28830) }, Literal { lit: 1, span: bytes(28831..28832) }, Punct { char: ';', spacing: Alone, span: bytes(28832..28833) }, Ident { sym: self, span: bytes(28850..28854) }, Punct { char: '.', spacing: Alone, span: bytes(28854..28855) }, Ident { sym: rebuild_tree, span: bytes(28855..28867) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(28867..28869) }, Punct { char: ';', spacing: Alone, span: bytes(28869..28870) }, Ident { sym: self, span: bytes(28887..28891) }, Punct { char: '.', spacing: Alone, span: bytes(28891..28892) }, Ident { sym: mark_moved, span: bytes(28892..28902) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(28902..28904) }, Punct { char: ';', spacing: Alone, span: bytes(28904..28905) }, Ident { sym: return, span: bytes(28922..28928) }, Ident { sym: true, span: bytes(28929..28933) }, Punct { char: ';', spacing: Alone, span: bytes(28933..28934) }], span: bytes(28778..28948) }], span: bytes(28725..28958) }, Ident { sym: false, span: bytes(28967..28972) }], span: bytes(28663..28978) }) }), delimiter: Some(Nothing) }, Delimited<syncdoc_core::parse::ModuleItem, unsynn::fundamental::Nothing> { value: Function(FnSig { attributes: Some(Repeats<1, 18446744073709551615, syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing>([Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: doc, span: bytes(28984..29020) }, Punct { char: '=', spacing: Alone, span: bytes(28984..29020) }, Literal { lit: " Apply section reordering to disk", span: bytes(28984..29020) }], span: bytes(28984..29020) }) }, delimiter: Some(Nothing) }, Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: doc, span: bytes(29025..29028) }, Punct { char: '=', spacing: Alone, span: bytes(29025..29028) }, Literal { lit: "", span: bytes(29025..29028) }], span: bytes(29025..29028) }) }, delimiter: Some(Nothing) }, Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: doc, span: bytes(29033..29045) }, Punct { char: '=', spacing: Alone, span: bytes(29033..29045) }, Literal { lit: " # Errors", span: bytes(29033..29045) }], span: bytes(29033..29045) }) }, delimiter: Some(Nothing) }, Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: doc, span: bytes(29050..29053) }, Punct { char: '=', spacing: Alone, span: bytes(29050..29053) }, Literal { lit: "", span: bytes(29050..29053) }], span: bytes(29050..29053) }) }, delimiter: Some(Nothing) }, Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: doc, span: bytes(29058..29142) }, Punct { char: '=', spacing: Alone, span: bytes(29058..29142) }, Literal { lit: " Returns an error if writing to disk fails or if file operations cannot complete.", span: bytes(29058..29142) }], span: bytes(29058..29142) }) }, delimiter: Some(Nothing) }])), visibility: Some(Public(KPub(Cached<proc_macro2::Ident> { value: Ident { sym: pub, span: bytes(29147..29150) }, string: "pub" }))), const_kw: None, async_kw: None, unsafe_kw: None, extern_kw: None, _fn: KFn(Cached<proc_macro2::Ident> { value: Ident { sym: fn, span: bytes(29151..29153) }, string: "fn" }), name: Ident { sym: save_section_reorder, span: bytes(29154..29174) }, generics: None, params: ParenthesisGroupContaining < core::option::Option<unsynn::container::DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>>>(Some(DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>([Delimited<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>> { value: SelfParam(RefMut(Cons<unsynn::operator::Operator<'&'>, unsynn::combinator::Cons<syncdoc_core::parse::KMut, syncdoc_core::parse::KSelf>> { first: Operator<'&'>, second: Cons<syncdoc_core::parse::KMut, syncdoc_core::parse::KSelf> { first: KMut(Cached<proc_macro2::Ident> { value: Ident { sym: mut, span: bytes(29176..29179) }, string: "mut" }), second: KSelf(Cached<proc_macro2::Ident> { value: Ident { sym: self, span: bytes(29180..29184) }, string: "self" }) } })), delimiter: None }]))), return_type: Some(ReturnTypeFn { _arrow: Operator<'->'>, return_type: Repeats<1, 18446744073709551615, unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing>([Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::group::BraceGroup>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Ident { sym: io, span: bytes(29189..29191) })) }, delimiter: Some(Nothing) }, Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::group::BraceGroup>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Punct { char: ':', spacing: Joint, span: bytes(29191..29192) })) }, delimiter: Some(Nothing) }, Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::group::BraceGroup>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Punct { char: ':', spacing: Alone, span: bytes(29192..29193) })) }, delimiter: Some(Nothing) }, Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::group::BraceGroup>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Ident { sym: Result, span: bytes(29193..29199) })) }, delimiter: Some(Nothing) }, Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::group::BraceGroup>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>> { first: Operator<'<'>, second: [Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::operator::Operator<'>'>>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(29200..29202) })) }], third: Operator<'>'> })) }, delimiter: Some(Nothing) }]) }), where_clause: None, body: BraceGroup(Group { delimiter: Brace, stream: TokenStream [Ident { sym: if, span: bytes(29214..29216) }, Ident { sym: self, span: bytes(29217..29221) }, Punct { char: '.', spacing: Alone, span: bytes(29221..29222) }, Ident { sym: move_state, span: bytes(29222..29232) }, Punct { char: '!', spacing: Joint, span: bytes(29233..29234) }, Punct { char: '=', spacing: Alone, span: bytes(29234..29235) }, Ident { sym: MoveState, span: bytes(29236..29245) }, Punct { char: ':', spacing: Joint, span: bytes(29245..29246) }, Punct { char: ':', spacing: Alone, span: bytes(29246..29247) }, Ident { sym: Moved, span: bytes(29247..29252) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: return, span: bytes(29267..29273) }, Ident { sym: Ok, span: bytes(29274..29276) }, Group { delimiter: Parenthesis, stream: TokenStream [Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(29277..29279) }], span: bytes(29276..29280) }, Punct { char: ';', spacing: Alone, span: bytes(29280..29281) }], span: bytes(29253..29291) }, Ident { sym: let, span: bytes(29335..29338) }, Ident { sym: mut, span: bytes(29339..29342) }, Ident { sym: file_sections, span: bytes(29343..29356) }, Punct { char: ':', spacing: Alone, span: bytes(29356..29357) }, Ident { sym: HashMap, span: bytes(29358..29365) }, Punct { char: '<', spacing: Alone, span: bytes(29365..29366) }, Ident { sym: String, span: bytes(29366..29372) }, Punct { char: ',', spacing: Alone, span: bytes(29372..29373) }, Ident { sym: Vec, span: bytes(29374..29377) }, Punct { char: '<', spacing: Joint, span: bytes(29377..29378) }, Punct { char: '&', spacing: Alone, span: bytes(29378..29379) }, Ident { sym: Section, span: bytes(29379..29386) }, Punct { char: '>', spacing: Joint, span: bytes(29386..29387) }, Punct { char: '>', spacing: Alone, span: bytes(29387..29388) }, Punct { char: '=', spacing: Alone, span: bytes(29389..29390) }, Ident { sym: HashMap, span: bytes(29391..29398) }, Punct { char: ':', spacing: Joint, span: bytes(29398..29399) }, Punct { char: ':', spacing: Alone, span: bytes(29399..29400) }, Ident { sym: new, span: bytes(29400..29403) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(29403..29405) }, Punct { char: ';', spacing: Alone, span: bytes(29405..29406) }, Ident { sym: for, span: bytes(29415..29418) }, Ident { sym: section, span: bytes(29419..29426) }, Ident { sym: in, span: bytes(29427..29429) }, Punct { char: '&', spacing: Alone, span: bytes(29430..29431) }, Ident { sym: self, span: bytes(29431..29435) }, Punct { char: '.', spacing: Alone, span: bytes(29435..29436) }, Ident { sym: sections, span: bytes(29436..29444) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: file_sections, span: bytes(29459..29472) }, Punct { char: '.', spacing: Alone, span: bytes(29489..29490) }, Ident { sym: entry, span: bytes(29490..29495) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: section, span: bytes(29496..29503) }, Punct { char: '.', spacing: Alone, span: bytes(29503..29504) }, Ident { sym: file_path, span: bytes(29504..29513) }, Punct { char: '.', spacing: Alone, span: bytes(29513..29514) }, Ident { sym: clone, span: bytes(29514..29519) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(29519..29521) }], span: bytes(29495..29522) }, Punct { char: '.', spacing: Alone, span: bytes(29539..29540) }, Ident { sym: or_default, span: bytes(29540..29550) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(29550..29552) }, Punct { char: '.', spacing: Alone, span: bytes(29569..29570) }, Ident { sym: push, span: bytes(29570..29574) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: section, span: bytes(29575..29582) }], span: bytes(29574..29583) }, Punct { char: ';', spacing: Alone, span: bytes(29583..29584) }], span: bytes(29445..29594) }, Ident { sym: for, span: bytes(29633..29636) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: file_path, span: bytes(29638..29647) }, Punct { char: ',', spacing: Alone, span: bytes(29647..29648) }, Ident { sym: sections, span: bytes(29649..29657) }], span: bytes(29637..29658) }, Ident { sym: in, span: bytes(29659..29661) }, Ident { sym: file_sections, span: bytes(29662..29675) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: Self, span: bytes(29690..29694) }, Punct { char: ':', spacing: Joint, span: bytes(29694..29695) }, Punct { char: ':', spacing: Alone, span: bytes(29695..29696) }, Ident { sym: rewrite_file_sections, span: bytes(29696..29717) }, Group { delimiter: Parenthesis, stream: TokenStream [Punct { char: '&', spacing: Alone, span: bytes(29718..29719) }, Ident { sym: file_path, span: bytes(29719..29728) }, Punct { char: ',', spacing: Alone, span: bytes(29728..29729) }, Punct { char: '&', spacing: Alone, span: bytes(29730..29731) }, Ident { sym: sections, span: bytes(29731..29739) }], span: bytes(29717..29740) }, Punct { char: '?', spacing: Joint, span: bytes(29740..29741) }, Punct { char: ';', spacing: Alone, span: bytes(29741..29742) }], span: bytes(29676..29752) }, Ident { sym: let, span: bytes(29814..29817) }, Ident { sym: format, span: bytes(29818..29824) }, Punct { char: '=', spacing: Alone, span: bytes(29825..29826) }, Ident { sym: MarkdownFormat, span: bytes(29827..29841) }, Punct { char: ';', spacing: Alone, span: bytes(29841..29842) }, Ident { sym: let, span: bytes(29851..29854) }, Ident { sym: mut, span: bytes(29855..29858) }, Ident { sym: new_sections, span: bytes(29859..29871) }, Punct { char: '=', spacing: Alone, span: bytes(29872..29873) }, Ident { sym: Vec, span: bytes(29874..29877) }, Punct { char: ':', spacing: Joint, span: bytes(29877..29878) }, Punct { char: ':', spacing: Alone, span: bytes(29878..29879) }, Ident { sym: new, span: bytes(29879..29882) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(29882..29884) }, Punct { char: ';', spacing: Alone, span: bytes(29884..29885) }, Ident { sym: for, span: bytes(29894..29897) }, Ident { sym: file, span: bytes(29898..29902) }, Ident { sym: in, span: bytes(29903..29905) }, Punct { char: '&', spacing: Alone, span: bytes(29906..29907) }, Ident { sym: self, span: bytes(29907..29911) }, Punct { char: '.', spacing: Alone, span: bytes(29911..29912) }, Ident { sym: files, span: bytes(29912..29917) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: if, span: bytes(29932..29934) }, Ident { sym: let, span: bytes(29935..29938) }, Ident { sym: Ok, span: bytes(29939..29941) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: secs, span: bytes(29942..29946) }], span: bytes(29941..29947) }, Punct { char: '=', spacing: Alone, span: bytes(29948..29949) }, Ident { sym: input, span: bytes(29950..29955) }, Punct { char: ':', spacing: Joint, span: bytes(29955..29956) }, Punct { char: ':', spacing: Alone, span: bytes(29956..29957) }, Ident { sym: extract_sections, span: bytes(29957..29973) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: file, span: bytes(29974..29978) }, Punct { char: ',', spacing: Alone, span: bytes(29978..29979) }, Punct { char: '&', spacing: Alone, span: bytes(29980..29981) }, Ident { sym: format, span: bytes(29981..29987) }], span: bytes(29973..29988) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: new_sections, span: bytes(30007..30019) }, Punct { char: '.', spacing: Alone, span: bytes(30019..30020) }, Ident { sym: extend, span: bytes(30020..30026) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: secs, span: bytes(30027..30031) }], span: bytes(30026..30032) }, Punct { char: ';', spacing: Alone, span: bytes(30032..30033) }], span: bytes(29989..30047) }], span: bytes(29918..30057) }, Ident { sym: self, span: bytes(30067..30071) }, Punct { char: '.', spacing: Alone, span: bytes(30071..30072) }, Ident { sym: sections, span: bytes(30072..30080) }, Punct { char: '=', spacing: Alone, span: bytes(30081..30082) }, Ident { sym: new_sections, span: bytes(30083..30095) }, Punct { char: ';', spacing: Alone, span: bytes(30095..30096) }, Ident { sym: self, span: bytes(30105..30109) }, Punct { char: '.', spacing: Alone, span: bytes(30109..30110) }, Ident { sym: rebuild_tree, span: bytes(30110..30122) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(30122..30124) }, Punct { char: ';', spacing: Alone, span: bytes(30124..30125) }, Ident { sym: self, span: bytes(30134..30138) }, Punct { char: '.', spacing: Alone, span: bytes(30138..30139) }, Ident { sym: cancel_move, span: bytes(30139..30150) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(30150..30152) }, Punct { char: ';', spacing: Alone, span: bytes(30152..30153) }, Ident { sym: self, span: bytes(30162..30166) }, Punct { char: '.', spacing: Alone, span: bytes(30166..30167) }, Ident { sym: message, span: bytes(30167..30174) }, Punct { char: '=', spacing: Alone, span: bytes(30175..30176) }, Ident { sym: Some, span: bytes(30177..30181) }, Group { delimiter: Parenthesis, stream: TokenStream [Literal { lit: "Sections reordered", span: bytes(30182..30202) }, Punct { char: '.', spacing: Alone, span: bytes(30202..30203) }, Ident { sym: to_string, span: bytes(30203..30212) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(30212..30214) }], span: bytes(30181..30215) }, Punct { char: ';', spacing: Alone, span: bytes(30215..30216) }, Ident { sym: Ok, span: bytes(30226..30228) }, Group { delimiter: Parenthesis, stream: TokenStream [Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(30229..30231) }], span: bytes(30228..30232) }], span: bytes(29204..30238) }) }), delimiter: Some(Nothing) }, Delimited<syncdoc_core::parse::ModuleItem, unsynn::fundamental::Nothing> { value: Function(FnSig { attributes: Some(Repeats<1, 18446744073709551615, syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing>([Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: doc, span: bytes(30244..30294) }, Punct { char: '=', spacing: Alone, span: bytes(30244..30294) }, Literal { lit: " Rewrite an entire file with reordered sections", span: bytes(30244..30294) }], span: bytes(30244..30294) }) }, delimiter: Some(Nothing) }])), visibility: None, const_kw: None, async_kw: None, unsafe_kw: None, extern_kw: None, _fn: KFn(Cached<proc_macro2::Ident> { value: Ident { sym: fn, span: bytes(30299..30301) }, string: "fn" }), name: Ident { sym: rewrite_file_sections, span: bytes(30302..30323) }, generics: None, params: ParenthesisGroupContaining < core::option::Option<unsynn::container::DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>>>(Some(DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>([Delimited<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>> { value: Named(NamedParam { mut_kw: None, name: Ident { sym: file_path, span: bytes(30324..30333) }, _colon: Operator<':'>, param_type: Repeats<1, 18446744073709551615, unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<','>>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing>([Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<','>>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::operator::Operator<','>>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::operator::Operator<','>>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Punct { char: '&', spacing: Alone, span: bytes(30335..30336) })) }, delimiter: Some(Nothing) }, Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<','>>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::operator::Operator<','>>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::operator::Operator<','>>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Ident { sym: str, span: bytes(30336..30339) })) }, delimiter: Some(Nothing) }]) }), delimiter: Some(Operator<','>) }, Delimited<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>> { value: Named(NamedParam { mut_kw: None, name: Ident { sym: sections, span: bytes(30341..30349) }, _colon: Operator<':'>, param_type: Repeats<1, 18446744073709551615, unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<','>>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing>([Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<','>>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::operator::Operator<','>>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::operator::Operator<','>>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Punct { char: '&', spacing: Alone, span: bytes(30351..30352) })) }, delimiter: Some(Nothing) }, Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<','>>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::operator::Operator<','>>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::operator::Operator<','>>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Group { delimiter: Bracket, stream: TokenStream [Punct { char: '&', spacing: Alone, span: bytes(30353..30354) }, Ident { sym: Section, span: bytes(30354..30361) }], span: bytes(30352..30362) })) }, delimiter: Some(Nothing) }]) }), delimiter: None }]))), return_type: Some(ReturnTypeFn { _arrow: Operator<'->'>, return_type: Repeats<1, 18446744073709551615, unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing>([Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::group::BraceGroup>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Ident { sym: io, span: bytes(30367..30369) })) }, delimiter: Some(Nothing) }, Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::group::BraceGroup>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Punct { char: ':', spacing: Joint, span: bytes(30369..30370) })) }, delimiter: Some(Nothing) }, Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::group::BraceGroup>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Punct { char: ':', spacing: Alone, span: bytes(30370..30371) })) }, delimiter: Some(Nothing) }, Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::group::BraceGroup>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Ident { sym: Result, span: bytes(30371..30377) })) }, delimiter: Some(Nothing) }, Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::group::BraceGroup>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>> { first: Operator<'<'>, second: [Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::operator::Operator<'>'>>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(30378..30380) })) }], third: Operator<'>'> })) }, delimiter: Some(Nothing) }]) }), where_clause: None, body: BraceGroup(Group { delimiter: Brace, stream: TokenStream [Ident { sym: let, span: bytes(30392..30395) }, Ident { sym: content, span: bytes(30396..30403) }, Punct { char: '=', spacing: Alone, span: bytes(30404..30405) }, Ident { sym: fs, span: bytes(30406..30408) }, Punct { char: ':', spacing: Joint, span: bytes(30408..30409) }, Punct { char: ':', spacing: Alone, span: bytes(30409..30410) }, Ident { sym: read_to_string, span: bytes(30410..30424) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: file_path, span: bytes(30425..30434) }], span: bytes(30424..30435) }, Punct { char: '?', spacing: Joint, span: bytes(30435..30436) }, Punct { char: ';', spacing: Alone, span: bytes(30436..30437) }, Ident { sym: let, span: bytes(30446..30449) }, Ident { sym: mut, span: bytes(30450..30453) }, Ident { sym: new_content, span: bytes(30454..30465) }, Punct { char: '=', spacing: Alone, span: bytes(30466..30467) }, Ident { sym: String, span: bytes(30468..30474) }, Punct { char: ':', spacing: Joint, span: bytes(30474..30475) }, Punct { char: ':', spacing: Alone, span: bytes(30475..30476) }, Ident { sym: new, span: bytes(30476..30479) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(30479..30481) }, Punct { char: ';', spacing: Alone, span: bytes(30481..30482) }, Ident { sym: for, span: bytes(30492..30495) }, Ident { sym: section, span: bytes(30496..30503) }, Ident { sym: in, span: bytes(30504..30506) }, Ident { sym: sections, span: bytes(30507..30515) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: let, span: bytes(30530..30533) }, Ident { sym: heading_prefix, span: bytes(30534..30548) }, Punct { char: '=', spacing: Alone, span: bytes(30549..30550) }, Literal { lit: "#", span: bytes(30551..30554) }, Punct { char: '.', spacing: Alone, span: bytes(30554..30555) }, Ident { sym: repeat, span: bytes(30555..30561) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: section, span: bytes(30562..30569) }, Punct { char: '.', spacing: Alone, span: bytes(30569..30570) }, Ident { sym: level, span: bytes(30570..30575) }], span: bytes(30561..30576) }, Punct { char: ';', spacing: Alone, span: bytes(30576..30577) }, Ident { sym: let, span: bytes(30590..30593) }, Ident { sym: heading, span: bytes(30594..30601) }, Punct { char: '=', spacing: Alone, span: bytes(30602..30603) }, Ident { sym: format, span: bytes(30604..30610) }, Punct { char: '!', spacing: Alone, span: bytes(30610..30611) }, Group { delimiter: Parenthesis, stream: TokenStream [Literal { lit: "{} {}", span: bytes(30612..30619) }, Punct { char: ',', spacing: Alone, span: bytes(30619..30620) }, Ident { sym: heading_prefix, span: bytes(30621..30635) }, Punct { char: ',', spacing: Alone, span: bytes(30635..30636) }, Ident { sym: section, span: bytes(30637..30644) }, Punct { char: '.', spacing: Alone, span: bytes(30644..30645) }, Ident { sym: title, span: bytes(30645..30650) }], span: bytes(30611..30651) }, Punct { char: ';', spacing: Alone, span: bytes(30651..30652) }, Ident { sym: let, span: bytes(30666..30669) }, Ident { sym: bytes, span: bytes(30670..30675) }, Punct { char: '=', spacing: Alone, span: bytes(30676..30677) }, Ident { sym: content, span: bytes(30678..30685) }, Punct { char: '.', spacing: Alone, span: bytes(30685..30686) }, Ident { sym: as_bytes, span: bytes(30686..30694) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(30694..30696) }, Punct { char: ';', spacing: Alone, span: bytes(30696..30697) }, Ident { sym: let, span: bytes(30710..30713) }, Ident { sym: section_text, span: bytes(30714..30726) }, Punct { char: '=', spacing: Alone, span: bytes(30727..30728) }, Ident { sym: if, span: bytes(30745..30747) }, Ident { sym: section, span: bytes(30748..30755) }, Punct { char: '.', spacing: Alone, span: bytes(30755..30756) }, Ident { sym: byte_start, span: bytes(30756..30766) }, Punct { char: '<', spacing: Alone, span: bytes(30767..30768) }, Ident { sym: bytes, span: bytes(30769..30774) }, Punct { char: '.', spacing: Alone, span: bytes(30774..30775) }, Ident { sym: len, span: bytes(30775..30778) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(30778..30780) }, Punct { char: '&', spacing: Joint, span: bytes(30781..30782) }, Punct { char: '&', spacing: Alone, span: bytes(30782..30783) }, Ident { sym: section, span: bytes(30784..30791) }, Punct { char: '.', spacing: Alone, span: bytes(30791..30792) }, Ident { sym: byte_end, span: bytes(30792..30800) }, Punct { char: '<', spacing: Joint, span: bytes(30801..30802) }, Punct { char: '=', spacing: Alone, span: bytes(30802..30803) }, Ident { sym: bytes, span: bytes(30804..30809) }, Punct { char: '.', spacing: Alone, span: bytes(30809..30810) }, Ident { sym: len, span: bytes(30810..30813) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(30813..30815) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: String, span: bytes(30838..30844) }, Punct { char: ':', spacing: Joint, span: bytes(30844..30845) }, Punct { char: ':', spacing: Alone, span: bytes(30845..30846) }, Ident { sym: from_utf8_lossy, span: bytes(30846..30861) }, Group { delimiter: Parenthesis, stream: TokenStream [Punct { char: '&', spacing: Alone, span: bytes(30862..30863) }, Ident { sym: bytes, span: bytes(30863..30868) }, Group { delimiter: Bracket, stream: TokenStream [Ident { sym: section, span: bytes(30869..30876) }, Punct { char: '.', spacing: Alone, span: bytes(30876..30877) }, Ident { sym: byte_start, span: bytes(30877..30887) }, Punct { char: '.', spacing: Joint, span: bytes(30887..30888) }, Punct { char: '.', spacing: Alone, span: bytes(30888..30889) }, Ident { sym: section, span: bytes(30889..30896) }, Punct { char: '.', spacing: Alone, span: bytes(30896..30897) }, Ident { sym: byte_end, span: bytes(30897..30905) }], span: bytes(30868..30906) }], span: bytes(30861..30907) }, Punct { char: '.', spacing: Alone, span: bytes(30932..30933) }, Ident { sym: to_string, span: bytes(30933..30942) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(30942..30944) }, Punct { char: '.', spacing: Alone, span: bytes(30969..30970) }, Ident { sym: trim, span: bytes(30970..30974) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(30974..30976) }, Punct { char: '.', spacing: Alone, span: bytes(31001..31002) }, Ident { sym: to_string, span: bytes(31002..31011) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(31011..31013) }], span: bytes(30816..31031) }, Ident { sym: else, span: bytes(31032..31036) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: String, span: bytes(31059..31065) }, Punct { char: ':', spacing: Joint, span: bytes(31065..31066) }, Punct { char: ':', spacing: Alone, span: bytes(31066..31067) }, Ident { sym: new, span: bytes(31067..31070) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(31070..31072) }], span: bytes(31037..31090) }, Punct { char: ';', spacing: Alone, span: bytes(31090..31091) }, Ident { sym: new_content, span: bytes(31105..31116) }, Punct { char: '.', spacing: Alone, span: bytes(31116..31117) }, Ident { sym: push_str, span: bytes(31117..31125) }, Group { delimiter: Parenthesis, stream: TokenStream [Punct { char: '&', spacing: Alone, span: bytes(31126..31127) }, Ident { sym: heading, span: bytes(31127..31134) }], span: bytes(31125..31135) }, Punct { char: ';', spacing: Alone, span: bytes(31135..31136) }, Ident { sym: new_content, span: bytes(31149..31160) }, Punct { char: '.', spacing: Alone, span: bytes(31160..31161) }, Ident { sym: push_str, span: bytes(31161..31169) }, Group { delimiter: Parenthesis, stream: TokenStream [Literal { lit: "\n\n", span: bytes(31170..31176) }], span: bytes(31169..31177) }, Punct { char: ';', spacing: Alone, span: bytes(31177..31178) }, Ident { sym: if, span: bytes(31191..31193) }, Punct { char: '!', spacing: Alone, span: bytes(31194..31195) }, Ident { sym: section_text, span: bytes(31195..31207) }, Punct { char: '.', spacing: Alone, span: bytes(31207..31208) }, Ident { sym: is_empty, span: bytes(31208..31216) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(31216..31218) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: new_content, span: bytes(31237..31248) }, Punct { char: '.', spacing: Alone, span: bytes(31248..31249) }, Ident { sym: push_str, span: bytes(31249..31257) }, Group { delimiter: Parenthesis, stream: TokenStream [Punct { char: '&', spacing: Alone, span: bytes(31258..31259) }, Ident { sym: section_text, span: bytes(31259..31271) }], span: bytes(31257..31272) }, Punct { char: ';', spacing: Alone, span: bytes(31272..31273) }, Ident { sym: new_content, span: bytes(31290..31301) }, Punct { char: '.', spacing: Alone, span: bytes(31301..31302) }, Ident { sym: push_str, span: bytes(31302..31310) }, Group { delimiter: Parenthesis, stream: TokenStream [Literal { lit: "\n\n", span: bytes(31311..31317) }], span: bytes(31310..31318) }, Punct { char: ';', spacing: Alone, span: bytes(31318..31319) }], span: bytes(31219..31333) }], span: bytes(30516..31343) }, Ident { sym: fs, span: bytes(31353..31355) }, Punct { char: ':', spacing: Joint, span: bytes(31355..31356) }, Punct { char: ':', spacing: Alone, span: bytes(31356..31357) }, Ident { sym: write, span: bytes(31357..31362) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: file_path, span: bytes(31363..31372) }, Punct { char: ',', spacing: Alone, span: bytes(31372..31373) }, Ident { sym: new_content, span: bytes(31374..31385) }], span: bytes(31362..31386) }, Punct { char: '?', spacing: Joint, span: bytes(31386..31387) }, Punct { char: ';', spacing: Alone, span: bytes(31387..31388) }, Ident { sym: Ok, span: bytes(31397..31399) }, Group { delimiter: Parenthesis, stream: TokenStream [Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(31400..31402) }], span: bytes(31399..31403) }], span: bytes(30382..31409) }) }), delimiter: Some(Nothing) }]) }) })
[SYNCDOC DEBUG] Processing item type: Function
[SYNCDOC DEBUG] Processing item: Function(FnSig { attributes: Some(Repeats<1, 18446744073709551615, syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing>([Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: doc, span: bytes(3018..3098) }, Punct { char: '=', spacing: Alone, span: bytes(3018..3098) }, Literal { lit: " Initialises application state with parsed sections and determines file mode.", span: bytes(3018..3098) }], span: bytes(3018..3098) }) }, delimiter: Some(Nothing) }, Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: must_use, span: bytes(3105..3113) }], span: bytes(3104..3114) }) }, delimiter: Some(Nothing) }])), visibility: Some(Public(KPub(Cached<proc_macro2::Ident> { value: Ident { sym: pub, span: bytes(3119..3122) }, string: "pub" }))), const_kw: None, async_kw: None, unsafe_kw: None, extern_kw: None, _fn: KFn(Cached<proc_macro2::Ident> { value: Ident { sym: fn, span: bytes(3123..3125) }, string: "fn" }), name: Ident { sym: new, span: bytes(3126..3129) }, generics: None, params: ParenthesisGroupContaining < core::option::Option<unsynn::container::DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>>>(Some(DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>([Delimited<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>> { value: Named(NamedParam { mut_kw: None, name: Ident { sym: files, span: bytes(3130..3135) }, _colon: Operator<':'>, param_type: Repeats<1, 18446744073709551615, unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<','>>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing>([Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<','>>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::operator::Operator<','>>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::operator::Operator<','>>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Ident { sym: Vec, span: bytes(3137..3140) })) }, delimiter: Some(Nothing) }, Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<','>>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::operator::Operator<','>>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::operator::Operator<','>>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>> { first: Operator<'<'>, second: [Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::operator::Operator<'>'>>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Ident { sym: PathBuf, span: bytes(3141..3148) })) }], third: Operator<'>'> })) }, delimiter: Some(Nothing) }]) }), delimiter: Some(Operator<','>) }, Delimited<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>> { value: Named(NamedParam { mut_kw: None, name: Ident { sym: sections, span: bytes(3151..3159) }, _colon: Operator<':'>, param_type: Repeats<1, 18446744073709551615, unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<','>>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing>([Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<','>>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::operator::Operator<','>>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::operator::Operator<','>>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Ident { sym: Vec, span: bytes(3161..3164) })) }, delimiter: Some(Nothing) }, Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<','>>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::operator::Operator<','>>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::operator::Operator<','>>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>> { first: Operator<'<'>, second: [Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::operator::Operator<'>'>>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Ident { sym: Section, span: bytes(3165..3172) })) }], third: Operator<'>'> })) }, delimiter: Some(Nothing) }]) }), delimiter: Some(Operator<','>) }, Delimited<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>> { value: Named(NamedParam { mut_kw: None, name: Ident { sym: wrap_width, span: bytes(3175..3185) }, _colon: Operator<':'>, param_type: Repeats<1, 18446744073709551615, unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<','>>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing>([Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<','>>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::operator::Operator<','>>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::operator::Operator<','>>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Ident { sym: usize, span: bytes(3187..3192) })) }, delimiter: Some(Nothing) }]) }), delimiter: None }]))), return_type: Some(ReturnTypeFn { _arrow: Operator<'->'>, return_type: Repeats<1, 18446744073709551615, unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing>([Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::group::BraceGroup>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Ident { sym: Self, span: bytes(3197..3201) })) }, delimiter: Some(Nothing) }]) }), where_clause: None, body: BraceGroup(Group { delimiter: Brace, stream: TokenStream [Ident { sym: let, span: bytes(3212..3215) }, Ident { sym: file_mode, span: bytes(3216..3225) }, Punct { char: '=', spacing: Alone, span: bytes(3226..3227) }, Ident { sym: if, span: bytes(3228..3230) }, Ident { sym: files, span: bytes(3231..3236) }, Punct { char: '.', spacing: Alone, span: bytes(3236..3237) }, Ident { sym: len, span: bytes(3237..3240) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(3240..3242) }, Punct { char: '=', spacing: Joint, span: bytes(3243..3244) }, Punct { char: '=', spacing: Alone, span: bytes(3244..3245) }, Literal { lit: 1, span: bytes(3246..3247) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: FileMode, span: bytes(3262..3270) }, Punct { char: ':', spacing: Joint, span: bytes(3270..3271) }, Punct { char: ':', spacing: Alone, span: bytes(3271..3272) }, Ident { sym: Single, span: bytes(3272..3278) }], span: bytes(3248..3288) }, Ident { sym: else, span: bytes(3289..3293) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: FileMode, span: bytes(3308..3316) }, Punct { char: ':', spacing: Joint, span: bytes(3316..3317) }, Punct { char: ':', spacing: Alone, span: bytes(3317..3318) }, Ident { sym: Multi, span: bytes(3318..3323) }], span: bytes(3294..3333) }, Punct { char: ';', spacing: Alone, span: bytes(3333..3334) }, Ident { sym: let, span: bytes(3344..3347) }, Ident { sym: tree_nodes, span: bytes(3348..3358) }, Punct { char: '=', spacing: Alone, span: bytes(3359..3360) }, Ident { sym: Self, span: bytes(3361..3365) }, Punct { char: ':', spacing: Joint, span: bytes(3365..3366) }, Punct { char: ':', spacing: Alone, span: bytes(3366..3367) }, Ident { sym: build_tree, span: bytes(3367..3377) }, Group { delimiter: Parenthesis, stream: TokenStream [Punct { char: '&', spacing: Alone, span: bytes(3378..3379) }, Ident { sym: files, span: bytes(3379..3384) }, Punct { char: ',', spacing: Alone, span: bytes(3384..3385) }, Punct { char: '&', spacing: Alone, span: bytes(3386..3387) }, Ident { sym: sections, span: bytes(3387..3395) }], span: bytes(3377..3396) }, Punct { char: ';', spacing: Alone, span: bytes(3396..3397) }, Ident { sym: let, span: bytes(3444..3447) }, Ident { sym: initial_index, span: bytes(3448..3461) }, Punct { char: '=', spacing: Alone, span: bytes(3462..3463) }, Ident { sym: tree_nodes, span: bytes(3464..3474) }, Punct { char: '.', spacing: Alone, span: bytes(3474..3475) }, Ident { sym: iter, span: bytes(3475..3479) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(3479..3481) }, Punct { char: '.', spacing: Alone, span: bytes(3481..3482) }, Ident { sym: position, span: bytes(3482..3490) }, Group { delimiter: Parenthesis, stream: TokenStream [Punct { char: '|', spacing: Alone, span: bytes(3491..3492) }, Ident { sym: n, span: bytes(3492..3493) }, Punct { char: '|', spacing: Alone, span: bytes(3493..3494) }, Ident { sym: n, span: bytes(3495..3496) }, Punct { char: '.', spacing: Alone, span: bytes(3496..3497) }, Ident { sym: navigable, span: bytes(3497..3506) }], span: bytes(3490..3507) }, Punct { char: '.', spacing: Alone, span: bytes(3507..3508) }, Ident { sym: unwrap_or, span: bytes(3508..3517) }, Group { delimiter: Parenthesis, stream: TokenStream [Literal { lit: 0, span: bytes(3518..3519) }], span: bytes(3517..3520) }, Punct { char: ';', spacing: Alone, span: bytes(3520..3521) }, Ident { sym: Self, span: bytes(3531..3535) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: sections, span: bytes(3550..3558) }, Punct { char: ',', spacing: Alone, span: bytes(3558..3559) }, Ident { sym: tree_nodes, span: bytes(3572..3582) }, Punct { char: ',', spacing: Alone, span: bytes(3582..3583) }, Ident { sym: files, span: bytes(3596..3601) }, Punct { char: ',', spacing: Alone, span: bytes(3601..3602) }, Ident { sym: file_mode, span: bytes(3615..3624) }, Punct { char: ',', spacing: Alone, span: bytes(3624..3625) }, Ident { sym: current_view, span: bytes(3638..3650) }, Punct { char: ':', spacing: Alone, span: bytes(3650..3651) }, Ident { sym: View, span: bytes(3652..3656) }, Punct { char: ':', spacing: Joint, span: bytes(3656..3657) }, Punct { char: ':', spacing: Alone, span: bytes(3657..3658) }, Ident { sym: List, span: bytes(3658..3662) }, Punct { char: ',', spacing: Alone, span: bytes(3662..3663) }, Ident { sym: current_node_index, span: bytes(3676..3694) }, Punct { char: ':', spacing: Alone, span: bytes(3694..3695) }, Ident { sym: initial_index, span: bytes(3696..3709) }, Punct { char: ',', spacing: Alone, span: bytes(3709..3710) }, Ident { sym: editor_state, span: bytes(3723..3735) }, Punct { char: ':', spacing: Alone, span: bytes(3735..3736) }, Ident { sym: None, span: bytes(3737..3741) }, Punct { char: ',', spacing: Alone, span: bytes(3741..3742) }, Ident { sym: command_buffer, span: bytes(3755..3769) }, Punct { char: ':', spacing: Alone, span: bytes(3769..3770) }, Ident { sym: String, span: bytes(3771..3777) }, Punct { char: ':', spacing: Joint, span: bytes(3777..3778) }, Punct { char: ':', spacing: Alone, span: bytes(3778..3779) }, Ident { sym: new, span: bytes(3779..3782) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(3782..3784) }, Punct { char: ',', spacing: Alone, span: bytes(3784..3785) }, Ident { sym: message, span: bytes(3798..3805) }, Punct { char: ':', spacing: Alone, span: bytes(3805..3806) }, Ident { sym: None, span: bytes(3807..3811) }, Punct { char: ',', spacing: Alone, span: bytes(3811..3812) }, Ident { sym: wrap_width, span: bytes(3825..3835) }, Punct { char: ',', spacing: Alone, span: bytes(3835..3836) }, Ident { sym: file_offsets, span: bytes(3849..3861) }, Punct { char: ':', spacing: Alone, span: bytes(3861..3862) }, Ident { sym: HashMap, span: bytes(3863..3870) }, Punct { char: ':', spacing: Joint, span: bytes(3870..3871) }, Punct { char: ':', spacing: Alone, span: bytes(3871..3872) }, Ident { sym: new, span: bytes(3872..3875) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(3875..3877) }, Punct { char: ',', spacing: Alone, span: bytes(3877..3878) }, Ident { sym: move_state, span: bytes(3891..3901) }, Punct { char: ':', spacing: Alone, span: bytes(3901..3902) }, Ident { sym: MoveState, span: bytes(3903..3912) }, Punct { char: ':', spacing: Joint, span: bytes(3912..3913) }, Punct { char: ':', spacing: Alone, span: bytes(3913..3914) }, Ident { sym: None, span: bytes(3914..3918) }, Punct { char: ',', spacing: Alone, span: bytes(3918..3919) }, Ident { sym: moving_section_index, span: bytes(3932..3952) }, Punct { char: ':', spacing: Alone, span: bytes(3952..3953) }, Ident { sym: None, span: bytes(3954..3958) }, Punct { char: ',', spacing: Alone, span: bytes(3958..3959) }], span: bytes(3536..3969) }], span: bytes(3202..3975) }) })
[SYNCDOC DEBUG] Processing item type: Function
[SYNCDOC DEBUG] Processing item: Function(FnSig { attributes: None, visibility: None, const_kw: None, async_kw: None, unsafe_kw: None, extern_kw: None, _fn: KFn(Cached<proc_macro2::Ident> { value: Ident { sym: fn, span: bytes(3981..3983) }, string: "fn" }), name: Ident { sym: build_tree, span: bytes(3984..3994) }, generics: None, params: ParenthesisGroupContaining < core::option::Option<unsynn::container::DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>>>(Some(DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>([Delimited<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>> { value: Named(NamedParam { mut_kw: None, name: Ident { sym: files, span: bytes(3995..4000) }, _colon: Operator<':'>, param_type: Repeats<1, 18446744073709551615, unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<','>>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing>([Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<','>>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::operator::Operator<','>>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::operator::Operator<','>>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Punct { char: '&', spacing: Alone, span: bytes(4002..4003) })) }, delimiter: Some(Nothing) }, Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<','>>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::operator::Operator<','>>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::operator::Operator<','>>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: PathBuf, span: bytes(4004..4011) }], span: bytes(4003..4012) })) }, delimiter: Some(Nothing) }]) }), delimiter: Some(Operator<','>) }, Delimited<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>> { value: Named(NamedParam { mut_kw: None, name: Ident { sym: sections, span: bytes(4014..4022) }, _colon: Operator<':'>, param_type: Repeats<1, 18446744073709551615, unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<','>>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing>([Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<','>>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::operator::Operator<','>>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::operator::Operator<','>>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Punct { char: '&', spacing: Alone, span: bytes(4024..4025) })) }, delimiter: Some(Nothing) }, Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<','>>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::operator::Operator<','>>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::operator::Operator<','>>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: Section, span: bytes(4026..4033) }], span: bytes(4025..4034) })) }, delimiter: Some(Nothing) }]) }), delimiter: None }]))), return_type: Some(ReturnTypeFn { _arrow: Operator<'->'>, return_type: Repeats<1, 18446744073709551615, unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing>([Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::group::BraceGroup>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Ident { sym: Vec, span: bytes(4039..4042) })) }, delimiter: Some(Nothing) }, Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::group::BraceGroup>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>> { first: Operator<'<'>, second: [Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::operator::Operator<'>'>>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Ident { sym: TreeNode, span: bytes(4043..4051) })) }], third: Operator<'>'> })) }, delimiter: Some(Nothing) }]) }), where_clause: None, body: BraceGroup(Group { delimiter: Brace, stream: TokenStream [Ident { sym: let, span: bytes(4063..4066) }, Ident { sym: mut, span: bytes(4067..4070) }, Ident { sym: nodes, span: bytes(4071..4076) }, Punct { char: '=', spacing: Alone, span: bytes(4077..4078) }, Ident { sym: Vec, span: bytes(4079..4082) }, Punct { char: ':', spacing: Joint, span: bytes(4082..4083) }, Punct { char: ':', spacing: Alone, span: bytes(4083..4084) }, Ident { sym: new, span: bytes(4084..4087) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(4087..4089) }, Punct { char: ';', spacing: Alone, span: bytes(4089..4090) }, Ident { sym: let, span: bytes(4308..4311) }, Ident { sym: mut, span: bytes(4312..4315) }, Ident { sym: file_section_counts, span: bytes(4316..4335) }, Punct { char: ':', spacing: Alone, span: bytes(4335..4336) }, Ident { sym: HashMap, span: bytes(4337..4344) }, Punct { char: '<', spacing: Alone, span: bytes(4344..4345) }, Ident { sym: String, span: bytes(4345..4351) }, Punct { char: ',', spacing: Alone, span: bytes(4351..4352) }, Ident { sym: usize, span: bytes(4353..4358) }, Punct { char: '>', spacing: Alone, span: bytes(4358..4359) }, Punct { char: '=', spacing: Alone, span: bytes(4360..4361) }, Ident { sym: HashMap, span: bytes(4362..4369) }, Punct { char: ':', spacing: Joint, span: bytes(4369..4370) }, Punct { char: ':', spacing: Alone, span: bytes(4370..4371) }, Ident { sym: new, span: bytes(4371..4374) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(4374..4376) }, Punct { char: ';', spacing: Alone, span: bytes(4376..4377) }, Ident { sym: for, span: bytes(4386..4389) }, Ident { sym: section, span: bytes(4390..4397) }, Ident { sym: in, span: bytes(4398..4400) }, Ident { sym: sections, span: bytes(4401..4409) }, Group { delimiter: Brace, stream: TokenStream [Punct { char: '*', spacing: Alone, span: bytes(4424..4425) }, Ident { sym: file_section_counts, span: bytes(4425..4444) }, Punct { char: '.', spacing: Alone, span: bytes(4461..4462) }, Ident { sym: entry, span: bytes(4462..4467) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: section, span: bytes(4468..4475) }, Punct { char: '.', spacing: Alone, span: bytes(4475..4476) }, Ident { sym: file_path, span: bytes(4476..4485) }, Punct { char: '.', spacing: Alone, span: bytes(4485..4486) }, Ident { sym: clone, span: bytes(4486..4491) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(4491..4493) }], span: bytes(4467..4494) }, Punct { char: '.', spacing: Alone, span: bytes(4511..4512) }, Ident { sym: or_insert, span: bytes(4512..4521) }, Group { delimiter: Parenthesis, stream: TokenStream [Literal { lit: 0, span: bytes(4522..4523) }], span: bytes(4521..4524) }, Punct { char: '+', spacing: Joint, span: bytes(4525..4526) }, Punct { char: '=', spacing: Alone, span: bytes(4526..4527) }, Literal { lit: 1, span: bytes(4528..4529) }, Punct { char: ';', spacing: Alone, span: bytes(4529..4530) }], span: bytes(4410..4540) }, Ident { sym: let, span: bytes(4549..4552) }, Ident { sym: is_difftastic, span: bytes(4553..4566) }, Punct { char: '=', spacing: Alone, span: bytes(4567..4568) }, Ident { sym: file_section_counts, span: bytes(4569..4588) }, Punct { char: '.', spacing: Alone, span: bytes(4588..4589) }, Ident { sym: values, span: bytes(4589..4595) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(4595..4597) }, Punct { char: '.', spacing: Alone, span: bytes(4597..4598) }, Ident { sym: any, span: bytes(4598..4601) }, Group { delimiter: Parenthesis, stream: TokenStream [Punct { char: '|', spacing: Joint, span: bytes(4602..4603) }, Punct { char: '&', spacing: Alone, span: bytes(4603..4604) }, Ident { sym: count, span: bytes(4604..4609) }, Punct { char: '|', spacing: Alone, span: bytes(4609..4610) }, Ident { sym: count, span: bytes(4611..4616) }, Punct { char: '>', spacing: Alone, span: bytes(4617..4618) }, Literal { lit: 1, span: bytes(4619..4620) }], span: bytes(4601..4621) }, Punct { char: ';', spacing: Alone, span: bytes(4621..4622) }, Ident { sym: if, span: bytes(4632..4634) }, Ident { sym: files, span: bytes(4635..4640) }, Punct { char: '.', spacing: Alone, span: bytes(4640..4641) }, Ident { sym: len, span: bytes(4641..4644) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(4644..4646) }, Punct { char: '=', spacing: Joint, span: bytes(4647..4648) }, Punct { char: '=', spacing: Alone, span: bytes(4648..4649) }, Literal { lit: 1, span: bytes(4650..4651) }, Punct { char: '&', spacing: Joint, span: bytes(4652..4653) }, Punct { char: '&', spacing: Alone, span: bytes(4653..4654) }, Punct { char: '!', spacing: Alone, span: bytes(4655..4656) }, Ident { sym: is_difftastic, span: bytes(4656..4669) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: for, span: bytes(4765..4768) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: idx, span: bytes(4770..4773) }, Punct { char: ',', spacing: Alone, span: bytes(4773..4774) }, Ident { sym: section, span: bytes(4775..4782) }], span: bytes(4769..4783) }, Ident { sym: in, span: bytes(4784..4786) }, Ident { sym: sections, span: bytes(4787..4795) }, Punct { char: '.', spacing: Alone, span: bytes(4795..4796) }, Ident { sym: iter, span: bytes(4796..4800) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(4800..4802) }, Punct { char: '.', spacing: Alone, span: bytes(4802..4803) }, Ident { sym: enumerate, span: bytes(4803..4812) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(4812..4814) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: nodes, span: bytes(4833..4838) }, Punct { char: '.', spacing: Alone, span: bytes(4838..4839) }, Ident { sym: push, span: bytes(4839..4843) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: TreeNode, span: bytes(4844..4852) }, Punct { char: ':', spacing: Joint, span: bytes(4852..4853) }, Punct { char: ':', spacing: Alone, span: bytes(4853..4854) }, Ident { sym: section, span: bytes(4854..4861) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: section, span: bytes(4862..4869) }, Punct { char: '.', spacing: Alone, span: bytes(4869..4870) }, Ident { sym: clone, span: bytes(4870..4875) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(4875..4877) }, Punct { char: ',', spacing: Alone, span: bytes(4877..4878) }, Ident { sym: section, span: bytes(4879..4886) }, Punct { char: '.', spacing: Alone, span: bytes(4886..4887) }, Ident { sym: level, span: bytes(4887..4892) }, Punct { char: ',', spacing: Alone, span: bytes(4892..4893) }, Ident { sym: idx, span: bytes(4894..4897) }], span: bytes(4861..4898) }], span: bytes(4843..4899) }, Punct { char: ';', spacing: Alone, span: bytes(4899..4900) }], span: bytes(4815..4914) }], span: bytes(4670..4924) }, Ident { sym: else, span: bytes(4925..4929) }, Ident { sym: if, span: bytes(4930..4932) }, Ident { sym: is_difftastic, span: bytes(4933..4946) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: let, span: bytes(5051..5054) }, Ident { sym: mut, span: bytes(5055..5058) }, Ident { sym: file_tree, span: bytes(5059..5068) }, Punct { char: ':', spacing: Alone, span: bytes(5068..5069) }, Ident { sym: HashMap, span: bytes(5070..5077) }, Punct { char: '<', spacing: Alone, span: bytes(5077..5078) }, Ident { sym: String, span: bytes(5078..5084) }, Punct { char: ',', spacing: Alone, span: bytes(5084..5085) }, Ident { sym: Vec, span: bytes(5086..5089) }, Punct { char: '<', spacing: Alone, span: bytes(5089..5090) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: usize, span: bytes(5091..5096) }, Punct { char: ',', spacing: Alone, span: bytes(5096..5097) }, Punct { char: '&', spacing: Alone, span: bytes(5098..5099) }, Ident { sym: Section, span: bytes(5099..5106) }], span: bytes(5090..5107) }, Punct { char: '>', spacing: Joint, span: bytes(5107..5108) }, Punct { char: '>', spacing: Alone, span: bytes(5108..5109) }, Punct { char: '=', spacing: Alone, span: bytes(5110..5111) }, Ident { sym: HashMap, span: bytes(5112..5119) }, Punct { char: ':', spacing: Joint, span: bytes(5119..5120) }, Punct { char: ':', spacing: Alone, span: bytes(5120..5121) }, Ident { sym: new, span: bytes(5121..5124) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(5124..5126) }, Punct { char: ';', spacing: Alone, span: bytes(5126..5127) }, Ident { sym: let, span: bytes(5140..5143) }, Ident { sym: mut, span: bytes(5144..5147) }, Ident { sym: file_status, span: bytes(5148..5159) }, Punct { char: ':', spacing: Alone, span: bytes(5159..5160) }, Ident { sym: HashMap, span: bytes(5161..5168) }, Punct { char: '<', spacing: Alone, span: bytes(5168..5169) }, Ident { sym: String, span: bytes(5169..5175) }, Punct { char: ',', spacing: Alone, span: bytes(5175..5176) }, Ident { sym: Option, span: bytes(5177..5183) }, Punct { char: '<', spacing: Alone, span: bytes(5183..5184) }, Ident { sym: String, span: bytes(5184..5190) }, Punct { char: '>', spacing: Joint, span: bytes(5190..5191) }, Punct { char: '>', spacing: Alone, span: bytes(5191..5192) }, Punct { char: '=', spacing: Alone, span: bytes(5193..5194) }, Ident { sym: HashMap, span: bytes(5195..5202) }, Punct { char: ':', spacing: Joint, span: bytes(5202..5203) }, Punct { char: ':', spacing: Alone, span: bytes(5203..5204) }, Ident { sym: new, span: bytes(5204..5207) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(5207..5209) }, Punct { char: ';', spacing: Alone, span: bytes(5209..5210) }, Ident { sym: for, span: bytes(5286..5289) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: idx, span: bytes(5291..5294) }, Punct { char: ',', spacing: Alone, span: bytes(5294..5295) }, Ident { sym: section, span: bytes(5296..5303) }], span: bytes(5290..5304) }, Ident { sym: in, span: bytes(5305..5307) }, Ident { sym: sections, span: bytes(5308..5316) }, Punct { char: '.', spacing: Alone, span: bytes(5316..5317) }, Ident { sym: iter, span: bytes(5317..5321) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(5321..5323) }, Punct { char: '.', spacing: Alone, span: bytes(5323..5324) }, Ident { sym: enumerate, span: bytes(5324..5333) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(5333..5335) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: file_tree, span: bytes(5354..5363) }, Punct { char: '.', spacing: Alone, span: bytes(5384..5385) }, Ident { sym: entry, span: bytes(5385..5390) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: section, span: bytes(5391..5398) }, Punct { char: '.', spacing: Alone, span: bytes(5398..5399) }, Ident { sym: file_path, span: bytes(5399..5408) }, Punct { char: '.', spacing: Alone, span: bytes(5408..5409) }, Ident { sym: clone, span: bytes(5409..5414) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(5414..5416) }], span: bytes(5390..5417) }, Punct { char: '.', spacing: Alone, span: bytes(5438..5439) }, Ident { sym: or_default, span: bytes(5439..5449) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(5449..5451) }, Punct { char: '.', spacing: Alone, span: bytes(5472..5473) }, Ident { sym: push, span: bytes(5473..5477) }, Group { delimiter: Parenthesis, stream: TokenStream [Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: idx, span: bytes(5479..5482) }, Punct { char: ',', spacing: Alone, span: bytes(5482..5483) }, Ident { sym: section, span: bytes(5484..5491) }], span: bytes(5478..5492) }], span: bytes(5477..5493) }, Punct { char: ';', spacing: Alone, span: bytes(5493..5494) }, Ident { sym: if, span: bytes(5571..5573) }, Punct { char: '!', spacing: Alone, span: bytes(5574..5575) }, Ident { sym: file_status, span: bytes(5575..5586) }, Punct { char: '.', spacing: Alone, span: bytes(5586..5587) }, Ident { sym: contains_key, span: bytes(5587..5599) }, Group { delimiter: Parenthesis, stream: TokenStream [Punct { char: '&', spacing: Alone, span: bytes(5600..5601) }, Ident { sym: section, span: bytes(5601..5608) }, Punct { char: '.', spacing: Alone, span: bytes(5608..5609) }, Ident { sym: file_path, span: bytes(5609..5618) }], span: bytes(5599..5619) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: let, span: bytes(5642..5645) }, Ident { sym: status, span: bytes(5646..5652) }, Punct { char: '=', spacing: Alone, span: bytes(5653..5654) }, Ident { sym: if, span: bytes(5655..5657) }, Ident { sym: section, span: bytes(5658..5665) }, Punct { char: '.', spacing: Alone, span: bytes(5665..5666) }, Ident { sym: title, span: bytes(5666..5671) }, Punct { char: '.', spacing: Alone, span: bytes(5671..5672) }, Ident { sym: contains, span: bytes(5672..5680) }, Group { delimiter: Parenthesis, stream: TokenStream [Literal { lit: "@@ -0,0", span: bytes(5681..5690) }], span: bytes(5680..5691) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: Some, span: bytes(5718..5722) }, Group { delimiter: Parenthesis, stream: TokenStream [Literal { lit: "created", span: bytes(5723..5732) }, Punct { char: '.', spacing: Alone, span: bytes(5732..5733) }, Ident { sym: to_string, span: bytes(5733..5742) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(5742..5744) }], span: bytes(5722..5745) }], span: bytes(5692..5767) }, Ident { sym: else, span: bytes(5768..5772) }, Ident { sym: if, span: bytes(5773..5775) }, Ident { sym: section, span: bytes(5776..5783) }, Punct { char: '.', spacing: Alone, span: bytes(5783..5784) }, Ident { sym: title, span: bytes(5784..5789) }, Punct { char: '.', spacing: Alone, span: bytes(5789..5790) }, Ident { sym: contains, span: bytes(5790..5798) }, Group { delimiter: Parenthesis, stream: TokenStream [Literal { lit: "+0,0 @@", span: bytes(5799..5808) }], span: bytes(5798..5809) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: Some, span: bytes(5836..5840) }, Group { delimiter: Parenthesis, stream: TokenStream [Literal { lit: "deleted", span: bytes(5841..5850) }, Punct { char: '.', spacing: Alone, span: bytes(5850..5851) }, Ident { sym: to_string, span: bytes(5851..5860) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(5860..5862) }], span: bytes(5840..5863) }], span: bytes(5810..5885) }, Ident { sym: else, span: bytes(5886..5890) }, Ident { sym: if, span: bytes(5891..5893) }, Ident { sym: section, span: bytes(5894..5901) }, Punct { char: '.', spacing: Alone, span: bytes(5901..5902) }, Ident { sym: title, span: bytes(5902..5907) }, Punct { char: '.', spacing: Alone, span: bytes(5907..5908) }, Ident { sym: contains, span: bytes(5908..5916) }, Group { delimiter: Parenthesis, stream: TokenStream [Literal { lit: "@@ ", span: bytes(5917..5922) }], span: bytes(5916..5923) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: Some, span: bytes(5950..5954) }, Group { delimiter: Parenthesis, stream: TokenStream [Literal { lit: "changed", span: bytes(5955..5964) }, Punct { char: '.', spacing: Alone, span: bytes(5964..5965) }, Ident { sym: to_string, span: bytes(5965..5974) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(5974..5976) }], span: bytes(5954..5977) }], span: bytes(5924..5999) }, Ident { sym: else, span: bytes(6000..6004) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: None, span: bytes(6031..6035) }], span: bytes(6005..6057) }, Punct { char: ';', spacing: Alone, span: bytes(6057..6058) }, Ident { sym: file_status, span: bytes(6079..6090) }, Punct { char: '.', spacing: Alone, span: bytes(6090..6091) }, Ident { sym: insert, span: bytes(6091..6097) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: section, span: bytes(6098..6105) }, Punct { char: '.', spacing: Alone, span: bytes(6105..6106) }, Ident { sym: file_path, span: bytes(6106..6115) }, Punct { char: '.', spacing: Alone, span: bytes(6115..6116) }, Ident { sym: clone, span: bytes(6116..6121) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(6121..6123) }, Punct { char: ',', spacing: Alone, span: bytes(6123..6124) }, Ident { sym: status, span: bytes(6125..6131) }], span: bytes(6097..6132) }, Punct { char: ';', spacing: Alone, span: bytes(6132..6133) }], span: bytes(5620..6151) }], span: bytes(5336..6165) }, Ident { sym: let, span: bytes(6239..6242) }, Ident { sym: mut, span: bytes(6243..6246) }, Ident { sym: sorted_files, span: bytes(6247..6259) }, Punct { char: ':', spacing: Alone, span: bytes(6259..6260) }, Ident { sym: Vec, span: bytes(6261..6264) }, Punct { char: '<', spacing: Alone, span: bytes(6264..6265) }, Ident { sym: _, span: bytes(6265..6266) }, Punct { char: '>', spacing: Alone, span: bytes(6266..6267) }, Punct { char: '=', spacing: Alone, span: bytes(6268..6269) }, Ident { sym: file_tree, span: bytes(6270..6279) }, Punct { char: '.', spacing: Alone, span: bytes(6279..6280) }, Ident { sym: keys, span: bytes(6280..6284) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(6284..6286) }, Punct { char: '.', spacing: Alone, span: bytes(6286..6287) }, Ident { sym: collect, span: bytes(6287..6294) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(6294..6296) }, Punct { char: ';', spacing: Alone, span: bytes(6296..6297) }, Ident { sym: sorted_files, span: bytes(6310..6322) }, Punct { char: '.', spacing: Alone, span: bytes(6322..6323) }, Ident { sym: sort, span: bytes(6323..6327) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(6327..6329) }, Punct { char: ';', spacing: Alone, span: bytes(6329..6330) }, Ident { sym: for, span: bytes(6344..6347) }, Ident { sym: file_path, span: bytes(6348..6357) }, Ident { sym: in, span: bytes(6358..6360) }, Ident { sym: sorted_files, span: bytes(6361..6373) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: let, span: bytes(6441..6444) }, Ident { sym: file_name, span: bytes(6445..6454) }, Punct { char: '=', spacing: Alone, span: bytes(6455..6456) }, Ident { sym: PathBuf, span: bytes(6457..6464) }, Punct { char: ':', spacing: Joint, span: bytes(6464..6465) }, Punct { char: ':', spacing: Alone, span: bytes(6465..6466) }, Ident { sym: from, span: bytes(6466..6470) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: file_path, span: bytes(6471..6480) }], span: bytes(6470..6481) }, Punct { char: '.', spacing: Alone, span: bytes(6502..6503) }, Ident { sym: file_name, span: bytes(6503..6512) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(6512..6514) }, Punct { char: '.', spacing: Alone, span: bytes(6535..6536) }, Ident { sym: map_or_else, span: bytes(6536..6547) }, Group { delimiter: Parenthesis, stream: TokenStream [Punct { char: '|', spacing: Joint, span: bytes(6548..6549) }, Punct { char: '|', spacing: Alone, span: bytes(6549..6550) }, Ident { sym: file_path, span: bytes(6551..6560) }, Punct { char: '.', spacing: Alone, span: bytes(6560..6561) }, Ident { sym: clone, span: bytes(6561..6566) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(6566..6568) }, Punct { char: ',', spacing: Alone, span: bytes(6568..6569) }, Punct { char: '|', spacing: Alone, span: bytes(6570..6571) }, Ident { sym: n, span: bytes(6571..6572) }, Punct { char: '|', spacing: Alone, span: bytes(6572..6573) }, Ident { sym: n, span: bytes(6574..6575) }, Punct { char: '.', spacing: Alone, span: bytes(6575..6576) }, Ident { sym: to_string_lossy, span: bytes(6576..6591) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(6591..6593) }, Punct { char: '.', spacing: Alone, span: bytes(6593..6594) }, Ident { sym: to_string, span: bytes(6594..6603) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(6603..6605) }], span: bytes(6547..6606) }, Punct { char: ';', spacing: Alone, span: bytes(6606..6607) }, Ident { sym: let, span: bytes(6625..6628) }, Ident { sym: status_opt, span: bytes(6629..6639) }, Punct { char: '=', spacing: Alone, span: bytes(6640..6641) }, Ident { sym: file_status, span: bytes(6642..6653) }, Punct { char: '.', spacing: Alone, span: bytes(6653..6654) }, Ident { sym: get, span: bytes(6654..6657) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: file_path, span: bytes(6658..6667) }], span: bytes(6657..6668) }, Punct { char: '.', spacing: Alone, span: bytes(6668..6669) }, Ident { sym: and_then, span: bytes(6669..6677) }, Group { delimiter: Parenthesis, stream: TokenStream [Punct { char: '|', spacing: Alone, span: bytes(6678..6679) }, Ident { sym: opt, span: bytes(6679..6682) }, Punct { char: '|', spacing: Alone, span: bytes(6682..6683) }, Ident { sym: opt, span: bytes(6684..6687) }, Punct { char: '.', spacing: Alone, span: bytes(6687..6688) }, Ident { sym: as_deref, span: bytes(6688..6696) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(6696..6698) }], span: bytes(6677..6699) }, Punct { char: ';', spacing: Alone, span: bytes(6699..6700) }, Ident { sym: let, span: bytes(6750..6753) }, Ident { sym: label, span: bytes(6754..6759) }, Punct { char: '=', spacing: Alone, span: bytes(6760..6761) }, Ident { sym: match, span: bytes(6762..6767) }, Ident { sym: status_opt, span: bytes(6768..6778) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: Some, span: bytes(6801..6805) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: status, span: bytes(6806..6812) }], span: bytes(6805..6813) }, Punct { char: '=', spacing: Joint, span: bytes(6814..6815) }, Punct { char: '>', spacing: Alone, span: bytes(6815..6816) }, Ident { sym: format, span: bytes(6817..6823) }, Punct { char: '!', spacing: Alone, span: bytes(6823..6824) }, Group { delimiter: Parenthesis, stream: TokenStream [Literal { lit: "{file_name} ({status})", span: bytes(6825..6849) }], span: bytes(6824..6850) }, Punct { char: ',', spacing: Alone, span: bytes(6850..6851) }, Ident { sym: None, span: bytes(6872..6876) }, Punct { char: '=', spacing: Joint, span: bytes(6877..6878) }, Punct { char: '>', spacing: Alone, span: bytes(6878..6879) }, Ident { sym: file_name, span: bytes(6880..6889) }, Punct { char: '.', spacing: Alone, span: bytes(6889..6890) }, Ident { sym: clone, span: bytes(6890..6895) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(6895..6897) }, Punct { char: ',', spacing: Alone, span: bytes(6897..6898) }], span: bytes(6779..6916) }, Punct { char: ';', spacing: Alone, span: bytes(6916..6917) }, Ident { sym: nodes, span: bytes(6935..6940) }, Punct { char: '.', spacing: Alone, span: bytes(6940..6941) }, Ident { sym: push, span: bytes(6941..6945) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: TreeNode, span: bytes(6946..6954) }, Punct { char: ':', spacing: Joint, span: bytes(6954..6955) }, Punct { char: ':', spacing: Alone, span: bytes(6955..6956) }, Ident { sym: file, span: bytes(6956..6960) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: label, span: bytes(6961..6966) }, Punct { char: ',', spacing: Alone, span: bytes(6966..6967) }, Ident { sym: file_path, span: bytes(6968..6977) }, Punct { char: '.', spacing: Alone, span: bytes(6977..6978) }, Ident { sym: clone, span: bytes(6978..6983) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(6983..6985) }, Punct { char: ',', spacing: Alone, span: bytes(6985..6986) }, Literal { lit: 0, span: bytes(6987..6988) }], span: bytes(6960..6989) }], span: bytes(6945..6990) }, Punct { char: ';', spacing: Alone, span: bytes(6990..6991) }, Ident { sym: if, span: bytes(7062..7064) }, Ident { sym: let, span: bytes(7065..7068) }, Ident { sym: Some, span: bytes(7069..7073) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: file_sections, span: bytes(7074..7087) }], span: bytes(7073..7088) }, Punct { char: '=', spacing: Alone, span: bytes(7089..7090) }, Ident { sym: file_tree, span: bytes(7091..7100) }, Punct { char: '.', spacing: Alone, span: bytes(7100..7101) }, Ident { sym: get, span: bytes(7101..7104) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: file_path, span: bytes(7105..7114) }], span: bytes(7104..7115) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: for, span: bytes(7138..7141) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: idx, span: bytes(7143..7146) }, Punct { char: ',', spacing: Alone, span: bytes(7146..7147) }, Ident { sym: section, span: bytes(7148..7155) }], span: bytes(7142..7156) }, Ident { sym: in, span: bytes(7157..7159) }, Ident { sym: file_sections, span: bytes(7160..7173) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: nodes, span: bytes(7200..7205) }, Punct { char: '.', spacing: Alone, span: bytes(7205..7206) }, Ident { sym: push, span: bytes(7206..7210) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: TreeNode, span: bytes(7211..7219) }, Punct { char: ':', spacing: Joint, span: bytes(7219..7220) }, Punct { char: ':', spacing: Alone, span: bytes(7220..7221) }, Ident { sym: section, span: bytes(7221..7228) }, Group { delimiter: Parenthesis, stream: TokenStream [Group { delimiter: Parenthesis, stream: TokenStream [Punct { char: '*', spacing: Alone, span: bytes(7230..7231) }, Ident { sym: section, span: bytes(7231..7238) }], span: bytes(7229..7239) }, Punct { char: '.', spacing: Alone, span: bytes(7239..7240) }, Ident { sym: clone, span: bytes(7240..7245) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(7245..7247) }, Punct { char: ',', spacing: Alone, span: bytes(7247..7248) }, Literal { lit: 1, span: bytes(7249..7250) }, Punct { char: ',', spacing: Alone, span: bytes(7250..7251) }, Punct { char: '*', spacing: Alone, span: bytes(7252..7253) }, Ident { sym: idx, span: bytes(7253..7256) }], span: bytes(7228..7257) }], span: bytes(7210..7258) }, Punct { char: ';', spacing: Alone, span: bytes(7258..7259) }], span: bytes(7174..7281) }], span: bytes(7116..7299) }], span: bytes(6374..7313) }], span: bytes(4947..7323) }, Ident { sym: else, span: bytes(7324..7328) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: let, span: bytes(7438..7441) }, Ident { sym: mut, span: bytes(7442..7445) }, Ident { sym: file_tree, span: bytes(7446..7455) }, Punct { char: ':', spacing: Alone, span: bytes(7455..7456) }, Ident { sym: HashMap, span: bytes(7457..7464) }, Punct { char: '<', spacing: Alone, span: bytes(7464..7465) }, Ident { sym: String, span: bytes(7465..7471) }, Punct { char: ',', spacing: Alone, span: bytes(7471..7472) }, Ident { sym: Vec, span: bytes(7473..7476) }, Punct { char: '<', spacing: Alone, span: bytes(7476..7477) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: usize, span: bytes(7478..7483) }, Punct { char: ',', spacing: Alone, span: bytes(7483..7484) }, Punct { char: '&', spacing: Alone, span: bytes(7485..7486) }, Ident { sym: Section, span: bytes(7486..7493) }], span: bytes(7477..7494) }, Punct { char: '>', spacing: Joint, span: bytes(7494..7495) }, Punct { char: '>', spacing: Alone, span: bytes(7495..7496) }, Punct { char: '=', spacing: Alone, span: bytes(7497..7498) }, Ident { sym: HashMap, span: bytes(7499..7506) }, Punct { char: ':', spacing: Joint, span: bytes(7506..7507) }, Punct { char: ':', spacing: Alone, span: bytes(7507..7508) }, Ident { sym: new, span: bytes(7508..7511) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(7511..7513) }, Punct { char: ';', spacing: Alone, span: bytes(7513..7514) }, Ident { sym: for, span: bytes(7566..7569) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: idx, span: bytes(7571..7574) }, Punct { char: ',', spacing: Alone, span: bytes(7574..7575) }, Ident { sym: section, span: bytes(7576..7583) }], span: bytes(7570..7584) }, Ident { sym: in, span: bytes(7585..7587) }, Ident { sym: sections, span: bytes(7588..7596) }, Punct { char: '.', spacing: Alone, span: bytes(7596..7597) }, Ident { sym: iter, span: bytes(7597..7601) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(7601..7603) }, Punct { char: '.', spacing: Alone, span: bytes(7603..7604) }, Ident { sym: enumerate, span: bytes(7604..7613) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(7613..7615) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: file_tree, span: bytes(7634..7643) }, Punct { char: '.', spacing: Alone, span: bytes(7664..7665) }, Ident { sym: entry, span: bytes(7665..7670) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: section, span: bytes(7671..7678) }, Punct { char: '.', spacing: Alone, span: bytes(7678..7679) }, Ident { sym: file_path, span: bytes(7679..7688) }, Punct { char: '.', spacing: Alone, span: bytes(7688..7689) }, Ident { sym: clone, span: bytes(7689..7694) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(7694..7696) }], span: bytes(7670..7697) }, Punct { char: '.', spacing: Alone, span: bytes(7718..7719) }, Ident { sym: or_default, span: bytes(7719..7729) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(7729..7731) }, Punct { char: '.', spacing: Alone, span: bytes(7752..7753) }, Ident { sym: push, span: bytes(7753..7757) }, Group { delimiter: Parenthesis, stream: TokenStream [Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: idx, span: bytes(7759..7762) }, Punct { char: ',', spacing: Alone, span: bytes(7762..7763) }, Ident { sym: section, span: bytes(7764..7771) }], span: bytes(7758..7772) }], span: bytes(7757..7773) }, Punct { char: ';', spacing: Alone, span: bytes(7773..7774) }], span: bytes(7616..7788) }, Ident { sym: let, span: bytes(7853..7856) }, Ident { sym: mut, span: bytes(7857..7860) }, Ident { sym: sorted_files, span: bytes(7861..7873) }, Punct { char: ':', spacing: Alone, span: bytes(7873..7874) }, Ident { sym: Vec, span: bytes(7875..7878) }, Punct { char: '<', spacing: Alone, span: bytes(7878..7879) }, Ident { sym: _, span: bytes(7879..7880) }, Punct { char: '>', spacing: Alone, span: bytes(7880..7881) }, Punct { char: '=', spacing: Alone, span: bytes(7882..7883) }, Ident { sym: files, span: bytes(7884..7889) }, Punct { char: '.', spacing: Alone, span: bytes(7889..7890) }, Ident { sym: iter, span: bytes(7890..7894) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(7894..7896) }, Punct { char: '.', spacing: Alone, span: bytes(7896..7897) }, Ident { sym: collect, span: bytes(7897..7904) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(7904..7906) }, Punct { char: ';', spacing: Alone, span: bytes(7906..7907) }, Ident { sym: sorted_files, span: bytes(7920..7932) }, Punct { char: '.', spacing: Alone, span: bytes(7932..7933) }, Ident { sym: sort, span: bytes(7933..7937) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(7937..7939) }, Punct { char: ';', spacing: Alone, span: bytes(7939..7940) }, Ident { sym: for, span: bytes(7954..7957) }, Ident { sym: file_path, span: bytes(7958..7967) }, Ident { sym: in, span: bytes(7968..7970) }, Ident { sym: sorted_files, span: bytes(7971..7983) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: let, span: bytes(8002..8005) }, Ident { sym: path_str, span: bytes(8006..8014) }, Punct { char: '=', spacing: Alone, span: bytes(8015..8016) }, Ident { sym: file_path, span: bytes(8017..8026) }, Punct { char: '.', spacing: Alone, span: bytes(8026..8027) }, Ident { sym: to_string_lossy, span: bytes(8027..8042) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(8042..8044) }, Punct { char: '.', spacing: Alone, span: bytes(8044..8045) }, Ident { sym: to_string, span: bytes(8045..8054) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(8054..8056) }, Punct { char: ';', spacing: Alone, span: bytes(8056..8057) }, Ident { sym: let, span: bytes(8124..8127) }, Ident { sym: file_name, span: bytes(8128..8137) }, Punct { char: '=', spacing: Alone, span: bytes(8138..8139) }, Ident { sym: file_path, span: bytes(8140..8149) }, Punct { char: '.', spacing: Alone, span: bytes(8170..8171) }, Ident { sym: file_name, span: bytes(8171..8180) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(8180..8182) }, Punct { char: '.', spacing: Alone, span: bytes(8203..8204) }, Ident { sym: map_or_else, span: bytes(8204..8215) }, Group { delimiter: Parenthesis, stream: TokenStream [Punct { char: '|', spacing: Joint, span: bytes(8216..8217) }, Punct { char: '|', spacing: Alone, span: bytes(8217..8218) }, Ident { sym: path_str, span: bytes(8219..8227) }, Punct { char: '.', spacing: Alone, span: bytes(8227..8228) }, Ident { sym: clone, span: bytes(8228..8233) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(8233..8235) }, Punct { char: ',', spacing: Alone, span: bytes(8235..8236) }, Punct { char: '|', spacing: Alone, span: bytes(8237..8238) }, Ident { sym: n, span: bytes(8238..8239) }, Punct { char: '|', spacing: Alone, span: bytes(8239..8240) }, Ident { sym: n, span: bytes(8241..8242) }, Punct { char: '.', spacing: Alone, span: bytes(8242..8243) }, Ident { sym: to_string_lossy, span: bytes(8243..8258) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(8258..8260) }, Punct { char: '.', spacing: Alone, span: bytes(8260..8261) }, Ident { sym: to_string, span: bytes(8261..8270) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(8270..8272) }], span: bytes(8215..8273) }, Punct { char: ';', spacing: Alone, span: bytes(8273..8274) }, Ident { sym: nodes, span: bytes(8292..8297) }, Punct { char: '.', spacing: Alone, span: bytes(8297..8298) }, Ident { sym: push, span: bytes(8298..8302) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: TreeNode, span: bytes(8303..8311) }, Punct { char: ':', spacing: Joint, span: bytes(8311..8312) }, Punct { char: ':', spacing: Alone, span: bytes(8312..8313) }, Ident { sym: file, span: bytes(8313..8317) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: file_name, span: bytes(8318..8327) }, Punct { char: '.', spacing: Alone, span: bytes(8327..8328) }, Ident { sym: clone, span: bytes(8328..8333) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(8333..8335) }, Punct { char: ',', spacing: Alone, span: bytes(8335..8336) }, Ident { sym: path_str, span: bytes(8337..8345) }, Punct { char: '.', spacing: Alone, span: bytes(8345..8346) }, Ident { sym: clone, span: bytes(8346..8351) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(8351..8353) }, Punct { char: ',', spacing: Alone, span: bytes(8353..8354) }, Literal { lit: 0, span: bytes(8355..8356) }], span: bytes(8317..8357) }], span: bytes(8302..8358) }, Punct { char: ';', spacing: Alone, span: bytes(8358..8359) }, Ident { sym: if, span: bytes(8425..8427) }, Ident { sym: let, span: bytes(8428..8431) }, Ident { sym: Some, span: bytes(8432..8436) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: file_sections, span: bytes(8437..8450) }], span: bytes(8436..8451) }, Punct { char: '=', spacing: Alone, span: bytes(8452..8453) }, Ident { sym: file_tree, span: bytes(8454..8463) }, Punct { char: '.', spacing: Alone, span: bytes(8463..8464) }, Ident { sym: get, span: bytes(8464..8467) }, Group { delimiter: Parenthesis, stream: TokenStream [Punct { char: '&', spacing: Alone, span: bytes(8468..8469) }, Ident { sym: path_str, span: bytes(8469..8477) }], span: bytes(8467..8478) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: for, span: bytes(8501..8504) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: idx, span: bytes(8506..8509) }, Punct { char: ',', spacing: Alone, span: bytes(8509..8510) }, Ident { sym: section, span: bytes(8511..8518) }], span: bytes(8505..8519) }, Ident { sym: in, span: bytes(8520..8522) }, Ident { sym: file_sections, span: bytes(8523..8536) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: nodes, span: bytes(8563..8568) }, Punct { char: '.', spacing: Alone, span: bytes(8568..8569) }, Ident { sym: push, span: bytes(8569..8573) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: TreeNode, span: bytes(8574..8582) }, Punct { char: ':', spacing: Joint, span: bytes(8582..8583) }, Punct { char: ':', spacing: Alone, span: bytes(8583..8584) }, Ident { sym: section, span: bytes(8584..8591) }, Group { delimiter: Parenthesis, stream: TokenStream [Group { delimiter: Parenthesis, stream: TokenStream [Punct { char: '*', spacing: Alone, span: bytes(8593..8594) }, Ident { sym: section, span: bytes(8594..8601) }], span: bytes(8592..8602) }, Punct { char: '.', spacing: Alone, span: bytes(8602..8603) }, Ident { sym: clone, span: bytes(8603..8608) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(8608..8610) }, Punct { char: ',', spacing: Alone, span: bytes(8610..8611) }, Ident { sym: section, span: bytes(8612..8619) }, Punct { char: '.', spacing: Alone, span: bytes(8619..8620) }, Ident { sym: level, span: bytes(8620..8625) }, Punct { char: ',', spacing: Alone, span: bytes(8625..8626) }, Punct { char: '*', spacing: Alone, span: bytes(8627..8628) }, Ident { sym: idx, span: bytes(8628..8631) }], span: bytes(8591..8632) }], span: bytes(8573..8633) }, Punct { char: ';', spacing: Alone, span: bytes(8633..8634) }], span: bytes(8537..8656) }], span: bytes(8479..8674) }], span: bytes(7984..8688) }], span: bytes(7329..8698) }, Ident { sym: nodes, span: bytes(8708..8713) }], span: bytes(4053..8719) }) })
[SYNCDOC DEBUG] Processing item type: Function
[SYNCDOC DEBUG] Processing item: Function(FnSig { attributes: Some(Repeats<1, 18446744073709551615, syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing>([Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: doc, span: bytes(8725..8782) }, Punct { char: '=', spacing: Alone, span: bytes(8725..8782) }, Literal { lit: " Rebuild tree after sections change (e.g., after save)", span: bytes(8725..8782) }], span: bytes(8725..8782) }) }, delimiter: Some(Nothing) }])), visibility: Some(Public(KPub(Cached<proc_macro2::Ident> { value: Ident { sym: pub, span: bytes(8787..8790) }, string: "pub" }))), const_kw: None, async_kw: None, unsafe_kw: None, extern_kw: None, _fn: KFn(Cached<proc_macro2::Ident> { value: Ident { sym: fn, span: bytes(8791..8793) }, string: "fn" }), name: Ident { sym: rebuild_tree, span: bytes(8794..8806) }, generics: None, params: ParenthesisGroupContaining < core::option::Option<unsynn::container::DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>>>(Some(DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>([Delimited<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>> { value: SelfParam(RefMut(Cons<unsynn::operator::Operator<'&'>, unsynn::combinator::Cons<syncdoc_core::parse::KMut, syncdoc_core::parse::KSelf>> { first: Operator<'&'>, second: Cons<syncdoc_core::parse::KMut, syncdoc_core::parse::KSelf> { first: KMut(Cached<proc_macro2::Ident> { value: Ident { sym: mut, span: bytes(8808..8811) }, string: "mut" }), second: KSelf(Cached<proc_macro2::Ident> { value: Ident { sym: self, span: bytes(8812..8816) }, string: "self" }) } })), delimiter: None }]))), return_type: None, where_clause: None, body: BraceGroup(Group { delimiter: Brace, stream: TokenStream [Ident { sym: self, span: bytes(8828..8832) }, Punct { char: '.', spacing: Alone, span: bytes(8832..8833) }, Ident { sym: tree_nodes, span: bytes(8833..8843) }, Punct { char: '=', spacing: Alone, span: bytes(8844..8845) }, Ident { sym: Self, span: bytes(8846..8850) }, Punct { char: ':', spacing: Joint, span: bytes(8850..8851) }, Punct { char: ':', spacing: Alone, span: bytes(8851..8852) }, Ident { sym: build_tree, span: bytes(8852..8862) }, Group { delimiter: Parenthesis, stream: TokenStream [Punct { char: '&', spacing: Alone, span: bytes(8863..8864) }, Ident { sym: self, span: bytes(8864..8868) }, Punct { char: '.', spacing: Alone, span: bytes(8868..8869) }, Ident { sym: files, span: bytes(8869..8874) }, Punct { char: ',', spacing: Alone, span: bytes(8874..8875) }, Punct { char: '&', spacing: Alone, span: bytes(8876..8877) }, Ident { sym: self, span: bytes(8877..8881) }, Punct { char: '.', spacing: Alone, span: bytes(8881..8882) }, Ident { sym: sections, span: bytes(8882..8890) }], span: bytes(8862..8891) }, Punct { char: ';', spacing: Alone, span: bytes(8891..8892) }, Ident { sym: if, span: bytes(8970..8972) }, Ident { sym: let, span: bytes(8973..8976) }, Ident { sym: Some, span: bytes(8977..8981) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: current_section_idx, span: bytes(8982..9001) }], span: bytes(8981..9002) }, Punct { char: '=', spacing: Alone, span: bytes(9003..9004) }, Ident { sym: self, span: bytes(9005..9009) }, Punct { char: '.', spacing: Alone, span: bytes(9009..9010) }, Ident { sym: get_current_section_index, span: bytes(9010..9035) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(9035..9037) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: if, span: bytes(9052..9054) }, Ident { sym: let, span: bytes(9055..9058) }, Ident { sym: Some, span: bytes(9059..9063) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: node_idx, span: bytes(9064..9072) }], span: bytes(9063..9073) }, Punct { char: '=', spacing: Alone, span: bytes(9074..9075) }, Ident { sym: self, span: bytes(9076..9080) }, Punct { char: '.', spacing: Alone, span: bytes(9097..9098) }, Ident { sym: tree_nodes, span: bytes(9098..9108) }, Punct { char: '.', spacing: Alone, span: bytes(9125..9126) }, Ident { sym: iter, span: bytes(9126..9130) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(9130..9132) }, Punct { char: '.', spacing: Alone, span: bytes(9149..9150) }, Ident { sym: position, span: bytes(9150..9158) }, Group { delimiter: Parenthesis, stream: TokenStream [Punct { char: '|', spacing: Alone, span: bytes(9159..9160) }, Ident { sym: n, span: bytes(9160..9161) }, Punct { char: '|', spacing: Alone, span: bytes(9161..9162) }, Ident { sym: n, span: bytes(9163..9164) }, Punct { char: '.', spacing: Alone, span: bytes(9164..9165) }, Ident { sym: section_index, span: bytes(9165..9178) }, Punct { char: '=', spacing: Joint, span: bytes(9179..9180) }, Punct { char: '=', spacing: Alone, span: bytes(9180..9181) }, Ident { sym: Some, span: bytes(9182..9186) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: current_section_idx, span: bytes(9187..9206) }], span: bytes(9186..9207) }], span: bytes(9158..9208) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: self, span: bytes(9239..9243) }, Punct { char: '.', spacing: Alone, span: bytes(9243..9244) }, Ident { sym: current_node_index, span: bytes(9244..9262) }, Punct { char: '=', spacing: Alone, span: bytes(9263..9264) }, Ident { sym: node_idx, span: bytes(9265..9273) }, Punct { char: ';', spacing: Alone, span: bytes(9273..9274) }], span: bytes(9221..9288) }], span: bytes(9038..9298) }], span: bytes(8818..9304) }) })
[SYNCDOC DEBUG] Processing item type: Function
[SYNCDOC DEBUG] Processing item: Function(FnSig { attributes: Some(Repeats<1, 18446744073709551615, syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing>([Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: doc, span: bytes(9310..9387) }, Punct { char: '=', spacing: Alone, span: bytes(9310..9387) }, Literal { lit: " Get the section index for the currently selected node (if it's a section)", span: bytes(9310..9387) }], span: bytes(9310..9387) }) }, delimiter: Some(Nothing) }, Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: must_use, span: bytes(9394..9402) }], span: bytes(9393..9403) }) }, delimiter: Some(Nothing) }])), visibility: Some(Public(KPub(Cached<proc_macro2::Ident> { value: Ident { sym: pub, span: bytes(9408..9411) }, string: "pub" }))), const_kw: None, async_kw: None, unsafe_kw: None, extern_kw: None, _fn: KFn(Cached<proc_macro2::Ident> { value: Ident { sym: fn, span: bytes(9412..9414) }, string: "fn" }), name: Ident { sym: get_current_section_index, span: bytes(9415..9440) }, generics: None, params: ParenthesisGroupContaining < core::option::Option<unsynn::container::DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>>>(Some(DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>([Delimited<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>> { value: SelfParam(Ref(Cons<unsynn::operator::Operator<'&'>, syncdoc_core::parse::KSelf> { first: Operator<'&'>, second: KSelf(Cached<proc_macro2::Ident> { value: Ident { sym: self, span: bytes(9442..9446) }, string: "self" }) })), delimiter: None }]))), return_type: Some(ReturnTypeFn { _arrow: Operator<'->'>, return_type: Repeats<1, 18446744073709551615, unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing>([Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::group::BraceGroup>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Ident { sym: Option, span: bytes(9451..9457) })) }, delimiter: Some(Nothing) }, Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::group::BraceGroup>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>> { first: Operator<'<'>, second: [Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::operator::Operator<'>'>>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Ident { sym: usize, span: bytes(9458..9463) })) }], third: Operator<'>'> })) }, delimiter: Some(Nothing) }]) }), where_clause: None, body: BraceGroup(Group { delimiter: Brace, stream: TokenStream [Ident { sym: if, span: bytes(9475..9477) }, Ident { sym: self, span: bytes(9478..9482) }, Punct { char: '.', spacing: Alone, span: bytes(9482..9483) }, Ident { sym: current_node_index, span: bytes(9483..9501) }, Punct { char: '<', spacing: Alone, span: bytes(9502..9503) }, Ident { sym: self, span: bytes(9504..9508) }, Punct { char: '.', spacing: Alone, span: bytes(9508..9509) }, Ident { sym: tree_nodes, span: bytes(9509..9519) }, Punct { char: '.', spacing: Alone, span: bytes(9519..9520) }, Ident { sym: len, span: bytes(9520..9523) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(9523..9525) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: self, span: bytes(9540..9544) }, Punct { char: '.', spacing: Alone, span: bytes(9544..9545) }, Ident { sym: tree_nodes, span: bytes(9545..9555) }, Group { delimiter: Bracket, stream: TokenStream [Ident { sym: self, span: bytes(9556..9560) }, Punct { char: '.', spacing: Alone, span: bytes(9560..9561) }, Ident { sym: current_node_index, span: bytes(9561..9579) }], span: bytes(9555..9580) }, Punct { char: '.', spacing: Alone, span: bytes(9580..9581) }, Ident { sym: section_index, span: bytes(9581..9594) }], span: bytes(9526..9604) }, Ident { sym: else, span: bytes(9605..9609) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: None, span: bytes(9624..9628) }], span: bytes(9610..9638) }], span: bytes(9465..9644) }) })
[SYNCDOC DEBUG] Processing item type: Function
[SYNCDOC DEBUG] Processing item: Function(FnSig { attributes: Some(Repeats<1, 18446744073709551615, syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing>([Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: doc, span: bytes(9650..9700) }, Punct { char: '=', spacing: Alone, span: bytes(9650..9700) }, Literal { lit: " Get the current section (if on a section node)", span: bytes(9650..9700) }], span: bytes(9650..9700) }) }, delimiter: Some(Nothing) }, Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: must_use, span: bytes(9707..9715) }], span: bytes(9706..9716) }) }, delimiter: Some(Nothing) }])), visibility: Some(Public(KPub(Cached<proc_macro2::Ident> { value: Ident { sym: pub, span: bytes(9721..9724) }, string: "pub" }))), const_kw: None, async_kw: None, unsafe_kw: None, extern_kw: None, _fn: KFn(Cached<proc_macro2::Ident> { value: Ident { sym: fn, span: bytes(9725..9727) }, string: "fn" }), name: Ident { sym: get_current_section, span: bytes(9728..9747) }, generics: None, params: ParenthesisGroupContaining < core::option::Option<unsynn::container::DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>>>(Some(DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>([Delimited<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>> { value: SelfParam(Ref(Cons<unsynn::operator::Operator<'&'>, syncdoc_core::parse::KSelf> { first: Operator<'&'>, second: KSelf(Cached<proc_macro2::Ident> { value: Ident { sym: self, span: bytes(9749..9753) }, string: "self" }) })), delimiter: None }]))), return_type: Some(ReturnTypeFn { _arrow: Operator<'->'>, return_type: Repeats<1, 18446744073709551615, unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing>([Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::group::BraceGroup>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Ident { sym: Option, span: bytes(9758..9764) })) }, delimiter: Some(Nothing) }, Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::group::BraceGroup>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>> { first: Operator<'<'>, second: [Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::operator::Operator<'>'>>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Punct { char: '&', spacing: Alone, span: bytes(9765..9766) })) }, Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::operator::Operator<'>'>>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Ident { sym: Section, span: bytes(9766..9773) })) }], third: Operator<'>'> })) }, delimiter: Some(Nothing) }]) }), where_clause: None, body: BraceGroup(Group { delimiter: Brace, stream: TokenStream [Ident { sym: self, span: bytes(9785..9789) }, Punct { char: '.', spacing: Alone, span: bytes(9789..9790) }, Ident { sym: get_current_section_index, span: bytes(9790..9815) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(9815..9817) }, Punct { char: '.', spacing: Alone, span: bytes(9830..9831) }, Ident { sym: and_then, span: bytes(9831..9839) }, Group { delimiter: Parenthesis, stream: TokenStream [Punct { char: '|', spacing: Alone, span: bytes(9840..9841) }, Ident { sym: idx, span: bytes(9841..9844) }, Punct { char: '|', spacing: Alone, span: bytes(9844..9845) }, Ident { sym: self, span: bytes(9846..9850) }, Punct { char: '.', spacing: Alone, span: bytes(9850..9851) }, Ident { sym: sections, span: bytes(9851..9859) }, Punct { char: '.', spacing: Alone, span: bytes(9859..9860) }, Ident { sym: get, span: bytes(9860..9863) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: idx, span: bytes(9864..9867) }], span: bytes(9863..9868) }], span: bytes(9839..9869) }], span: bytes(9775..9875) }) })
[SYNCDOC DEBUG] Processing item type: Function
[SYNCDOC DEBUG] Processing item: Function(FnSig { attributes: None, visibility: None, const_kw: None, async_kw: None, unsafe_kw: None, extern_kw: None, _fn: KFn(Cached<proc_macro2::Ident> { value: Ident { sym: fn, span: bytes(9881..9883) }, string: "fn" }), name: Ident { sym: rebuild_file_offsets, span: bytes(9884..9904) }, generics: None, params: ParenthesisGroupContaining < core::option::Option<unsynn::container::DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>>>(Some(DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>([Delimited<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>> { value: SelfParam(RefMut(Cons<unsynn::operator::Operator<'&'>, unsynn::combinator::Cons<syncdoc_core::parse::KMut, syncdoc_core::parse::KSelf>> { first: Operator<'&'>, second: Cons<syncdoc_core::parse::KMut, syncdoc_core::parse::KSelf> { first: KMut(Cached<proc_macro2::Ident> { value: Ident { sym: mut, span: bytes(9906..9909) }, string: "mut" }), second: KSelf(Cached<proc_macro2::Ident> { value: Ident { sym: self, span: bytes(9910..9914) }, string: "self" }) } })), delimiter: None }]))), return_type: None, where_clause: None, body: BraceGroup(Group { delimiter: Brace, stream: TokenStream [Ident { sym: self, span: bytes(9926..9930) }, Punct { char: '.', spacing: Alone, span: bytes(9930..9931) }, Ident { sym: file_offsets, span: bytes(9931..9943) }, Punct { char: '.', spacing: Alone, span: bytes(9943..9944) }, Ident { sym: clear, span: bytes(9944..9949) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(9949..9951) }, Punct { char: ';', spacing: Alone, span: bytes(9951..9952) }, Ident { sym: if, span: bytes(9962..9964) }, Ident { sym: let, span: bytes(9965..9968) }, Ident { sym: Some, span: bytes(9969..9973) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: section_idx, span: bytes(9974..9985) }], span: bytes(9973..9986) }, Punct { char: '=', spacing: Alone, span: bytes(9987..9988) }, Ident { sym: self, span: bytes(9989..9993) }, Punct { char: '.', spacing: Alone, span: bytes(9993..9994) }, Ident { sym: get_current_section_index, span: bytes(9994..10019) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(10019..10021) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: if, span: bytes(10036..10038) }, Ident { sym: let, span: bytes(10039..10042) }, Ident { sym: Some, span: bytes(10043..10047) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: section, span: bytes(10048..10055) }], span: bytes(10047..10056) }, Punct { char: '=', spacing: Alone, span: bytes(10057..10058) }, Ident { sym: self, span: bytes(10059..10063) }, Punct { char: '.', spacing: Alone, span: bytes(10063..10064) }, Ident { sym: sections, span: bytes(10064..10072) }, Punct { char: '.', spacing: Alone, span: bytes(10072..10073) }, Ident { sym: get, span: bytes(10073..10076) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: section_idx, span: bytes(10077..10088) }], span: bytes(10076..10089) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: let, span: bytes(10108..10111) }, Ident { sym: lines_added, span: bytes(10112..10123) }, Punct { char: '=', spacing: Alone, span: bytes(10124..10125) }, Ident { sym: self, span: bytes(10126..10130) }, Punct { char: '.', spacing: Alone, span: bytes(10130..10131) }, Ident { sym: editor_state, span: bytes(10131..10143) }, Punct { char: '.', spacing: Alone, span: bytes(10143..10144) }, Ident { sym: as_ref, span: bytes(10144..10150) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(10150..10152) }, Punct { char: '.', spacing: Alone, span: bytes(10152..10153) }, Ident { sym: map_or, span: bytes(10153..10159) }, Group { delimiter: Parenthesis, stream: TokenStream [Literal { lit: 0, span: bytes(10160..10161) }, Punct { char: ',', spacing: Alone, span: bytes(10161..10162) }, Punct { char: '|', spacing: Alone, span: bytes(10163..10164) }, Ident { sym: es, span: bytes(10164..10166) }, Punct { char: '|', spacing: Alone, span: bytes(10166..10167) }, Ident { sym: es, span: bytes(10168..10170) }, Punct { char: '.', spacing: Alone, span: bytes(10170..10171) }, Ident { sym: lines, span: bytes(10171..10176) }, Punct { char: '.', spacing: Alone, span: bytes(10176..10177) }, Ident { sym: len, span: bytes(10177..10180) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(10180..10182) }], span: bytes(10159..10183) }, Punct { char: ';', spacing: Alone, span: bytes(10183..10184) }, Ident { sym: let, span: bytes(10202..10205) }, Ident { sym: file_map, span: bytes(10206..10214) }, Punct { char: '=', spacing: Alone, span: bytes(10215..10216) }, Ident { sym: self, span: bytes(10217..10221) }, Punct { char: '.', spacing: Alone, span: bytes(10242..10243) }, Ident { sym: file_offsets, span: bytes(10243..10255) }, Punct { char: '.', spacing: Alone, span: bytes(10276..10277) }, Ident { sym: entry, span: bytes(10277..10282) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: section, span: bytes(10283..10290) }, Punct { char: '.', spacing: Alone, span: bytes(10290..10291) }, Ident { sym: file_path, span: bytes(10291..10300) }, Punct { char: '.', spacing: Alone, span: bytes(10300..10301) }, Ident { sym: clone, span: bytes(10301..10306) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(10306..10308) }], span: bytes(10282..10309) }, Punct { char: '.', spacing: Alone, span: bytes(10330..10331) }, Ident { sym: or_default, span: bytes(10331..10341) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(10341..10343) }, Punct { char: ';', spacing: Alone, span: bytes(10343..10344) }, Ident { sym: file_map, span: bytes(10362..10370) }, Punct { char: '.', spacing: Alone, span: bytes(10370..10371) }, Ident { sym: insert, span: bytes(10371..10377) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: section, span: bytes(10378..10385) }, Punct { char: '.', spacing: Alone, span: bytes(10385..10386) }, Ident { sym: line_start, span: bytes(10386..10396) }, Punct { char: ',', spacing: Alone, span: bytes(10396..10397) }, Ident { sym: lines_added, span: bytes(10398..10409) }], span: bytes(10377..10410) }, Punct { char: ';', spacing: Alone, span: bytes(10410..10411) }], span: bytes(10090..10425) }], span: bytes(10022..10435) }], span: bytes(9916..10441) }) })
[SYNCDOC DEBUG] Processing item type: Function
[SYNCDOC DEBUG] Processing item: Function(FnSig { attributes: Some(Repeats<1, 18446744073709551615, syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing>([Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: doc, span: bytes(10447..10533) }, Punct { char: '=', spacing: Alone, span: bytes(10447..10533) }, Literal { lit: " Calculates total lines added before a section to determine correct write position.", span: bytes(10447..10533) }], span: bytes(10447..10533) }) }, delimiter: Some(Nothing) }, Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: must_use, span: bytes(10540..10548) }], span: bytes(10539..10549) }) }, delimiter: Some(Nothing) }])), visibility: Some(Public(KPub(Cached<proc_macro2::Ident> { value: Ident { sym: pub, span: bytes(10554..10557) }, string: "pub" }))), const_kw: None, async_kw: None, unsafe_kw: None, extern_kw: None, _fn: KFn(Cached<proc_macro2::Ident> { value: Ident { sym: fn, span: bytes(10558..10560) }, string: "fn" }), name: Ident { sym: cumulative_offset, span: bytes(10561..10578) }, generics: None, params: ParenthesisGroupContaining < core::option::Option<unsynn::container::DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>>>(Some(DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>([Delimited<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>> { value: SelfParam(Ref(Cons<unsynn::operator::Operator<'&'>, syncdoc_core::parse::KSelf> { first: Operator<'&'>, second: KSelf(Cached<proc_macro2::Ident> { value: Ident { sym: self, span: bytes(10580..10584) }, string: "self" }) })), delimiter: Some(Operator<','>) }, Delimited<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>> { value: Named(NamedParam { mut_kw: None, name: Ident { sym: index, span: bytes(10586..10591) }, _colon: Operator<':'>, param_type: Repeats<1, 18446744073709551615, unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<','>>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing>([Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<','>>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::operator::Operator<','>>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::operator::Operator<','>>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Ident { sym: usize, span: bytes(10593..10598) })) }, delimiter: Some(Nothing) }]) }), delimiter: None }]))), return_type: Some(ReturnTypeFn { _arrow: Operator<'->'>, return_type: Repeats<1, 18446744073709551615, unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing>([Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::group::BraceGroup>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Ident { sym: usize, span: bytes(10603..10608) })) }, delimiter: Some(Nothing) }]) }), where_clause: None, body: BraceGroup(Group { delimiter: Brace, stream: TokenStream [Ident { sym: let, span: bytes(10619..10622) }, Ident { sym: section, span: bytes(10623..10630) }, Punct { char: '=', spacing: Alone, span: bytes(10631..10632) }, Punct { char: '&', spacing: Alone, span: bytes(10633..10634) }, Ident { sym: self, span: bytes(10634..10638) }, Punct { char: '.', spacing: Alone, span: bytes(10638..10639) }, Ident { sym: sections, span: bytes(10639..10647) }, Group { delimiter: Bracket, stream: TokenStream [Ident { sym: index, span: bytes(10648..10653) }], span: bytes(10647..10654) }, Punct { char: ';', spacing: Alone, span: bytes(10654..10655) }, Ident { sym: let, span: bytes(10664..10667) }, Ident { sym: target_file, span: bytes(10668..10679) }, Punct { char: '=', spacing: Alone, span: bytes(10680..10681) }, Punct { char: '&', spacing: Alone, span: bytes(10682..10683) }, Ident { sym: section, span: bytes(10683..10690) }, Punct { char: '.', spacing: Alone, span: bytes(10690..10691) }, Ident { sym: file_path, span: bytes(10691..10700) }, Punct { char: ';', spacing: Alone, span: bytes(10700..10701) }, Ident { sym: let, span: bytes(10710..10713) }, Ident { sym: target_line, span: bytes(10714..10725) }, Punct { char: '=', spacing: Alone, span: bytes(10726..10727) }, Ident { sym: section, span: bytes(10728..10735) }, Punct { char: '.', spacing: Alone, span: bytes(10735..10736) }, Ident { sym: line_start, span: bytes(10736..10746) }, Punct { char: ';', spacing: Alone, span: bytes(10746..10747) }, Ident { sym: if, span: bytes(10757..10759) }, Ident { sym: let, span: bytes(10760..10763) }, Ident { sym: Some, span: bytes(10764..10768) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: file_map, span: bytes(10769..10777) }], span: bytes(10768..10778) }, Punct { char: '=', spacing: Alone, span: bytes(10779..10780) }, Ident { sym: self, span: bytes(10781..10785) }, Punct { char: '.', spacing: Alone, span: bytes(10785..10786) }, Ident { sym: file_offsets, span: bytes(10786..10798) }, Punct { char: '.', spacing: Alone, span: bytes(10798..10799) }, Ident { sym: get, span: bytes(10799..10802) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: target_file, span: bytes(10803..10814) }], span: bytes(10802..10815) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: file_map, span: bytes(10830..10838) }, Punct { char: '.', spacing: Alone, span: bytes(10855..10856) }, Ident { sym: iter, span: bytes(10856..10860) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(10860..10862) }, Punct { char: '.', spacing: Alone, span: bytes(10879..10880) }, Ident { sym: filter, span: bytes(10880..10886) }, Group { delimiter: Parenthesis, stream: TokenStream [Punct { char: '|', spacing: Alone, span: bytes(10887..10888) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: line, span: bytes(10889..10893) }, Punct { char: ',', spacing: Alone, span: bytes(10893..10894) }, Ident { sym: _, span: bytes(10895..10896) }], span: bytes(10888..10897) }, Punct { char: '|', spacing: Alone, span: bytes(10897..10898) }, Punct { char: '*', spacing: Joint, span: bytes(10899..10900) }, Punct { char: '*', spacing: Alone, span: bytes(10900..10901) }, Ident { sym: line, span: bytes(10901..10905) }, Punct { char: '<', spacing: Alone, span: bytes(10906..10907) }, Ident { sym: target_line, span: bytes(10908..10919) }], span: bytes(10886..10920) }, Punct { char: '.', spacing: Alone, span: bytes(10937..10938) }, Ident { sym: map, span: bytes(10938..10941) }, Group { delimiter: Parenthesis, stream: TokenStream [Punct { char: '|', spacing: Alone, span: bytes(10942..10943) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: _, span: bytes(10944..10945) }, Punct { char: ',', spacing: Alone, span: bytes(10945..10946) }, Ident { sym: offset, span: bytes(10947..10953) }], span: bytes(10943..10954) }, Punct { char: '|', spacing: Alone, span: bytes(10954..10955) }, Ident { sym: offset, span: bytes(10956..10962) }], span: bytes(10941..10963) }, Punct { char: '.', spacing: Alone, span: bytes(10980..10981) }, Ident { sym: sum, span: bytes(10981..10984) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(10984..10986) }], span: bytes(10816..10996) }, Ident { sym: else, span: bytes(10997..11001) }, Group { delimiter: Brace, stream: TokenStream [Literal { lit: 0, span: bytes(11016..11017) }], span: bytes(11002..11027) }], span: bytes(10609..11033) }) })
[SYNCDOC DEBUG] Processing item type: Function
[SYNCDOC DEBUG] Processing item: Function(FnSig { attributes: Some(Repeats<1, 18446744073709551615, syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing>([Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: doc, span: bytes(11039..11101) }, Punct { char: '=', spacing: Alone, span: bytes(11039..11101) }, Literal { lit: " Restores previously edited content from a saved edit plan.", span: bytes(11039..11101) }], span: bytes(11039..11101) }) }, delimiter: Some(Nothing) }])), visibility: Some(Public(KPub(Cached<proc_macro2::Ident> { value: Ident { sym: pub, span: bytes(11106..11109) }, string: "pub" }))), const_kw: None, async_kw: None, unsafe_kw: None, extern_kw: None, _fn: KFn(Cached<proc_macro2::Ident> { value: Ident { sym: fn, span: bytes(11110..11112) }, string: "fn" }), name: Ident { sym: load_docs, span: bytes(11113..11122) }, generics: None, params: ParenthesisGroupContaining < core::option::Option<unsynn::container::DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>>>(Some(DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>([Delimited<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>> { value: SelfParam(RefMut(Cons<unsynn::operator::Operator<'&'>, unsynn::combinator::Cons<syncdoc_core::parse::KMut, syncdoc_core::parse::KSelf>> { first: Operator<'&'>, second: Cons<syncdoc_core::parse::KMut, syncdoc_core::parse::KSelf> { first: KMut(Cached<proc_macro2::Ident> { value: Ident { sym: mut, span: bytes(11124..11127) }, string: "mut" }), second: KSelf(Cached<proc_macro2::Ident> { value: Ident { sym: self, span: bytes(11128..11132) }, string: "self" }) } })), delimiter: Some(Operator<','>) }, Delimited<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>> { value: Named(NamedParam { mut_kw: None, name: Ident { sym: plan, span: bytes(11134..11138) }, _colon: Operator<':'>, param_type: Repeats<1, 18446744073709551615, unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<','>>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing>([Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<','>>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::operator::Operator<','>>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::operator::Operator<','>>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Ident { sym: EditPlan, span: bytes(11140..11148) })) }, delimiter: Some(Nothing) }]) }), delimiter: None }]))), return_type: None, where_clause: None, body: BraceGroup(Group { delimiter: Brace, stream: TokenStream [Ident { sym: let, span: bytes(11160..11163) }, Ident { sym: mut, span: bytes(11164..11167) }, Ident { sym: doc_map, span: bytes(11168..11175) }, Punct { char: ':', spacing: Alone, span: bytes(11175..11176) }, Ident { sym: HashMap, span: bytes(11177..11184) }, Punct { char: '<', spacing: Alone, span: bytes(11184..11185) }, Ident { sym: String, span: bytes(11185..11191) }, Punct { char: ',', spacing: Alone, span: bytes(11191..11192) }, Ident { sym: Vec, span: bytes(11193..11196) }, Punct { char: '<', spacing: Alone, span: bytes(11196..11197) }, Ident { sym: String, span: bytes(11197..11203) }, Punct { char: '>', spacing: Joint, span: bytes(11203..11204) }, Punct { char: '>', spacing: Alone, span: bytes(11204..11205) }, Punct { char: '=', spacing: Alone, span: bytes(11206..11207) }, Ident { sym: HashMap, span: bytes(11208..11215) }, Punct { char: ':', spacing: Joint, span: bytes(11215..11216) }, Punct { char: ':', spacing: Alone, span: bytes(11216..11217) }, Ident { sym: new, span: bytes(11217..11220) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(11220..11222) }, Punct { char: ';', spacing: Alone, span: bytes(11222..11223) }, Ident { sym: for, span: bytes(11232..11235) }, Ident { sym: edit, span: bytes(11236..11240) }, Ident { sym: in, span: bytes(11241..11243) }, Ident { sym: plan, span: bytes(11244..11248) }, Punct { char: '.', spacing: Alone, span: bytes(11248..11249) }, Ident { sym: edits, span: bytes(11249..11254) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: let, span: bytes(11269..11272) }, Ident { sym: key, span: bytes(11273..11276) }, Punct { char: '=', spacing: Alone, span: bytes(11277..11278) }, Ident { sym: format, span: bytes(11279..11285) }, Punct { char: '!', spacing: Alone, span: bytes(11285..11286) }, Group { delimiter: Parenthesis, stream: TokenStream [Literal { lit: "{}:{}:{}", span: bytes(11304..11314) }, Punct { char: ',', spacing: Alone, span: bytes(11314..11315) }, Ident { sym: edit, span: bytes(11332..11336) }, Punct { char: '.', spacing: Alone, span: bytes(11336..11337) }, Ident { sym: file_name, span: bytes(11337..11346) }, Punct { char: ',', spacing: Alone, span: bytes(11346..11347) }, Ident { sym: edit, span: bytes(11348..11352) }, Punct { char: '.', spacing: Alone, span: bytes(11352..11353) }, Ident { sym: line_start, span: bytes(11353..11363) }, Punct { char: ',', spacing: Alone, span: bytes(11363..11364) }, Ident { sym: edit, span: bytes(11365..11369) }, Punct { char: '.', spacing: Alone, span: bytes(11369..11370) }, Ident { sym: column_start, span: bytes(11370..11382) }], span: bytes(11286..11396) }, Punct { char: ';', spacing: Alone, span: bytes(11396..11397) }, Ident { sym: let, span: bytes(11410..11413) }, Ident { sym: lines, span: bytes(11414..11419) }, Punct { char: ':', spacing: Alone, span: bytes(11419..11420) }, Ident { sym: Vec, span: bytes(11421..11424) }, Punct { char: '<', spacing: Alone, span: bytes(11424..11425) }, Ident { sym: String, span: bytes(11425..11431) }, Punct { char: '>', spacing: Alone, span: bytes(11431..11432) }, Punct { char: '=', spacing: Alone, span: bytes(11433..11434) }, Ident { sym: edit, span: bytes(11435..11439) }, Punct { char: '.', spacing: Alone, span: bytes(11456..11457) }, Ident { sym: section_content, span: bytes(11457..11472) }, Punct { char: '.', spacing: Alone, span: bytes(11489..11490) }, Ident { sym: lines, span: bytes(11490..11495) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(11495..11497) }, Punct { char: '.', spacing: Alone, span: bytes(11514..11515) }, Ident { sym: map, span: bytes(11515..11518) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: std, span: bytes(11519..11522) }, Punct { char: ':', spacing: Joint, span: bytes(11522..11523) }, Punct { char: ':', spacing: Alone, span: bytes(11523..11524) }, Ident { sym: string, span: bytes(11524..11530) }, Punct { char: ':', spacing: Joint, span: bytes(11530..11531) }, Punct { char: ':', spacing: Alone, span: bytes(11531..11532) }, Ident { sym: ToString, span: bytes(11532..11540) }, Punct { char: ':', spacing: Joint, span: bytes(11540..11541) }, Punct { char: ':', spacing: Alone, span: bytes(11541..11542) }, Ident { sym: to_string, span: bytes(11542..11551) }], span: bytes(11518..11552) }, Punct { char: '.', spacing: Alone, span: bytes(11569..11570) }, Ident { sym: collect, span: bytes(11570..11577) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(11577..11579) }, Punct { char: ';', spacing: Alone, span: bytes(11579..11580) }, Ident { sym: doc_map, span: bytes(11593..11600) }, Punct { char: '.', spacing: Alone, span: bytes(11600..11601) }, Ident { sym: insert, span: bytes(11601..11607) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: key, span: bytes(11608..11611) }, Punct { char: ',', spacing: Alone, span: bytes(11611..11612) }, Ident { sym: lines, span: bytes(11613..11618) }], span: bytes(11607..11619) }, Punct { char: ';', spacing: Alone, span: bytes(11619..11620) }], span: bytes(11255..11630) }, Ident { sym: for, span: bytes(11707..11710) }, Ident { sym: section, span: bytes(11711..11718) }, Ident { sym: in, span: bytes(11719..11721) }, Punct { char: '&', spacing: Alone, span: bytes(11722..11723) }, Ident { sym: mut, span: bytes(11723..11726) }, Ident { sym: self, span: bytes(11727..11731) }, Punct { char: '.', spacing: Alone, span: bytes(11731..11732) }, Ident { sym: sections, span: bytes(11732..11740) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: let, span: bytes(11755..11758) }, Ident { sym: key, span: bytes(11759..11762) }, Punct { char: '=', spacing: Alone, span: bytes(11763..11764) }, Ident { sym: format, span: bytes(11765..11771) }, Punct { char: '!', spacing: Alone, span: bytes(11771..11772) }, Group { delimiter: Parenthesis, stream: TokenStream [Literal { lit: "{}:{}:{}", span: bytes(11790..11800) }, Punct { char: ',', spacing: Alone, span: bytes(11800..11801) }, Ident { sym: section, span: bytes(11818..11825) }, Punct { char: '.', spacing: Alone, span: bytes(11825..11826) }, Ident { sym: file_path, span: bytes(11826..11835) }, Punct { char: ',', spacing: Alone, span: bytes(11835..11836) }, Ident { sym: section, span: bytes(11837..11844) }, Punct { char: '.', spacing: Alone, span: bytes(11844..11845) }, Ident { sym: line_start, span: bytes(11845..11855) }, Punct { char: ',', spacing: Alone, span: bytes(11855..11856) }, Ident { sym: section, span: bytes(11857..11864) }, Punct { char: '.', spacing: Alone, span: bytes(11864..11865) }, Ident { sym: column_start, span: bytes(11865..11877) }], span: bytes(11772..11891) }, Punct { char: ';', spacing: Alone, span: bytes(11891..11892) }, Ident { sym: if, span: bytes(11905..11907) }, Ident { sym: doc_map, span: bytes(11908..11915) }, Punct { char: '.', spacing: Alone, span: bytes(11915..11916) }, Ident { sym: contains_key, span: bytes(11916..11928) }, Group { delimiter: Parenthesis, stream: TokenStream [Punct { char: '&', spacing: Alone, span: bytes(11929..11930) }, Ident { sym: key, span: bytes(11930..11933) }], span: bytes(11928..11934) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: if, span: bytes(11953..11955) }, Ident { sym: let, span: bytes(11956..11959) }, Ident { sym: Ok, span: bytes(11960..11962) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: content, span: bytes(11963..11970) }], span: bytes(11962..11971) }, Punct { char: '=', spacing: Alone, span: bytes(11972..11973) }, Ident { sym: fs, span: bytes(11974..11976) }, Punct { char: ':', spacing: Joint, span: bytes(11976..11977) }, Punct { char: ':', spacing: Alone, span: bytes(11977..11978) }, Ident { sym: read_to_string, span: bytes(11978..11992) }, Group { delimiter: Parenthesis, stream: TokenStream [Punct { char: '&', spacing: Alone, span: bytes(11993..11994) }, Ident { sym: section, span: bytes(11994..12001) }, Punct { char: '.', spacing: Alone, span: bytes(12001..12002) }, Ident { sym: file_path, span: bytes(12002..12011) }], span: bytes(11992..12012) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: let, span: bytes(12035..12038) }, Ident { sym: bytes, span: bytes(12039..12044) }, Punct { char: '=', spacing: Alone, span: bytes(12045..12046) }, Ident { sym: content, span: bytes(12047..12054) }, Punct { char: '.', spacing: Alone, span: bytes(12054..12055) }, Ident { sym: as_bytes, span: bytes(12055..12063) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(12063..12065) }, Punct { char: ';', spacing: Alone, span: bytes(12065..12066) }, Ident { sym: if, span: bytes(12087..12089) }, Ident { sym: section, span: bytes(12090..12097) }, Punct { char: '.', spacing: Alone, span: bytes(12097..12098) }, Ident { sym: byte_start, span: bytes(12098..12108) }, Punct { char: '<', spacing: Alone, span: bytes(12109..12110) }, Ident { sym: bytes, span: bytes(12111..12116) }, Punct { char: '.', spacing: Alone, span: bytes(12116..12117) }, Ident { sym: len, span: bytes(12117..12120) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(12120..12122) }, Punct { char: '&', spacing: Joint, span: bytes(12123..12124) }, Punct { char: '&', spacing: Alone, span: bytes(12124..12125) }, Ident { sym: section, span: bytes(12126..12133) }, Punct { char: '.', spacing: Alone, span: bytes(12133..12134) }, Ident { sym: byte_end, span: bytes(12134..12142) }, Punct { char: '<', spacing: Joint, span: bytes(12143..12144) }, Punct { char: '=', spacing: Alone, span: bytes(12144..12145) }, Ident { sym: bytes, span: bytes(12146..12151) }, Punct { char: '.', spacing: Alone, span: bytes(12151..12152) }, Ident { sym: len, span: bytes(12152..12155) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(12155..12157) }, Group { delimiter: Brace, stream: TokenStream [], span: bytes(12158..12241) }], span: bytes(12013..12259) }], span: bytes(11935..12273) }], span: bytes(11741..12283) }], span: bytes(11150..12289) }) })
[SYNCDOC DEBUG] Processing item type: Function
[SYNCDOC DEBUG] Processing item: Function(FnSig { attributes: Some(Repeats<1, 18446744073709551615, syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing>([Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: doc, span: bytes(12295..12366) }, Punct { char: '=', spacing: Alone, span: bytes(12295..12366) }, Literal { lit: " Creates a serialisable plan capturing current editor modifications.", span: bytes(12295..12366) }], span: bytes(12295..12366) }) }, delimiter: Some(Nothing) }, Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: must_use, span: bytes(12373..12381) }], span: bytes(12372..12382) }) }, delimiter: Some(Nothing) }])), visibility: Some(Public(KPub(Cached<proc_macro2::Ident> { value: Ident { sym: pub, span: bytes(12387..12390) }, string: "pub" }))), const_kw: None, async_kw: None, unsafe_kw: None, extern_kw: None, _fn: KFn(Cached<proc_macro2::Ident> { value: Ident { sym: fn, span: bytes(12391..12393) }, string: "fn" }), name: Ident { sym: generate_edit_plan, span: bytes(12394..12412) }, generics: None, params: ParenthesisGroupContaining < core::option::Option<unsynn::container::DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>>>(Some(DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>([Delimited<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>> { value: SelfParam(Ref(Cons<unsynn::operator::Operator<'&'>, syncdoc_core::parse::KSelf> { first: Operator<'&'>, second: KSelf(Cached<proc_macro2::Ident> { value: Ident { sym: self, span: bytes(12414..12418) }, string: "self" }) })), delimiter: None }]))), return_type: Some(ReturnTypeFn { _arrow: Operator<'->'>, return_type: Repeats<1, 18446744073709551615, unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing>([Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::group::BraceGroup>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Ident { sym: EditPlan, span: bytes(12423..12431) })) }, delimiter: Some(Nothing) }]) }), where_clause: None, body: BraceGroup(Group { delimiter: Brace, stream: TokenStream [Ident { sym: let, span: bytes(12442..12445) }, Ident { sym: mut, span: bytes(12446..12449) }, Ident { sym: edits, span: bytes(12450..12455) }, Punct { char: '=', spacing: Alone, span: bytes(12456..12457) }, Ident { sym: Vec, span: bytes(12458..12461) }, Punct { char: ':', spacing: Joint, span: bytes(12461..12462) }, Punct { char: ':', spacing: Alone, span: bytes(12462..12463) }, Ident { sym: new, span: bytes(12463..12466) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(12466..12468) }, Punct { char: ';', spacing: Alone, span: bytes(12468..12469) }, Ident { sym: for, span: bytes(12479..12482) }, Ident { sym: section, span: bytes(12483..12490) }, Ident { sym: in, span: bytes(12491..12493) }, Punct { char: '&', spacing: Alone, span: bytes(12494..12495) }, Ident { sym: self, span: bytes(12495..12499) }, Punct { char: '.', spacing: Alone, span: bytes(12499..12500) }, Ident { sym: sections, span: bytes(12500..12508) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: if, span: bytes(12523..12525) }, Ident { sym: let, span: bytes(12526..12529) }, Ident { sym: Some, span: bytes(12530..12534) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: ref, span: bytes(12535..12538) }, Ident { sym: doc_lines, span: bytes(12539..12548) }], span: bytes(12534..12549) }, Punct { char: '=', spacing: Alone, span: bytes(12550..12551) }, Ident { sym: section, span: bytes(12552..12559) }, Punct { char: '.', spacing: Alone, span: bytes(12559..12560) }, Ident { sym: section_content, span: bytes(12560..12575) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: let, span: bytes(12594..12597) }, Ident { sym: section_content, span: bytes(12598..12613) }, Punct { char: '=', spacing: Alone, span: bytes(12614..12615) }, Ident { sym: doc_lines, span: bytes(12616..12625) }, Punct { char: '.', spacing: Alone, span: bytes(12625..12626) }, Ident { sym: join, span: bytes(12626..12630) }, Group { delimiter: Parenthesis, stream: TokenStream [Literal { lit: "\n", span: bytes(12631..12635) }], span: bytes(12630..12636) }, Punct { char: ';', spacing: Alone, span: bytes(12636..12637) }, Ident { sym: edits, span: bytes(12655..12660) }, Punct { char: '.', spacing: Alone, span: bytes(12660..12661) }, Ident { sym: push, span: bytes(12661..12665) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: Edit, span: bytes(12666..12670) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: file_name, span: bytes(12693..12702) }, Punct { char: ':', spacing: Alone, span: bytes(12702..12703) }, Ident { sym: section, span: bytes(12704..12711) }, Punct { char: '.', spacing: Alone, span: bytes(12711..12712) }, Ident { sym: file_path, span: bytes(12712..12721) }, Punct { char: '.', spacing: Alone, span: bytes(12721..12722) }, Ident { sym: clone, span: bytes(12722..12727) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(12727..12729) }, Punct { char: ',', spacing: Alone, span: bytes(12729..12730) }, Ident { sym: line_start, span: bytes(12751..12761) }, Punct { char: ':', spacing: Alone, span: bytes(12761..12762) }, Ident { sym: section, span: bytes(12763..12770) }, Punct { char: '.', spacing: Alone, span: bytes(12770..12771) }, Ident { sym: line_start, span: bytes(12771..12781) }, Punct { char: ',', spacing: Alone, span: bytes(12781..12782) }, Ident { sym: line_end, span: bytes(12803..12811) }, Punct { char: ':', spacing: Alone, span: bytes(12811..12812) }, Ident { sym: section, span: bytes(12813..12820) }, Punct { char: '.', spacing: Alone, span: bytes(12820..12821) }, Ident { sym: line_end, span: bytes(12821..12829) }, Punct { char: ',', spacing: Alone, span: bytes(12829..12830) }, Ident { sym: column_start, span: bytes(12851..12863) }, Punct { char: ':', spacing: Alone, span: bytes(12863..12864) }, Ident { sym: section, span: bytes(12865..12872) }, Punct { char: '.', spacing: Alone, span: bytes(12872..12873) }, Ident { sym: column_start, span: bytes(12873..12885) }, Punct { char: ',', spacing: Alone, span: bytes(12885..12886) }, Ident { sym: column_end, span: bytes(12907..12917) }, Punct { char: ':', spacing: Alone, span: bytes(12917..12918) }, Ident { sym: section, span: bytes(12919..12926) }, Punct { char: '.', spacing: Alone, span: bytes(12926..12927) }, Ident { sym: column_end, span: bytes(12927..12937) }, Punct { char: ',', spacing: Alone, span: bytes(12937..12938) }, Ident { sym: section_content, span: bytes(12959..12974) }, Punct { char: ',', spacing: Alone, span: bytes(12974..12975) }, Ident { sym: item_name, span: bytes(12996..13005) }, Punct { char: ':', spacing: Alone, span: bytes(13005..13006) }, Ident { sym: section, span: bytes(13007..13014) }, Punct { char: '.', spacing: Alone, span: bytes(13014..13015) }, Ident { sym: title, span: bytes(13015..13020) }, Punct { char: '.', spacing: Alone, span: bytes(13020..13021) }, Ident { sym: clone, span: bytes(13021..13026) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(13026..13028) }, Punct { char: ',', spacing: Alone, span: bytes(13028..13029) }], span: bytes(12671..13047) }], span: bytes(12665..13048) }, Punct { char: ';', spacing: Alone, span: bytes(13048..13049) }], span: bytes(12576..13063) }], span: bytes(12509..13073) }, Ident { sym: EditPlan, span: bytes(13083..13091) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: edits, span: bytes(13094..13099) }], span: bytes(13092..13101) }], span: bytes(12432..13107) }) })
[SYNCDOC DEBUG] Processing item type: Function
[SYNCDOC DEBUG] Processing item: Function(FnSig { attributes: Some(Repeats<1, 18446744073709551615, syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing>([Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: doc, span: bytes(13113..13171) }, Punct { char: '=', spacing: Alone, span: bytes(13113..13171) }, Literal { lit: " Loads selected section content into the editor buffer.", span: bytes(13113..13171) }], span: bytes(13113..13171) }) }, delimiter: Some(Nothing) }])), visibility: Some(Public(KPub(Cached<proc_macro2::Ident> { value: Ident { sym: pub, span: bytes(13176..13179) }, string: "pub" }))), const_kw: None, async_kw: None, unsafe_kw: None, extern_kw: None, _fn: KFn(Cached<proc_macro2::Ident> { value: Ident { sym: fn, span: bytes(13180..13182) }, string: "fn" }), name: Ident { sym: enter_detail_view, span: bytes(13183..13200) }, generics: None, params: ParenthesisGroupContaining < core::option::Option<unsynn::container::DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>>>(Some(DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>([Delimited<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>> { value: SelfParam(RefMut(Cons<unsynn::operator::Operator<'&'>, unsynn::combinator::Cons<syncdoc_core::parse::KMut, syncdoc_core::parse::KSelf>> { first: Operator<'&'>, second: Cons<syncdoc_core::parse::KMut, syncdoc_core::parse::KSelf> { first: KMut(Cached<proc_macro2::Ident> { value: Ident { sym: mut, span: bytes(13202..13205) }, string: "mut" }), second: KSelf(Cached<proc_macro2::Ident> { value: Ident { sym: self, span: bytes(13206..13210) }, string: "self" }) } })), delimiter: None }]))), return_type: None, where_clause: None, body: BraceGroup(Group { delimiter: Brace, stream: TokenStream [Ident { sym: let, span: bytes(13222..13225) }, Ident { sym: Some, span: bytes(13226..13230) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: section_idx, span: bytes(13231..13242) }], span: bytes(13230..13243) }, Punct { char: '=', spacing: Alone, span: bytes(13244..13245) }, Ident { sym: self, span: bytes(13246..13250) }, Punct { char: '.', spacing: Alone, span: bytes(13250..13251) }, Ident { sym: get_current_section_index, span: bytes(13251..13276) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(13276..13278) }, Ident { sym: else, span: bytes(13279..13283) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: return, span: bytes(13298..13304) }, Punct { char: ';', spacing: Alone, span: bytes(13304..13305) }], span: bytes(13284..13315) }, Punct { char: ';', spacing: Alone, span: bytes(13315..13316) }, Ident { sym: let, span: bytes(13326..13329) }, Ident { sym: section, span: bytes(13330..13337) }, Punct { char: '=', spacing: Alone, span: bytes(13338..13339) }, Punct { char: '&', spacing: Alone, span: bytes(13340..13341) }, Ident { sym: self, span: bytes(13341..13345) }, Punct { char: '.', spacing: Alone, span: bytes(13345..13346) }, Ident { sym: sections, span: bytes(13346..13354) }, Group { delimiter: Bracket, stream: TokenStream [Ident { sym: section_idx, span: bytes(13355..13366) }], span: bytes(13354..13367) }, Punct { char: ';', spacing: Alone, span: bytes(13367..13368) }, Ident { sym: if, span: bytes(13426..13428) }, Ident { sym: let, span: bytes(13429..13432) }, Ident { sym: Some, span: bytes(13433..13437) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: chunk_type, span: bytes(13438..13448) }], span: bytes(13437..13449) }, Punct { char: '=', spacing: Alone, span: bytes(13450..13451) }, Punct { char: '&', spacing: Alone, span: bytes(13452..13453) }, Ident { sym: section, span: bytes(13453..13460) }, Punct { char: '.', spacing: Alone, span: bytes(13460..13461) }, Ident { sym: chunk_type, span: bytes(13461..13471) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: let, span: bytes(13486..13489) }, Ident { sym: content, span: bytes(13490..13497) }, Punct { char: '=', spacing: Alone, span: bytes(13498..13499) }, Ident { sym: match, span: bytes(13500..13505) }, Ident { sym: chunk_type, span: bytes(13506..13516) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: ChunkType, span: bytes(13535..13544) }, Punct { char: ':', spacing: Joint, span: bytes(13544..13545) }, Punct { char: ':', spacing: Alone, span: bytes(13545..13546) }, Ident { sym: Added, span: bytes(13546..13551) }, Punct { char: '=', spacing: Joint, span: bytes(13552..13553) }, Punct { char: '>', spacing: Alone, span: bytes(13553..13554) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: section, span: bytes(13631..13638) }, Punct { char: '.', spacing: Alone, span: bytes(13638..13639) }, Ident { sym: rhs_content, span: bytes(13639..13650) }, Punct { char: '.', spacing: Alone, span: bytes(13650..13651) }, Ident { sym: clone, span: bytes(13651..13656) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(13656..13658) }, Punct { char: '.', spacing: Alone, span: bytes(13658..13659) }, Ident { sym: unwrap_or_default, span: bytes(13659..13676) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(13676..13678) }], span: bytes(13555..13696) }, Ident { sym: ChunkType, span: bytes(13713..13722) }, Punct { char: ':', spacing: Joint, span: bytes(13722..13723) }, Punct { char: ':', spacing: Alone, span: bytes(13723..13724) }, Ident { sym: Deleted, span: bytes(13724..13731) }, Punct { char: '=', spacing: Joint, span: bytes(13732..13733) }, Punct { char: '>', spacing: Alone, span: bytes(13733..13734) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: section, span: bytes(13830..13837) }, Punct { char: '.', spacing: Alone, span: bytes(13837..13838) }, Ident { sym: lhs_content, span: bytes(13838..13849) }, Punct { char: '.', spacing: Alone, span: bytes(13849..13850) }, Ident { sym: clone, span: bytes(13850..13855) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(13855..13857) }, Punct { char: '.', spacing: Alone, span: bytes(13857..13858) }, Ident { sym: unwrap_or_default, span: bytes(13858..13875) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(13875..13877) }], span: bytes(13735..13895) }, Ident { sym: ChunkType, span: bytes(13912..13921) }, Punct { char: ':', spacing: Joint, span: bytes(13921..13922) }, Punct { char: ':', spacing: Alone, span: bytes(13922..13923) }, Ident { sym: Modified, span: bytes(13923..13931) }, Punct { char: '=', spacing: Joint, span: bytes(13932..13933) }, Punct { char: '>', spacing: Alone, span: bytes(13933..13934) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: let, span: bytes(14016..14019) }, Ident { sym: lhs, span: bytes(14020..14023) }, Punct { char: '=', spacing: Alone, span: bytes(14024..14025) }, Ident { sym: section, span: bytes(14026..14033) }, Punct { char: '.', spacing: Alone, span: bytes(14033..14034) }, Ident { sym: lhs_content, span: bytes(14034..14045) }, Punct { char: '.', spacing: Alone, span: bytes(14045..14046) }, Ident { sym: as_deref, span: bytes(14046..14054) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(14054..14056) }, Punct { char: '.', spacing: Alone, span: bytes(14056..14057) }, Ident { sym: unwrap_or, span: bytes(14057..14066) }, Group { delimiter: Parenthesis, stream: TokenStream [Literal { lit: "", span: bytes(14067..14069) }], span: bytes(14066..14070) }, Punct { char: ';', spacing: Alone, span: bytes(14070..14071) }, Ident { sym: let, span: bytes(14092..14095) }, Ident { sym: rhs, span: bytes(14096..14099) }, Punct { char: '=', spacing: Alone, span: bytes(14100..14101) }, Ident { sym: section, span: bytes(14102..14109) }, Punct { char: '.', spacing: Alone, span: bytes(14109..14110) }, Ident { sym: rhs_content, span: bytes(14110..14121) }, Punct { char: '.', spacing: Alone, span: bytes(14121..14122) }, Ident { sym: as_deref, span: bytes(14122..14130) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(14130..14132) }, Punct { char: '.', spacing: Alone, span: bytes(14132..14133) }, Ident { sym: unwrap_or, span: bytes(14133..14142) }, Group { delimiter: Parenthesis, stream: TokenStream [Literal { lit: "", span: bytes(14143..14145) }], span: bytes(14142..14146) }, Punct { char: ';', spacing: Alone, span: bytes(14146..14147) }, Ident { sym: format, span: bytes(14168..14174) }, Punct { char: '!', spacing: Alone, span: bytes(14174..14175) }, Group { delimiter: Parenthesis, stream: TokenStream [Literal { lit: "- {lhs}\n+ {rhs}", span: bytes(14176..14194) }], span: bytes(14175..14195) }], span: bytes(13935..14213) }, Ident { sym: ChunkType, span: bytes(14230..14239) }, Punct { char: ':', spacing: Joint, span: bytes(14239..14240) }, Punct { char: ':', spacing: Alone, span: bytes(14240..14241) }, Ident { sym: Unchanged, span: bytes(14241..14250) }, Punct { char: '=', spacing: Joint, span: bytes(14251..14252) }, Punct { char: '>', spacing: Alone, span: bytes(14252..14253) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: section, span: bytes(14335..14342) }, Punct { char: '.', spacing: Alone, span: bytes(14367..14368) }, Ident { sym: lhs_content, span: bytes(14368..14379) }, Punct { char: '.', spacing: Alone, span: bytes(14404..14405) }, Ident { sym: clone, span: bytes(14405..14410) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(14410..14412) }, Punct { char: '.', spacing: Alone, span: bytes(14437..14438) }, Ident { sym: or_else, span: bytes(14438..14445) }, Group { delimiter: Parenthesis, stream: TokenStream [Punct { char: '|', spacing: Joint, span: bytes(14446..14447) }, Punct { char: '|', spacing: Alone, span: bytes(14447..14448) }, Ident { sym: section, span: bytes(14449..14456) }, Punct { char: '.', spacing: Alone, span: bytes(14456..14457) }, Ident { sym: rhs_content, span: bytes(14457..14468) }, Punct { char: '.', spacing: Alone, span: bytes(14468..14469) }, Ident { sym: clone, span: bytes(14469..14474) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(14474..14476) }], span: bytes(14445..14477) }, Punct { char: '.', spacing: Alone, span: bytes(14502..14503) }, Ident { sym: unwrap_or_default, span: bytes(14503..14520) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(14520..14522) }], span: bytes(14254..14540) }], span: bytes(13517..14554) }, Punct { char: ';', spacing: Alone, span: bytes(14554..14555) }, Ident { sym: let, span: bytes(14569..14572) }, Ident { sym: lines, span: bytes(14573..14578) }, Punct { char: '=', spacing: Alone, span: bytes(14579..14580) }, Ident { sym: Lines, span: bytes(14581..14586) }, Punct { char: ':', spacing: Joint, span: bytes(14586..14587) }, Punct { char: ':', spacing: Alone, span: bytes(14587..14588) }, Ident { sym: from, span: bytes(14588..14592) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: content, span: bytes(14593..14600) }, Punct { char: '.', spacing: Alone, span: bytes(14600..14601) }, Ident { sym: as_str, span: bytes(14601..14607) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(14607..14609) }], span: bytes(14592..14610) }, Punct { char: ';', spacing: Alone, span: bytes(14610..14611) }, Ident { sym: self, span: bytes(14624..14628) }, Punct { char: '.', spacing: Alone, span: bytes(14628..14629) }, Ident { sym: editor_state, span: bytes(14629..14641) }, Punct { char: '=', spacing: Alone, span: bytes(14642..14643) }, Ident { sym: Some, span: bytes(14644..14648) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: EditorState, span: bytes(14649..14660) }, Punct { char: ':', spacing: Joint, span: bytes(14660..14661) }, Punct { char: ':', spacing: Alone, span: bytes(14661..14662) }, Ident { sym: new, span: bytes(14662..14665) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: lines, span: bytes(14666..14671) }], span: bytes(14665..14672) }], span: bytes(14648..14673) }, Punct { char: ';', spacing: Alone, span: bytes(14673..14674) }], span: bytes(13472..14684) }, Ident { sym: else, span: bytes(14685..14689) }, Ident { sym: if, span: bytes(14690..14692) }, Ident { sym: let, span: bytes(14693..14696) }, Ident { sym: Ok, span: bytes(14697..14699) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: content, span: bytes(14700..14707) }], span: bytes(14699..14708) }, Punct { char: '=', spacing: Alone, span: bytes(14709..14710) }, Ident { sym: fs, span: bytes(14711..14713) }, Punct { char: ':', spacing: Joint, span: bytes(14713..14714) }, Punct { char: ':', spacing: Alone, span: bytes(14714..14715) }, Ident { sym: read_to_string, span: bytes(14715..14729) }, Group { delimiter: Parenthesis, stream: TokenStream [Punct { char: '&', spacing: Alone, span: bytes(14730..14731) }, Ident { sym: section, span: bytes(14731..14738) }, Punct { char: '.', spacing: Alone, span: bytes(14738..14739) }, Ident { sym: file_path, span: bytes(14739..14748) }], span: bytes(14729..14749) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: let, span: bytes(14764..14767) }, Ident { sym: bytes, span: bytes(14768..14773) }, Punct { char: '=', spacing: Alone, span: bytes(14774..14775) }, Ident { sym: content, span: bytes(14776..14783) }, Punct { char: '.', spacing: Alone, span: bytes(14783..14784) }, Ident { sym: as_bytes, span: bytes(14784..14792) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(14792..14794) }, Punct { char: ';', spacing: Alone, span: bytes(14794..14795) }, Ident { sym: let, span: bytes(14808..14811) }, Ident { sym: section_bytes, span: bytes(14812..14825) }, Punct { char: '=', spacing: Alone, span: bytes(14826..14827) }, Punct { char: '&', spacing: Alone, span: bytes(14844..14845) }, Ident { sym: bytes, span: bytes(14845..14850) }, Group { delimiter: Bracket, stream: TokenStream [Ident { sym: section, span: bytes(14851..14858) }, Punct { char: '.', spacing: Alone, span: bytes(14858..14859) }, Ident { sym: byte_start, span: bytes(14859..14869) }, Punct { char: '.', spacing: Alone, span: bytes(14869..14870) }, Ident { sym: min, span: bytes(14870..14873) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: bytes, span: bytes(14874..14879) }, Punct { char: '.', spacing: Alone, span: bytes(14879..14880) }, Ident { sym: len, span: bytes(14880..14883) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(14883..14885) }], span: bytes(14873..14886) }, Punct { char: '.', spacing: Joint, span: bytes(14886..14887) }, Punct { char: '.', spacing: Alone, span: bytes(14887..14888) }, Ident { sym: section, span: bytes(14888..14895) }, Punct { char: '.', spacing: Alone, span: bytes(14895..14896) }, Ident { sym: byte_end, span: bytes(14896..14904) }, Punct { char: '.', spacing: Alone, span: bytes(14904..14905) }, Ident { sym: min, span: bytes(14905..14908) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: bytes, span: bytes(14909..14914) }, Punct { char: '.', spacing: Alone, span: bytes(14914..14915) }, Ident { sym: len, span: bytes(14915..14918) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(14918..14920) }], span: bytes(14908..14921) }], span: bytes(14850..14922) }, Punct { char: ';', spacing: Alone, span: bytes(14922..14923) }, Ident { sym: let, span: bytes(14937..14940) }, Ident { sym: section_content, span: bytes(14941..14956) }, Punct { char: '=', spacing: Alone, span: bytes(14957..14958) }, Ident { sym: String, span: bytes(14959..14965) }, Punct { char: ':', spacing: Joint, span: bytes(14965..14966) }, Punct { char: ':', spacing: Alone, span: bytes(14966..14967) }, Ident { sym: from_utf8_lossy, span: bytes(14967..14982) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: section_bytes, span: bytes(14983..14996) }], span: bytes(14982..14997) }, Punct { char: '.', spacing: Alone, span: bytes(14997..14998) }, Ident { sym: to_string, span: bytes(14998..15007) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(15007..15009) }, Punct { char: ';', spacing: Alone, span: bytes(15009..15010) }, Ident { sym: let, span: bytes(15024..15027) }, Ident { sym: lines_text, span: bytes(15028..15038) }, Punct { char: '=', spacing: Alone, span: bytes(15039..15040) }, Ident { sym: if, span: bytes(15041..15043) }, Ident { sym: section_content, span: bytes(15044..15059) }, Punct { char: '.', spacing: Alone, span: bytes(15059..15060) }, Ident { sym: trim, span: bytes(15060..15064) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(15064..15066) }, Punct { char: '.', spacing: Alone, span: bytes(15066..15067) }, Ident { sym: is_empty, span: bytes(15067..15075) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(15075..15077) }, Group { delimiter: Brace, stream: TokenStream [Literal { lit: "\n", span: bytes(15096..15100) }, Punct { char: '.', spacing: Alone, span: bytes(15100..15101) }, Ident { sym: to_string, span: bytes(15101..15110) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(15110..15112) }], span: bytes(15078..15126) }, Ident { sym: else, span: bytes(15127..15131) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: format, span: bytes(15150..15156) }, Punct { char: '!', spacing: Alone, span: bytes(15156..15157) }, Group { delimiter: Parenthesis, stream: TokenStream [Literal { lit: "\n{}\n", span: bytes(15158..15166) }, Punct { char: ',', spacing: Alone, span: bytes(15166..15167) }, Ident { sym: section_content, span: bytes(15168..15183) }, Punct { char: '.', spacing: Alone, span: bytes(15183..15184) }, Ident { sym: trim, span: bytes(15184..15188) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(15188..15190) }], span: bytes(15157..15191) }], span: bytes(15132..15205) }, Punct { char: ';', spacing: Alone, span: bytes(15205..15206) }, Ident { sym: let, span: bytes(15220..15223) }, Ident { sym: lines, span: bytes(15224..15229) }, Punct { char: '=', spacing: Alone, span: bytes(15230..15231) }, Ident { sym: Lines, span: bytes(15232..15237) }, Punct { char: ':', spacing: Joint, span: bytes(15237..15238) }, Punct { char: ':', spacing: Alone, span: bytes(15238..15239) }, Ident { sym: from, span: bytes(15239..15243) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: lines_text, span: bytes(15244..15254) }, Punct { char: '.', spacing: Alone, span: bytes(15254..15255) }, Ident { sym: as_str, span: bytes(15255..15261) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(15261..15263) }], span: bytes(15243..15264) }, Punct { char: ';', spacing: Alone, span: bytes(15264..15265) }, Ident { sym: self, span: bytes(15278..15282) }, Punct { char: '.', spacing: Alone, span: bytes(15282..15283) }, Ident { sym: editor_state, span: bytes(15283..15295) }, Punct { char: '=', spacing: Alone, span: bytes(15296..15297) }, Ident { sym: Some, span: bytes(15298..15302) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: EditorState, span: bytes(15303..15314) }, Punct { char: ':', spacing: Joint, span: bytes(15314..15315) }, Punct { char: ':', spacing: Alone, span: bytes(15315..15316) }, Ident { sym: new, span: bytes(15316..15319) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: lines, span: bytes(15320..15325) }], span: bytes(15319..15326) }], span: bytes(15302..15327) }, Punct { char: ';', spacing: Alone, span: bytes(15327..15328) }], span: bytes(14750..15338) }, Ident { sym: self, span: bytes(15348..15352) }, Punct { char: '.', spacing: Alone, span: bytes(15352..15353) }, Ident { sym: current_view, span: bytes(15353..15365) }, Punct { char: '=', spacing: Alone, span: bytes(15366..15367) }, Ident { sym: View, span: bytes(15368..15372) }, Punct { char: ':', spacing: Joint, span: bytes(15372..15373) }, Punct { char: ':', spacing: Alone, span: bytes(15373..15374) }, Ident { sym: Detail, span: bytes(15374..15380) }, Punct { char: ';', spacing: Alone, span: bytes(15380..15381) }], span: bytes(13212..15387) }) })
[SYNCDOC DEBUG] Processing item type: Function
[SYNCDOC DEBUG] Processing item: Function(FnSig { attributes: Some(Repeats<1, 18446744073709551615, syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing>([Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: doc, span: bytes(15393..15459) }, Punct { char: '=', spacing: Alone, span: bytes(15393..15459) }, Literal { lit: " Returns to section list, optionally persisting editor changes.", span: bytes(15393..15459) }], span: bytes(15393..15459) }) }, delimiter: Some(Nothing) }])), visibility: Some(Public(KPub(Cached<proc_macro2::Ident> { value: Ident { sym: pub, span: bytes(15464..15467) }, string: "pub" }))), const_kw: None, async_kw: None, unsafe_kw: None, extern_kw: None, _fn: KFn(Cached<proc_macro2::Ident> { value: Ident { sym: fn, span: bytes(15468..15470) }, string: "fn" }), name: Ident { sym: exit_detail_view, span: bytes(15471..15487) }, generics: None, params: ParenthesisGroupContaining < core::option::Option<unsynn::container::DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>>>(Some(DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>([Delimited<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>> { value: SelfParam(RefMut(Cons<unsynn::operator::Operator<'&'>, unsynn::combinator::Cons<syncdoc_core::parse::KMut, syncdoc_core::parse::KSelf>> { first: Operator<'&'>, second: Cons<syncdoc_core::parse::KMut, syncdoc_core::parse::KSelf> { first: KMut(Cached<proc_macro2::Ident> { value: Ident { sym: mut, span: bytes(15489..15492) }, string: "mut" }), second: KSelf(Cached<proc_macro2::Ident> { value: Ident { sym: self, span: bytes(15493..15497) }, string: "self" }) } })), delimiter: Some(Operator<','>) }, Delimited<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>> { value: Named(NamedParam { mut_kw: None, name: Ident { sym: save, span: bytes(15499..15503) }, _colon: Operator<':'>, param_type: Repeats<1, 18446744073709551615, unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<','>>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing>([Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<','>>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::operator::Operator<','>>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::operator::Operator<','>>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Ident { sym: bool, span: bytes(15505..15509) })) }, delimiter: Some(Nothing) }]) }), delimiter: None }]))), return_type: None, where_clause: None, body: BraceGroup(Group { delimiter: Brace, stream: TokenStream [Ident { sym: if, span: bytes(15521..15523) }, Ident { sym: save, span: bytes(15524..15528) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: if, span: bytes(15543..15545) }, Ident { sym: let, span: bytes(15546..15549) }, Ident { sym: Some, span: bytes(15550..15554) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: ref, span: bytes(15555..15558) }, Ident { sym: editor_state, span: bytes(15559..15571) }], span: bytes(15554..15572) }, Punct { char: '=', spacing: Alone, span: bytes(15573..15574) }, Ident { sym: self, span: bytes(15575..15579) }, Punct { char: '.', spacing: Alone, span: bytes(15579..15580) }, Ident { sym: editor_state, span: bytes(15580..15592) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: if, span: bytes(15611..15613) }, Ident { sym: let, span: bytes(15614..15617) }, Ident { sym: Some, span: bytes(15618..15622) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: section_idx, span: bytes(15623..15634) }], span: bytes(15622..15635) }, Punct { char: '=', spacing: Alone, span: bytes(15636..15637) }, Ident { sym: self, span: bytes(15638..15642) }, Punct { char: '.', spacing: Alone, span: bytes(15642..15643) }, Ident { sym: get_current_section_index, span: bytes(15643..15668) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(15668..15670) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: let, span: bytes(15693..15696) }, Ident { sym: lines, span: bytes(15697..15702) }, Punct { char: '=', spacing: Alone, span: bytes(15703..15704) }, Ident { sym: editor_state, span: bytes(15705..15717) }, Punct { char: '.', spacing: Alone, span: bytes(15742..15743) }, Ident { sym: lines, span: bytes(15743..15748) }, Punct { char: '.', spacing: Alone, span: bytes(15773..15774) }, Ident { sym: iter_row, span: bytes(15774..15782) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(15782..15784) }, Punct { char: '.', spacing: Alone, span: bytes(15809..15810) }, Ident { sym: map, span: bytes(15810..15813) }, Group { delimiter: Parenthesis, stream: TokenStream [Punct { char: '|', spacing: Alone, span: bytes(15814..15815) }, Ident { sym: line, span: bytes(15815..15819) }, Punct { char: '|', spacing: Alone, span: bytes(15819..15820) }, Ident { sym: line, span: bytes(15821..15825) }, Punct { char: '.', spacing: Alone, span: bytes(15825..15826) }, Ident { sym: iter, span: bytes(15826..15830) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(15830..15832) }, Punct { char: '.', spacing: Alone, span: bytes(15832..15833) }, Ident { sym: collect, span: bytes(15833..15840) }, Punct { char: ':', spacing: Joint, span: bytes(15840..15841) }, Punct { char: ':', spacing: Joint, span: bytes(15841..15842) }, Punct { char: '<', spacing: Alone, span: bytes(15842..15843) }, Ident { sym: String, span: bytes(15843..15849) }, Punct { char: '>', spacing: Alone, span: bytes(15849..15850) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(15850..15852) }], span: bytes(15813..15853) }, Punct { char: '.', spacing: Alone, span: bytes(15878..15879) }, Ident { sym: collect, span: bytes(15879..15886) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(15886..15888) }, Punct { char: ';', spacing: Alone, span: bytes(15888..15889) }, Ident { sym: self, span: bytes(15910..15914) }, Punct { char: '.', spacing: Alone, span: bytes(15914..15915) }, Ident { sym: sections, span: bytes(15915..15923) }, Group { delimiter: Bracket, stream: TokenStream [Ident { sym: section_idx, span: bytes(15924..15935) }], span: bytes(15923..15936) }, Punct { char: '.', spacing: Alone, span: bytes(15936..15937) }, Ident { sym: section_content, span: bytes(15937..15952) }, Punct { char: '=', spacing: Alone, span: bytes(15953..15954) }, Ident { sym: Some, span: bytes(15955..15959) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: lines, span: bytes(15960..15965) }], span: bytes(15959..15966) }, Punct { char: ';', spacing: Alone, span: bytes(15966..15967) }], span: bytes(15671..15985) }], span: bytes(15593..15999) }], span: bytes(15529..16009) }, Ident { sym: self, span: bytes(16018..16022) }, Punct { char: '.', spacing: Alone, span: bytes(16022..16023) }, Ident { sym: editor_state, span: bytes(16023..16035) }, Punct { char: '=', spacing: Alone, span: bytes(16036..16037) }, Ident { sym: None, span: bytes(16038..16042) }, Punct { char: ';', spacing: Alone, span: bytes(16042..16043) }, Ident { sym: self, span: bytes(16052..16056) }, Punct { char: '.', spacing: Alone, span: bytes(16056..16057) }, Ident { sym: current_view, span: bytes(16057..16069) }, Punct { char: '=', spacing: Alone, span: bytes(16070..16071) }, Ident { sym: View, span: bytes(16072..16076) }, Punct { char: ':', spacing: Joint, span: bytes(16076..16077) }, Punct { char: ':', spacing: Alone, span: bytes(16077..16078) }, Ident { sym: List, span: bytes(16078..16082) }, Punct { char: ';', spacing: Alone, span: bytes(16082..16083) }], span: bytes(15511..16089) }) })
[SYNCDOC DEBUG] Processing item type: Function
[SYNCDOC DEBUG] Processing item: Function(FnSig { attributes: Some(Repeats<1, 18446744073709551615, syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing>([Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: doc, span: bytes(16095..16142) }, Punct { char: '=', spacing: Alone, span: bytes(16095..16142) }, Literal { lit: " Save the current section's content to disk.", span: bytes(16095..16142) }], span: bytes(16095..16142) }) }, delimiter: Some(Nothing) }, Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: doc, span: bytes(16147..16150) }, Punct { char: '=', spacing: Alone, span: bytes(16147..16150) }, Literal { lit: "", span: bytes(16147..16150) }], span: bytes(16147..16150) }) }, delimiter: Some(Nothing) }, Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: doc, span: bytes(16155..16167) }, Punct { char: '=', spacing: Alone, span: bytes(16155..16167) }, Literal { lit: " # Errors", span: bytes(16155..16167) }], span: bytes(16155..16167) }) }, delimiter: Some(Nothing) }, Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: doc, span: bytes(16172..16175) }, Punct { char: '=', spacing: Alone, span: bytes(16172..16175) }, Literal { lit: "", span: bytes(16172..16175) }], span: bytes(16172..16175) }) }, delimiter: Some(Nothing) }, Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: doc, span: bytes(16180..16264) }, Punct { char: '=', spacing: Alone, span: bytes(16180..16264) }, Literal { lit: " Returns an error if writing to disk fails or if file operations cannot complete.", span: bytes(16180..16264) }], span: bytes(16180..16264) }) }, delimiter: Some(Nothing) }])), visibility: Some(Public(KPub(Cached<proc_macro2::Ident> { value: Ident { sym: pub, span: bytes(16269..16272) }, string: "pub" }))), const_kw: None, async_kw: None, unsafe_kw: None, extern_kw: None, _fn: KFn(Cached<proc_macro2::Ident> { value: Ident { sym: fn, span: bytes(16273..16275) }, string: "fn" }), name: Ident { sym: save_current, span: bytes(16276..16288) }, generics: None, params: ParenthesisGroupContaining < core::option::Option<unsynn::container::DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>>>(Some(DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>([Delimited<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>> { value: SelfParam(RefMut(Cons<unsynn::operator::Operator<'&'>, unsynn::combinator::Cons<syncdoc_core::parse::KMut, syncdoc_core::parse::KSelf>> { first: Operator<'&'>, second: Cons<syncdoc_core::parse::KMut, syncdoc_core::parse::KSelf> { first: KMut(Cached<proc_macro2::Ident> { value: Ident { sym: mut, span: bytes(16290..16293) }, string: "mut" }), second: KSelf(Cached<proc_macro2::Ident> { value: Ident { sym: self, span: bytes(16294..16298) }, string: "self" }) } })), delimiter: None }]))), return_type: Some(ReturnTypeFn { _arrow: Operator<'->'>, return_type: Repeats<1, 18446744073709551615, unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing>([Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::group::BraceGroup>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Ident { sym: io, span: bytes(16303..16305) })) }, delimiter: Some(Nothing) }, Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::group::BraceGroup>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Punct { char: ':', spacing: Joint, span: bytes(16305..16306) })) }, delimiter: Some(Nothing) }, Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::group::BraceGroup>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Punct { char: ':', spacing: Alone, span: bytes(16306..16307) })) }, delimiter: Some(Nothing) }, Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::group::BraceGroup>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Ident { sym: Result, span: bytes(16307..16313) })) }, delimiter: Some(Nothing) }, Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::group::BraceGroup>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>> { first: Operator<'<'>, second: [Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::operator::Operator<'>'>>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(16314..16316) })) }], third: Operator<'>'> })) }, delimiter: Some(Nothing) }]) }), where_clause: None, body: BraceGroup(Group { delimiter: Brace, stream: TokenStream [Ident { sym: let, span: bytes(16328..16331) }, Ident { sym: editor_lines, span: bytes(16332..16344) }, Punct { char: '=', spacing: Alone, span: bytes(16345..16346) }, Ident { sym: if, span: bytes(16347..16349) }, Ident { sym: let, span: bytes(16350..16353) }, Ident { sym: Some, span: bytes(16354..16358) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: ref, span: bytes(16359..16362) }, Ident { sym: editor_state, span: bytes(16363..16375) }], span: bytes(16358..16376) }, Punct { char: '=', spacing: Alone, span: bytes(16377..16378) }, Ident { sym: self, span: bytes(16379..16383) }, Punct { char: '.', spacing: Alone, span: bytes(16383..16384) }, Ident { sym: editor_state, span: bytes(16384..16396) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: editor_state, span: bytes(16411..16423) }, Punct { char: '.', spacing: Alone, span: bytes(16440..16441) }, Ident { sym: lines, span: bytes(16441..16446) }, Punct { char: '.', spacing: Alone, span: bytes(16463..16464) }, Ident { sym: iter_row, span: bytes(16464..16472) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(16472..16474) }, Punct { char: '.', spacing: Alone, span: bytes(16491..16492) }, Ident { sym: map, span: bytes(16492..16495) }, Group { delimiter: Parenthesis, stream: TokenStream [Punct { char: '|', spacing: Alone, span: bytes(16496..16497) }, Ident { sym: line, span: bytes(16497..16501) }, Punct { char: '|', spacing: Alone, span: bytes(16501..16502) }, Ident { sym: line, span: bytes(16503..16507) }, Punct { char: '.', spacing: Alone, span: bytes(16507..16508) }, Ident { sym: iter, span: bytes(16508..16512) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(16512..16514) }, Punct { char: '.', spacing: Alone, span: bytes(16514..16515) }, Ident { sym: collect, span: bytes(16515..16522) }, Punct { char: ':', spacing: Joint, span: bytes(16522..16523) }, Punct { char: ':', spacing: Joint, span: bytes(16523..16524) }, Punct { char: '<', spacing: Alone, span: bytes(16524..16525) }, Ident { sym: String, span: bytes(16525..16531) }, Punct { char: '>', spacing: Alone, span: bytes(16531..16532) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(16532..16534) }], span: bytes(16495..16535) }, Punct { char: '.', spacing: Alone, span: bytes(16552..16553) }, Ident { sym: collect, span: bytes(16553..16560) }, Punct { char: ':', spacing: Joint, span: bytes(16560..16561) }, Punct { char: ':', spacing: Joint, span: bytes(16561..16562) }, Punct { char: '<', spacing: Alone, span: bytes(16562..16563) }, Ident { sym: Vec, span: bytes(16563..16566) }, Punct { char: '<', spacing: Alone, span: bytes(16566..16567) }, Ident { sym: _, span: bytes(16567..16568) }, Punct { char: '>', spacing: Joint, span: bytes(16568..16569) }, Punct { char: '>', spacing: Alone, span: bytes(16569..16570) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(16570..16572) }], span: bytes(16397..16582) }, Ident { sym: else, span: bytes(16583..16587) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: return, span: bytes(16602..16608) }, Ident { sym: Ok, span: bytes(16609..16611) }, Group { delimiter: Parenthesis, stream: TokenStream [Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(16612..16614) }], span: bytes(16611..16615) }, Punct { char: ';', spacing: Alone, span: bytes(16615..16616) }], span: bytes(16588..16626) }, Punct { char: ';', spacing: Alone, span: bytes(16626..16627) }, Ident { sym: let, span: bytes(16637..16640) }, Ident { sym: Some, span: bytes(16641..16645) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: section_idx, span: bytes(16646..16657) }], span: bytes(16645..16658) }, Punct { char: '=', spacing: Alone, span: bytes(16659..16660) }, Ident { sym: self, span: bytes(16661..16665) }, Punct { char: '.', spacing: Alone, span: bytes(16665..16666) }, Ident { sym: get_current_section_index, span: bytes(16666..16691) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(16691..16693) }, Ident { sym: else, span: bytes(16694..16698) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: return, span: bytes(16713..16719) }, Ident { sym: Ok, span: bytes(16720..16722) }, Group { delimiter: Parenthesis, stream: TokenStream [Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(16723..16725) }], span: bytes(16722..16726) }, Punct { char: ';', spacing: Alone, span: bytes(16726..16727) }], span: bytes(16699..16737) }, Punct { char: ';', spacing: Alone, span: bytes(16737..16738) }, Ident { sym: self, span: bytes(16748..16752) }, Punct { char: '.', spacing: Alone, span: bytes(16752..16753) }, Ident { sym: sections, span: bytes(16753..16761) }, Group { delimiter: Bracket, stream: TokenStream [Ident { sym: section_idx, span: bytes(16762..16773) }], span: bytes(16761..16774) }, Punct { char: '.', spacing: Alone, span: bytes(16774..16775) }, Ident { sym: section_content, span: bytes(16775..16790) }, Punct { char: '=', spacing: Alone, span: bytes(16791..16792) }, Ident { sym: Some, span: bytes(16793..16797) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: editor_lines, span: bytes(16798..16810) }, Punct { char: '.', spacing: Alone, span: bytes(16810..16811) }, Ident { sym: clone, span: bytes(16811..16816) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(16816..16818) }], span: bytes(16797..16819) }, Punct { char: ';', spacing: Alone, span: bytes(16819..16820) }, Ident { sym: let, span: bytes(16830..16833) }, Ident { sym: section, span: bytes(16834..16841) }, Punct { char: '=', spacing: Alone, span: bytes(16842..16843) }, Punct { char: '&', spacing: Alone, span: bytes(16844..16845) }, Ident { sym: self, span: bytes(16845..16849) }, Punct { char: '.', spacing: Alone, span: bytes(16849..16850) }, Ident { sym: sections, span: bytes(16850..16858) }, Group { delimiter: Bracket, stream: TokenStream [Ident { sym: section_idx, span: bytes(16859..16870) }], span: bytes(16858..16871) }, Punct { char: ';', spacing: Alone, span: bytes(16871..16872) }, Ident { sym: let, span: bytes(16882..16885) }, Ident { sym: raw_content, span: bytes(16886..16897) }, Punct { char: '=', spacing: Alone, span: bytes(16898..16899) }, Ident { sym: editor_lines, span: bytes(16900..16912) }, Punct { char: '.', spacing: Alone, span: bytes(16912..16913) }, Ident { sym: join, span: bytes(16913..16917) }, Group { delimiter: Parenthesis, stream: TokenStream [Literal { lit: "\n", span: bytes(16918..16922) }], span: bytes(16917..16923) }, Punct { char: ';', spacing: Alone, span: bytes(16923..16924) }, Ident { sym: let, span: bytes(16933..16936) }, Ident { sym: trimmed_content, span: bytes(16937..16952) }, Punct { char: '=', spacing: Alone, span: bytes(16953..16954) }, Ident { sym: raw_content, span: bytes(16955..16966) }, Punct { char: '.', spacing: Alone, span: bytes(16966..16967) }, Ident { sym: trim, span: bytes(16967..16971) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(16971..16973) }, Punct { char: ';', spacing: Alone, span: bytes(16973..16974) }, Ident { sym: let, span: bytes(16983..16986) }, Ident { sym: padded_content, span: bytes(16987..17001) }, Punct { char: '=', spacing: Alone, span: bytes(17002..17003) }, Ident { sym: format, span: bytes(17004..17010) }, Punct { char: '!', spacing: Alone, span: bytes(17010..17011) }, Group { delimiter: Parenthesis, stream: TokenStream [Literal { lit: "\n{trimmed_content}\n\n", span: bytes(17012..17037) }], span: bytes(17011..17038) }, Punct { char: ';', spacing: Alone, span: bytes(17038..17039) }, Ident { sym: let, span: bytes(17049..17052) }, Ident { sym: edit, span: bytes(17053..17057) }, Punct { char: '=', spacing: Alone, span: bytes(17058..17059) }, Ident { sym: Edit, span: bytes(17060..17064) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: file_name, span: bytes(17079..17088) }, Punct { char: ':', spacing: Alone, span: bytes(17088..17089) }, Ident { sym: section, span: bytes(17090..17097) }, Punct { char: '.', spacing: Alone, span: bytes(17097..17098) }, Ident { sym: file_path, span: bytes(17098..17107) }, Punct { char: '.', spacing: Alone, span: bytes(17107..17108) }, Ident { sym: clone, span: bytes(17108..17113) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(17113..17115) }, Punct { char: ',', spacing: Alone, span: bytes(17115..17116) }, Ident { sym: line_start, span: bytes(17129..17139) }, Punct { char: ':', spacing: Alone, span: bytes(17139..17140) }, Ident { sym: section, span: bytes(17141..17148) }, Punct { char: '.', spacing: Alone, span: bytes(17148..17149) }, Ident { sym: line_start, span: bytes(17149..17159) }, Punct { char: ',', spacing: Alone, span: bytes(17159..17160) }, Ident { sym: line_end, span: bytes(17173..17181) }, Punct { char: ':', spacing: Alone, span: bytes(17181..17182) }, Ident { sym: section, span: bytes(17183..17190) }, Punct { char: '.', spacing: Alone, span: bytes(17190..17191) }, Ident { sym: line_end, span: bytes(17191..17199) }, Punct { char: ',', spacing: Alone, span: bytes(17199..17200) }, Ident { sym: column_start, span: bytes(17213..17225) }, Punct { char: ':', spacing: Alone, span: bytes(17225..17226) }, Ident { sym: section, span: bytes(17227..17234) }, Punct { char: '.', spacing: Alone, span: bytes(17234..17235) }, Ident { sym: column_start, span: bytes(17235..17247) }, Punct { char: ',', spacing: Alone, span: bytes(17247..17248) }, Ident { sym: column_end, span: bytes(17261..17271) }, Punct { char: ':', spacing: Alone, span: bytes(17271..17272) }, Ident { sym: section, span: bytes(17273..17280) }, Punct { char: '.', spacing: Alone, span: bytes(17280..17281) }, Ident { sym: column_end, span: bytes(17281..17291) }, Punct { char: ',', spacing: Alone, span: bytes(17291..17292) }, Ident { sym: section_content, span: bytes(17305..17320) }, Punct { char: ':', spacing: Alone, span: bytes(17320..17321) }, Ident { sym: padded_content, span: bytes(17322..17336) }, Punct { char: ',', spacing: Alone, span: bytes(17336..17337) }, Ident { sym: item_name, span: bytes(17350..17359) }, Punct { char: ':', spacing: Alone, span: bytes(17359..17360) }, Ident { sym: section, span: bytes(17361..17368) }, Punct { char: '.', spacing: Alone, span: bytes(17368..17369) }, Ident { sym: title, span: bytes(17369..17374) }, Punct { char: '.', spacing: Alone, span: bytes(17374..17375) }, Ident { sym: clone, span: bytes(17375..17380) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(17380..17382) }, Punct { char: ',', spacing: Alone, span: bytes(17382..17383) }], span: bytes(17065..17393) }, Punct { char: ';', spacing: Alone, span: bytes(17393..17394) }, Ident { sym: let, span: bytes(17404..17407) }, Ident { sym: mut, span: bytes(17408..17411) }, Ident { sym: plan, span: bytes(17412..17416) }, Punct { char: '=', spacing: Alone, span: bytes(17417..17418) }, Ident { sym: EditPlan, span: bytes(17419..17427) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: edits, span: bytes(17430..17435) }, Punct { char: ':', spacing: Alone, span: bytes(17435..17436) }, Ident { sym: vec, span: bytes(17437..17440) }, Punct { char: '!', spacing: Alone, span: bytes(17440..17441) }, Group { delimiter: Bracket, stream: TokenStream [Ident { sym: edit, span: bytes(17442..17446) }], span: bytes(17441..17447) }], span: bytes(17428..17449) }, Punct { char: ';', spacing: Alone, span: bytes(17449..17450) }, Ident { sym: plan, span: bytes(17459..17463) }, Punct { char: '.', spacing: Alone, span: bytes(17463..17464) }, Ident { sym: apply, span: bytes(17464..17469) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(17469..17471) }, Punct { char: '?', spacing: Joint, span: bytes(17471..17472) }, Punct { char: ';', spacing: Alone, span: bytes(17472..17473) }, Ident { sym: let, span: bytes(17510..17513) }, Ident { sym: format, span: bytes(17514..17520) }, Punct { char: '=', spacing: Alone, span: bytes(17521..17522) }, Ident { sym: MarkdownFormat, span: bytes(17523..17537) }, Punct { char: ';', spacing: Alone, span: bytes(17537..17538) }, Ident { sym: if, span: bytes(17547..17549) }, Ident { sym: let, span: bytes(17550..17553) }, Ident { sym: Ok, span: bytes(17554..17556) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: new_sections, span: bytes(17557..17569) }], span: bytes(17556..17570) }, Punct { char: '=', spacing: Alone, span: bytes(17571..17572) }, Ident { sym: input, span: bytes(17585..17590) }, Punct { char: ':', spacing: Joint, span: bytes(17590..17591) }, Punct { char: ':', spacing: Alone, span: bytes(17591..17592) }, Ident { sym: extract_sections, span: bytes(17592..17608) }, Group { delimiter: Parenthesis, stream: TokenStream [Punct { char: '&', spacing: Alone, span: bytes(17609..17610) }, Ident { sym: PathBuf, span: bytes(17610..17617) }, Punct { char: ':', spacing: Joint, span: bytes(17617..17618) }, Punct { char: ':', spacing: Alone, span: bytes(17618..17619) }, Ident { sym: from, span: bytes(17619..17623) }, Group { delimiter: Parenthesis, stream: TokenStream [Punct { char: '&', spacing: Alone, span: bytes(17624..17625) }, Ident { sym: section, span: bytes(17625..17632) }, Punct { char: '.', spacing: Alone, span: bytes(17632..17633) }, Ident { sym: file_path, span: bytes(17633..17642) }], span: bytes(17623..17643) }, Punct { char: ',', spacing: Alone, span: bytes(17643..17644) }, Punct { char: '&', spacing: Alone, span: bytes(17645..17646) }, Ident { sym: format, span: bytes(17646..17652) }], span: bytes(17608..17653) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: let, span: bytes(17676..17679) }, Ident { sym: target_title, span: bytes(17680..17692) }, Punct { char: '=', spacing: Alone, span: bytes(17693..17694) }, Ident { sym: section, span: bytes(17695..17702) }, Punct { char: '.', spacing: Alone, span: bytes(17702..17703) }, Ident { sym: title, span: bytes(17703..17708) }, Punct { char: '.', spacing: Alone, span: bytes(17708..17709) }, Ident { sym: clone, span: bytes(17709..17714) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(17714..17716) }, Punct { char: ';', spacing: Alone, span: bytes(17716..17717) }, Ident { sym: let, span: bytes(17730..17733) }, Ident { sym: target_level, span: bytes(17734..17746) }, Punct { char: '=', spacing: Alone, span: bytes(17747..17748) }, Ident { sym: section, span: bytes(17749..17756) }, Punct { char: '.', spacing: Alone, span: bytes(17756..17757) }, Ident { sym: level, span: bytes(17757..17762) }, Punct { char: ';', spacing: Alone, span: bytes(17762..17763) }, Ident { sym: let, span: bytes(17777..17780) }, Ident { sym: file_path, span: bytes(17781..17790) }, Punct { char: '=', spacing: Alone, span: bytes(17791..17792) }, Ident { sym: section, span: bytes(17793..17800) }, Punct { char: '.', spacing: Alone, span: bytes(17800..17801) }, Ident { sym: file_path, span: bytes(17801..17810) }, Punct { char: '.', spacing: Alone, span: bytes(17810..17811) }, Ident { sym: clone, span: bytes(17811..17816) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(17816..17818) }, Punct { char: ';', spacing: Alone, span: bytes(17818..17819) }, Ident { sym: self, span: bytes(17832..17836) }, Punct { char: '.', spacing: Alone, span: bytes(17836..17837) }, Ident { sym: sections, span: bytes(17837..17845) }, Punct { char: '.', spacing: Alone, span: bytes(17845..17846) }, Ident { sym: retain, span: bytes(17846..17852) }, Group { delimiter: Parenthesis, stream: TokenStream [Punct { char: '|', spacing: Alone, span: bytes(17853..17854) }, Ident { sym: s, span: bytes(17854..17855) }, Punct { char: '|', spacing: Alone, span: bytes(17855..17856) }, Ident { sym: s, span: bytes(17857..17858) }, Punct { char: '.', spacing: Alone, span: bytes(17858..17859) }, Ident { sym: file_path, span: bytes(17859..17868) }, Punct { char: '!', spacing: Joint, span: bytes(17869..17870) }, Punct { char: '=', spacing: Alone, span: bytes(17870..17871) }, Ident { sym: file_path, span: bytes(17872..17881) }], span: bytes(17852..17882) }, Punct { char: ';', spacing: Alone, span: bytes(17882..17883) }, Ident { sym: if, span: bytes(17897..17899) }, Ident { sym: let, span: bytes(17900..17903) }, Ident { sym: Some, span: bytes(17904..17908) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: local_index, span: bytes(17909..17920) }], span: bytes(17908..17921) }, Punct { char: '=', spacing: Alone, span: bytes(17922..17923) }, Ident { sym: new_sections, span: bytes(17924..17936) }, Punct { char: '.', spacing: Alone, span: bytes(17953..17954) }, Ident { sym: iter, span: bytes(17954..17958) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(17958..17960) }, Punct { char: '.', spacing: Alone, span: bytes(17977..17978) }, Ident { sym: position, span: bytes(17978..17986) }, Group { delimiter: Parenthesis, stream: TokenStream [Punct { char: '|', spacing: Alone, span: bytes(17987..17988) }, Ident { sym: s, span: bytes(17988..17989) }, Punct { char: '|', spacing: Alone, span: bytes(17989..17990) }, Ident { sym: s, span: bytes(17991..17992) }, Punct { char: '.', spacing: Alone, span: bytes(17992..17993) }, Ident { sym: title, span: bytes(17993..17998) }, Punct { char: '=', spacing: Joint, span: bytes(17999..18000) }, Punct { char: '=', spacing: Alone, span: bytes(18000..18001) }, Ident { sym: target_title, span: bytes(18002..18014) }, Punct { char: '&', spacing: Joint, span: bytes(18015..18016) }, Punct { char: '&', spacing: Alone, span: bytes(18016..18017) }, Ident { sym: s, span: bytes(18018..18019) }, Punct { char: '.', spacing: Alone, span: bytes(18019..18020) }, Ident { sym: level, span: bytes(18020..18025) }, Punct { char: '=', spacing: Joint, span: bytes(18026..18027) }, Punct { char: '=', spacing: Alone, span: bytes(18027..18028) }, Ident { sym: target_level, span: bytes(18029..18041) }], span: bytes(17986..18042) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: let, span: bytes(18073..18076) }, Ident { sym: new_global_index, span: bytes(18077..18093) }, Punct { char: '=', spacing: Alone, span: bytes(18094..18095) }, Ident { sym: self, span: bytes(18096..18100) }, Punct { char: '.', spacing: Alone, span: bytes(18100..18101) }, Ident { sym: sections, span: bytes(18101..18109) }, Punct { char: '.', spacing: Alone, span: bytes(18109..18110) }, Ident { sym: len, span: bytes(18110..18113) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(18113..18115) }, Punct { char: '+', spacing: Alone, span: bytes(18116..18117) }, Ident { sym: local_index, span: bytes(18118..18129) }, Punct { char: ';', spacing: Alone, span: bytes(18129..18130) }, Ident { sym: self, span: bytes(18147..18151) }, Punct { char: '.', spacing: Alone, span: bytes(18151..18152) }, Ident { sym: sections, span: bytes(18152..18160) }, Punct { char: '.', spacing: Alone, span: bytes(18160..18161) }, Ident { sym: extend, span: bytes(18161..18167) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: new_sections, span: bytes(18168..18180) }], span: bytes(18167..18181) }, Punct { char: ';', spacing: Alone, span: bytes(18181..18182) }, Ident { sym: self, span: bytes(18261..18265) }, Punct { char: '.', spacing: Alone, span: bytes(18265..18266) }, Ident { sym: rebuild_tree, span: bytes(18266..18278) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(18278..18280) }, Punct { char: ';', spacing: Alone, span: bytes(18280..18281) }, Ident { sym: if, span: bytes(18352..18354) }, Ident { sym: let, span: bytes(18355..18358) }, Ident { sym: Some, span: bytes(18359..18363) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: node_idx, span: bytes(18364..18372) }], span: bytes(18363..18373) }, Punct { char: '=', spacing: Alone, span: bytes(18374..18375) }, Ident { sym: self, span: bytes(18376..18380) }, Punct { char: '.', spacing: Alone, span: bytes(18401..18402) }, Ident { sym: tree_nodes, span: bytes(18402..18412) }, Punct { char: '.', spacing: Alone, span: bytes(18433..18434) }, Ident { sym: iter, span: bytes(18434..18438) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(18438..18440) }, Punct { char: '.', spacing: Alone, span: bytes(18461..18462) }, Ident { sym: position, span: bytes(18462..18470) }, Group { delimiter: Parenthesis, stream: TokenStream [Punct { char: '|', spacing: Alone, span: bytes(18471..18472) }, Ident { sym: n, span: bytes(18472..18473) }, Punct { char: '|', spacing: Alone, span: bytes(18473..18474) }, Ident { sym: n, span: bytes(18475..18476) }, Punct { char: '.', spacing: Alone, span: bytes(18476..18477) }, Ident { sym: section_index, span: bytes(18477..18490) }, Punct { char: '=', spacing: Joint, span: bytes(18491..18492) }, Punct { char: '=', spacing: Alone, span: bytes(18492..18493) }, Ident { sym: Some, span: bytes(18494..18498) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: new_global_index, span: bytes(18499..18515) }], span: bytes(18498..18516) }], span: bytes(18470..18517) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: self, span: bytes(18556..18560) }, Punct { char: '.', spacing: Alone, span: bytes(18560..18561) }, Ident { sym: current_node_index, span: bytes(18561..18579) }, Punct { char: '=', spacing: Alone, span: bytes(18580..18581) }, Ident { sym: node_idx, span: bytes(18582..18590) }, Punct { char: ';', spacing: Alone, span: bytes(18590..18591) }], span: bytes(18534..18609) }], span: bytes(18055..18623) }, Ident { sym: else, span: bytes(18624..18628) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: self, span: bytes(18647..18651) }, Punct { char: '.', spacing: Alone, span: bytes(18651..18652) }, Ident { sym: sections, span: bytes(18652..18660) }, Punct { char: '.', spacing: Alone, span: bytes(18660..18661) }, Ident { sym: extend, span: bytes(18661..18667) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: new_sections, span: bytes(18668..18680) }], span: bytes(18667..18681) }, Punct { char: ';', spacing: Alone, span: bytes(18681..18682) }, Ident { sym: self, span: bytes(18699..18703) }, Punct { char: '.', spacing: Alone, span: bytes(18703..18704) }, Ident { sym: rebuild_tree, span: bytes(18704..18716) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(18716..18718) }, Punct { char: ';', spacing: Alone, span: bytes(18718..18719) }], span: bytes(18629..18733) }], span: bytes(17662..18743) }, Ident { sym: self, span: bytes(18753..18757) }, Punct { char: '.', spacing: Alone, span: bytes(18757..18758) }, Ident { sym: rebuild_file_offsets, span: bytes(18758..18778) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(18778..18780) }, Punct { char: ';', spacing: Alone, span: bytes(18780..18781) }, Ident { sym: self, span: bytes(18790..18794) }, Punct { char: '.', spacing: Alone, span: bytes(18794..18795) }, Ident { sym: message, span: bytes(18795..18802) }, Punct { char: '=', spacing: Alone, span: bytes(18803..18804) }, Ident { sym: Some, span: bytes(18805..18809) }, Group { delimiter: Parenthesis, stream: TokenStream [Literal { lit: "Saved", span: bytes(18810..18817) }, Punct { char: '.', spacing: Alone, span: bytes(18817..18818) }, Ident { sym: to_string, span: bytes(18818..18827) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(18827..18829) }], span: bytes(18809..18830) }, Punct { char: ';', spacing: Alone, span: bytes(18830..18831) }, Ident { sym: Ok, span: bytes(18840..18842) }, Group { delimiter: Parenthesis, stream: TokenStream [Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(18843..18845) }], span: bytes(18842..18846) }], span: bytes(16318..18852) }) })
[SYNCDOC DEBUG] Processing item type: Function
[SYNCDOC DEBUG] Processing item: Function(FnSig { attributes: Some(Repeats<1, 18446744073709551615, syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing>([Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: doc, span: bytes(18858..18893) }, Punct { char: '=', spacing: Alone, span: bytes(18858..18893) }, Literal { lit: " Navigate to next navigable node", span: bytes(18858..18893) }], span: bytes(18858..18893) }) }, delimiter: Some(Nothing) }, Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: must_use, span: bytes(18900..18908) }], span: bytes(18899..18909) }) }, delimiter: Some(Nothing) }])), visibility: Some(Public(KPub(Cached<proc_macro2::Ident> { value: Ident { sym: pub, span: bytes(18914..18917) }, string: "pub" }))), const_kw: None, async_kw: None, unsafe_kw: None, extern_kw: None, _fn: KFn(Cached<proc_macro2::Ident> { value: Ident { sym: fn, span: bytes(18918..18920) }, string: "fn" }), name: Ident { sym: find_next_node, span: bytes(18921..18935) }, generics: None, params: ParenthesisGroupContaining < core::option::Option<unsynn::container::DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>>>(Some(DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>([Delimited<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>> { value: SelfParam(Ref(Cons<unsynn::operator::Operator<'&'>, syncdoc_core::parse::KSelf> { first: Operator<'&'>, second: KSelf(Cached<proc_macro2::Ident> { value: Ident { sym: self, span: bytes(18937..18941) }, string: "self" }) })), delimiter: None }]))), return_type: Some(ReturnTypeFn { _arrow: Operator<'->'>, return_type: Repeats<1, 18446744073709551615, unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing>([Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::group::BraceGroup>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Ident { sym: Option, span: bytes(18946..18952) })) }, delimiter: Some(Nothing) }, Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::group::BraceGroup>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>> { first: Operator<'<'>, second: [Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::operator::Operator<'>'>>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Ident { sym: usize, span: bytes(18953..18958) })) }], third: Operator<'>'> })) }, delimiter: Some(Nothing) }]) }), where_clause: None, body: BraceGroup(Group { delimiter: Brace, stream: TokenStream [Group { delimiter: Parenthesis, stream: TokenStream [Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: self, span: bytes(18972..18976) }, Punct { char: '.', spacing: Alone, span: bytes(18976..18977) }, Ident { sym: current_node_index, span: bytes(18977..18995) }, Punct { char: '+', spacing: Alone, span: bytes(18996..18997) }, Literal { lit: 1, span: bytes(18998..18999) }], span: bytes(18971..19000) }, Punct { char: '.', spacing: Joint, span: bytes(19000..19001) }, Punct { char: '.', spacing: Alone, span: bytes(19001..19002) }, Ident { sym: self, span: bytes(19002..19006) }, Punct { char: '.', spacing: Alone, span: bytes(19006..19007) }, Ident { sym: tree_nodes, span: bytes(19007..19017) }, Punct { char: '.', spacing: Alone, span: bytes(19017..19018) }, Ident { sym: len, span: bytes(19018..19021) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(19021..19023) }], span: bytes(18970..19024) }, Punct { char: '.', spacing: Alone, span: bytes(19037..19038) }, Ident { sym: find, span: bytes(19038..19042) }, Group { delimiter: Parenthesis, stream: TokenStream [Punct { char: '|', spacing: Joint, span: bytes(19043..19044) }, Punct { char: '&', spacing: Alone, span: bytes(19044..19045) }, Ident { sym: i, span: bytes(19045..19046) }, Punct { char: '|', spacing: Alone, span: bytes(19046..19047) }, Ident { sym: self, span: bytes(19048..19052) }, Punct { char: '.', spacing: Alone, span: bytes(19052..19053) }, Ident { sym: tree_nodes, span: bytes(19053..19063) }, Group { delimiter: Bracket, stream: TokenStream [Ident { sym: i, span: bytes(19064..19065) }], span: bytes(19063..19066) }, Punct { char: '.', spacing: Alone, span: bytes(19066..19067) }, Ident { sym: navigable, span: bytes(19067..19076) }], span: bytes(19042..19077) }], span: bytes(18960..19083) }) })
[SYNCDOC DEBUG] Processing item type: Function
[SYNCDOC DEBUG] Processing item: Function(FnSig { attributes: Some(Repeats<1, 18446744073709551615, syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing>([Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: doc, span: bytes(19089..19128) }, Punct { char: '=', spacing: Alone, span: bytes(19089..19128) }, Literal { lit: " Navigate to previous navigable node", span: bytes(19089..19128) }], span: bytes(19089..19128) }) }, delimiter: Some(Nothing) }, Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: must_use, span: bytes(19135..19143) }], span: bytes(19134..19144) }) }, delimiter: Some(Nothing) }])), visibility: Some(Public(KPub(Cached<proc_macro2::Ident> { value: Ident { sym: pub, span: bytes(19149..19152) }, string: "pub" }))), const_kw: None, async_kw: None, unsafe_kw: None, extern_kw: None, _fn: KFn(Cached<proc_macro2::Ident> { value: Ident { sym: fn, span: bytes(19153..19155) }, string: "fn" }), name: Ident { sym: find_prev_node, span: bytes(19156..19170) }, generics: None, params: ParenthesisGroupContaining < core::option::Option<unsynn::container::DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>>>(Some(DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>([Delimited<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>> { value: SelfParam(Ref(Cons<unsynn::operator::Operator<'&'>, syncdoc_core::parse::KSelf> { first: Operator<'&'>, second: KSelf(Cached<proc_macro2::Ident> { value: Ident { sym: self, span: bytes(19172..19176) }, string: "self" }) })), delimiter: None }]))), return_type: Some(ReturnTypeFn { _arrow: Operator<'->'>, return_type: Repeats<1, 18446744073709551615, unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing>([Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::group::BraceGroup>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Ident { sym: Option, span: bytes(19181..19187) })) }, delimiter: Some(Nothing) }, Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::group::BraceGroup>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>> { first: Operator<'<'>, second: [Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::operator::Operator<'>'>>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Ident { sym: usize, span: bytes(19188..19193) })) }], third: Operator<'>'> })) }, delimiter: Some(Nothing) }]) }), where_clause: None, body: BraceGroup(Group { delimiter: Brace, stream: TokenStream [Group { delimiter: Parenthesis, stream: TokenStream [Literal { lit: 0, span: bytes(19206..19207) }, Punct { char: '.', spacing: Joint, span: bytes(19207..19208) }, Punct { char: '.', spacing: Alone, span: bytes(19208..19209) }, Ident { sym: self, span: bytes(19209..19213) }, Punct { char: '.', spacing: Alone, span: bytes(19213..19214) }, Ident { sym: current_node_index, span: bytes(19214..19232) }], span: bytes(19205..19233) }, Punct { char: '.', spacing: Alone, span: bytes(19246..19247) }, Ident { sym: rev, span: bytes(19247..19250) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(19250..19252) }, Punct { char: '.', spacing: Alone, span: bytes(19265..19266) }, Ident { sym: find, span: bytes(19266..19270) }, Group { delimiter: Parenthesis, stream: TokenStream [Punct { char: '|', spacing: Joint, span: bytes(19271..19272) }, Punct { char: '&', spacing: Alone, span: bytes(19272..19273) }, Ident { sym: i, span: bytes(19273..19274) }, Punct { char: '|', spacing: Alone, span: bytes(19274..19275) }, Ident { sym: self, span: bytes(19276..19280) }, Punct { char: '.', spacing: Alone, span: bytes(19280..19281) }, Ident { sym: tree_nodes, span: bytes(19281..19291) }, Group { delimiter: Bracket, stream: TokenStream [Ident { sym: i, span: bytes(19292..19293) }], span: bytes(19291..19294) }, Punct { char: '.', spacing: Alone, span: bytes(19294..19295) }, Ident { sym: navigable, span: bytes(19295..19304) }], span: bytes(19270..19305) }], span: bytes(19195..19311) }) })
[SYNCDOC DEBUG] Processing item type: Function
[SYNCDOC DEBUG] Processing item: Function(FnSig { attributes: Some(Repeats<1, 18446744073709551615, syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing>([Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: doc, span: bytes(19317..19379) }, Punct { char: '=', spacing: Alone, span: bytes(19317..19379) }, Literal { lit: " Moves to the containing section in the document hierarchy.", span: bytes(19317..19379) }], span: bytes(19317..19379) }) }, delimiter: Some(Nothing) }, Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: must_use, span: bytes(19386..19394) }], span: bytes(19385..19395) }) }, delimiter: Some(Nothing) }])), visibility: Some(Public(KPub(Cached<proc_macro2::Ident> { value: Ident { sym: pub, span: bytes(19400..19403) }, string: "pub" }))), const_kw: None, async_kw: None, unsafe_kw: None, extern_kw: None, _fn: KFn(Cached<proc_macro2::Ident> { value: Ident { sym: fn, span: bytes(19404..19406) }, string: "fn" }), name: Ident { sym: navigate_to_parent, span: bytes(19407..19425) }, generics: None, params: ParenthesisGroupContaining < core::option::Option<unsynn::container::DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>>>(Some(DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>([Delimited<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>> { value: SelfParam(Ref(Cons<unsynn::operator::Operator<'&'>, syncdoc_core::parse::KSelf> { first: Operator<'&'>, second: KSelf(Cached<proc_macro2::Ident> { value: Ident { sym: self, span: bytes(19427..19431) }, string: "self" }) })), delimiter: None }]))), return_type: Some(ReturnTypeFn { _arrow: Operator<'->'>, return_type: Repeats<1, 18446744073709551615, unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing>([Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::group::BraceGroup>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Ident { sym: Option, span: bytes(19436..19442) })) }, delimiter: Some(Nothing) }, Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::group::BraceGroup>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>> { first: Operator<'<'>, second: [Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::operator::Operator<'>'>>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Ident { sym: usize, span: bytes(19443..19448) })) }], third: Operator<'>'> })) }, delimiter: Some(Nothing) }]) }), where_clause: None, body: BraceGroup(Group { delimiter: Brace, stream: TokenStream [Ident { sym: let, span: bytes(19460..19463) }, Ident { sym: section_idx, span: bytes(19464..19475) }, Punct { char: '=', spacing: Alone, span: bytes(19476..19477) }, Ident { sym: self, span: bytes(19478..19482) }, Punct { char: '.', spacing: Alone, span: bytes(19482..19483) }, Ident { sym: get_current_section_index, span: bytes(19483..19508) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(19508..19510) }, Punct { char: '?', spacing: Joint, span: bytes(19510..19511) }, Punct { char: ';', spacing: Alone, span: bytes(19511..19512) }, Ident { sym: let, span: bytes(19521..19524) }, Ident { sym: parent_section_idx, span: bytes(19525..19543) }, Punct { char: '=', spacing: Alone, span: bytes(19544..19545) }, Ident { sym: self, span: bytes(19546..19550) }, Punct { char: '.', spacing: Alone, span: bytes(19550..19551) }, Ident { sym: sections, span: bytes(19551..19559) }, Group { delimiter: Bracket, stream: TokenStream [Ident { sym: section_idx, span: bytes(19560..19571) }], span: bytes(19559..19572) }, Punct { char: '.', spacing: Alone, span: bytes(19572..19573) }, Ident { sym: parent_index, span: bytes(19573..19585) }, Punct { char: '?', spacing: Joint, span: bytes(19585..19586) }, Punct { char: ';', spacing: Alone, span: bytes(19586..19587) }, Ident { sym: self, span: bytes(19647..19651) }, Punct { char: '.', spacing: Alone, span: bytes(19651..19652) }, Ident { sym: tree_nodes, span: bytes(19652..19662) }, Punct { char: '.', spacing: Alone, span: bytes(19675..19676) }, Ident { sym: iter, span: bytes(19676..19680) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(19680..19682) }, Punct { char: '.', spacing: Alone, span: bytes(19695..19696) }, Ident { sym: position, span: bytes(19696..19704) }, Group { delimiter: Parenthesis, stream: TokenStream [Punct { char: '|', spacing: Alone, span: bytes(19705..19706) }, Ident { sym: n, span: bytes(19706..19707) }, Punct { char: '|', spacing: Alone, span: bytes(19707..19708) }, Ident { sym: n, span: bytes(19709..19710) }, Punct { char: '.', spacing: Alone, span: bytes(19710..19711) }, Ident { sym: section_index, span: bytes(19711..19724) }, Punct { char: '=', spacing: Joint, span: bytes(19725..19726) }, Punct { char: '=', spacing: Alone, span: bytes(19726..19727) }, Ident { sym: Some, span: bytes(19728..19732) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: parent_section_idx, span: bytes(19733..19751) }], span: bytes(19732..19752) }], span: bytes(19704..19753) }], span: bytes(19450..19759) }) })
[SYNCDOC DEBUG] Processing item type: Function
[SYNCDOC DEBUG] Processing item: Function(FnSig { attributes: Some(Repeats<1, 18446744073709551615, syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing>([Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: doc, span: bytes(19765..19831) }, Punct { char: '=', spacing: Alone, span: bytes(19765..19831) }, Literal { lit: " Descends to the first child section in the document hierarchy.", span: bytes(19765..19831) }], span: bytes(19765..19831) }) }, delimiter: Some(Nothing) }, Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: must_use, span: bytes(19838..19846) }], span: bytes(19837..19847) }) }, delimiter: Some(Nothing) }])), visibility: Some(Public(KPub(Cached<proc_macro2::Ident> { value: Ident { sym: pub, span: bytes(19852..19855) }, string: "pub" }))), const_kw: None, async_kw: None, unsafe_kw: None, extern_kw: None, _fn: KFn(Cached<proc_macro2::Ident> { value: Ident { sym: fn, span: bytes(19856..19858) }, string: "fn" }), name: Ident { sym: navigate_to_first_child, span: bytes(19859..19882) }, generics: None, params: ParenthesisGroupContaining < core::option::Option<unsynn::container::DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>>>(Some(DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>([Delimited<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>> { value: SelfParam(Ref(Cons<unsynn::operator::Operator<'&'>, syncdoc_core::parse::KSelf> { first: Operator<'&'>, second: KSelf(Cached<proc_macro2::Ident> { value: Ident { sym: self, span: bytes(19884..19888) }, string: "self" }) })), delimiter: None }]))), return_type: Some(ReturnTypeFn { _arrow: Operator<'->'>, return_type: Repeats<1, 18446744073709551615, unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing>([Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::group::BraceGroup>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Ident { sym: Option, span: bytes(19893..19899) })) }, delimiter: Some(Nothing) }, Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::group::BraceGroup>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>> { first: Operator<'<'>, second: [Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::operator::Operator<'>'>>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Ident { sym: usize, span: bytes(19900..19905) })) }], third: Operator<'>'> })) }, delimiter: Some(Nothing) }]) }), where_clause: None, body: BraceGroup(Group { delimiter: Brace, stream: TokenStream [Ident { sym: let, span: bytes(19917..19920) }, Ident { sym: section_idx, span: bytes(19921..19932) }, Punct { char: '=', spacing: Alone, span: bytes(19933..19934) }, Ident { sym: self, span: bytes(19935..19939) }, Punct { char: '.', spacing: Alone, span: bytes(19939..19940) }, Ident { sym: get_current_section_index, span: bytes(19940..19965) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(19965..19967) }, Punct { char: '?', spacing: Joint, span: bytes(19967..19968) }, Punct { char: ';', spacing: Alone, span: bytes(19968..19969) }, Ident { sym: let, span: bytes(19978..19981) }, Ident { sym: first_child_idx, span: bytes(19982..19997) }, Punct { char: '=', spacing: Alone, span: bytes(19998..19999) }, Ident { sym: self, span: bytes(20000..20004) }, Punct { char: '.', spacing: Alone, span: bytes(20004..20005) }, Ident { sym: sections, span: bytes(20005..20013) }, Group { delimiter: Bracket, stream: TokenStream [Ident { sym: section_idx, span: bytes(20014..20025) }], span: bytes(20013..20026) }, Punct { char: '.', spacing: Alone, span: bytes(20026..20027) }, Ident { sym: children_indices, span: bytes(20027..20043) }, Punct { char: '.', spacing: Alone, span: bytes(20043..20044) }, Ident { sym: first, span: bytes(20044..20049) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(20049..20051) }, Punct { char: '?', spacing: Joint, span: bytes(20051..20052) }, Punct { char: ';', spacing: Alone, span: bytes(20052..20053) }, Ident { sym: self, span: bytes(20063..20067) }, Punct { char: '.', spacing: Alone, span: bytes(20067..20068) }, Ident { sym: tree_nodes, span: bytes(20068..20078) }, Punct { char: '.', spacing: Alone, span: bytes(20091..20092) }, Ident { sym: iter, span: bytes(20092..20096) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(20096..20098) }, Punct { char: '.', spacing: Alone, span: bytes(20111..20112) }, Ident { sym: position, span: bytes(20112..20120) }, Group { delimiter: Parenthesis, stream: TokenStream [Punct { char: '|', spacing: Alone, span: bytes(20121..20122) }, Ident { sym: n, span: bytes(20122..20123) }, Punct { char: '|', spacing: Alone, span: bytes(20123..20124) }, Ident { sym: n, span: bytes(20125..20126) }, Punct { char: '.', spacing: Alone, span: bytes(20126..20127) }, Ident { sym: section_index, span: bytes(20127..20140) }, Punct { char: '=', spacing: Joint, span: bytes(20141..20142) }, Punct { char: '=', spacing: Alone, span: bytes(20142..20143) }, Ident { sym: Some, span: bytes(20144..20148) }, Group { delimiter: Parenthesis, stream: TokenStream [Punct { char: '*', spacing: Alone, span: bytes(20149..20150) }, Ident { sym: first_child_idx, span: bytes(20150..20165) }], span: bytes(20148..20166) }], span: bytes(20120..20167) }], span: bytes(19907..20173) }) })
[SYNCDOC DEBUG] Processing item type: Function
[SYNCDOC DEBUG] Processing item: Function(FnSig { attributes: Some(Repeats<1, 18446744073709551615, syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing>([Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: doc, span: bytes(20179..20247) }, Punct { char: '=', spacing: Alone, span: bytes(20179..20247) }, Literal { lit: " Finds the next descendant section at any depth in the hierarchy.", span: bytes(20179..20247) }], span: bytes(20179..20247) }) }, delimiter: Some(Nothing) }, Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: must_use, span: bytes(20254..20262) }], span: bytes(20253..20263) }) }, delimiter: Some(Nothing) }])), visibility: Some(Public(KPub(Cached<proc_macro2::Ident> { value: Ident { sym: pub, span: bytes(20268..20271) }, string: "pub" }))), const_kw: None, async_kw: None, unsafe_kw: None, extern_kw: None, _fn: KFn(Cached<proc_macro2::Ident> { value: Ident { sym: fn, span: bytes(20272..20274) }, string: "fn" }), name: Ident { sym: navigate_to_next_descendant, span: bytes(20275..20302) }, generics: None, params: ParenthesisGroupContaining < core::option::Option<unsynn::container::DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>>>(Some(DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>([Delimited<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>> { value: SelfParam(Ref(Cons<unsynn::operator::Operator<'&'>, syncdoc_core::parse::KSelf> { first: Operator<'&'>, second: KSelf(Cached<proc_macro2::Ident> { value: Ident { sym: self, span: bytes(20304..20308) }, string: "self" }) })), delimiter: None }]))), return_type: Some(ReturnTypeFn { _arrow: Operator<'->'>, return_type: Repeats<1, 18446744073709551615, unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing>([Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::group::BraceGroup>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Ident { sym: Option, span: bytes(20313..20319) })) }, delimiter: Some(Nothing) }, Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::group::BraceGroup>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>> { first: Operator<'<'>, second: [Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::operator::Operator<'>'>>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Ident { sym: usize, span: bytes(20320..20325) })) }], third: Operator<'>'> })) }, delimiter: Some(Nothing) }]) }), where_clause: None, body: BraceGroup(Group { delimiter: Brace, stream: TokenStream [Ident { sym: let, span: bytes(20337..20340) }, Ident { sym: section_idx, span: bytes(20341..20352) }, Punct { char: '=', spacing: Alone, span: bytes(20353..20354) }, Ident { sym: self, span: bytes(20355..20359) }, Punct { char: '.', spacing: Alone, span: bytes(20359..20360) }, Ident { sym: get_current_section_index, span: bytes(20360..20385) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(20385..20387) }, Punct { char: '?', spacing: Joint, span: bytes(20387..20388) }, Punct { char: ';', spacing: Alone, span: bytes(20388..20389) }, Ident { sym: if, span: bytes(20439..20441) }, Ident { sym: let, span: bytes(20442..20445) }, Ident { sym: Some, span: bytes(20446..20450) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: first_child, span: bytes(20451..20462) }], span: bytes(20450..20463) }, Punct { char: '=', spacing: Alone, span: bytes(20464..20465) }, Ident { sym: self, span: bytes(20466..20470) }, Punct { char: '.', spacing: Alone, span: bytes(20470..20471) }, Ident { sym: sections, span: bytes(20471..20479) }, Group { delimiter: Bracket, stream: TokenStream [Ident { sym: section_idx, span: bytes(20480..20491) }], span: bytes(20479..20492) }, Punct { char: '.', spacing: Alone, span: bytes(20492..20493) }, Ident { sym: children_indices, span: bytes(20493..20509) }, Punct { char: '.', spacing: Alone, span: bytes(20509..20510) }, Ident { sym: first, span: bytes(20510..20515) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(20515..20517) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: return, span: bytes(20532..20538) }, Ident { sym: self, span: bytes(20539..20543) }, Punct { char: '.', spacing: Alone, span: bytes(20560..20561) }, Ident { sym: tree_nodes, span: bytes(20561..20571) }, Punct { char: '.', spacing: Alone, span: bytes(20588..20589) }, Ident { sym: iter, span: bytes(20589..20593) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(20593..20595) }, Punct { char: '.', spacing: Alone, span: bytes(20612..20613) }, Ident { sym: position, span: bytes(20613..20621) }, Group { delimiter: Parenthesis, stream: TokenStream [Punct { char: '|', spacing: Alone, span: bytes(20622..20623) }, Ident { sym: n, span: bytes(20623..20624) }, Punct { char: '|', spacing: Alone, span: bytes(20624..20625) }, Ident { sym: n, span: bytes(20626..20627) }, Punct { char: '.', spacing: Alone, span: bytes(20627..20628) }, Ident { sym: section_index, span: bytes(20628..20641) }, Punct { char: '=', spacing: Joint, span: bytes(20642..20643) }, Punct { char: '=', spacing: Alone, span: bytes(20643..20644) }, Ident { sym: Some, span: bytes(20645..20649) }, Group { delimiter: Parenthesis, stream: TokenStream [Punct { char: '*', spacing: Alone, span: bytes(20650..20651) }, Ident { sym: first_child, span: bytes(20651..20662) }], span: bytes(20649..20663) }], span: bytes(20621..20664) }, Punct { char: ';', spacing: Alone, span: bytes(20664..20665) }], span: bytes(20518..20675) }, Ident { sym: for, span: bytes(20740..20743) }, Ident { sym: i, span: bytes(20744..20745) }, Ident { sym: in, span: bytes(20746..20748) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: section_idx, span: bytes(20750..20761) }, Punct { char: '+', spacing: Alone, span: bytes(20762..20763) }, Literal { lit: 1, span: bytes(20764..20765) }], span: bytes(20749..20766) }, Punct { char: '.', spacing: Joint, span: bytes(20766..20767) }, Punct { char: '.', spacing: Alone, span: bytes(20767..20768) }, Ident { sym: self, span: bytes(20768..20772) }, Punct { char: '.', spacing: Alone, span: bytes(20772..20773) }, Ident { sym: sections, span: bytes(20773..20781) }, Punct { char: '.', spacing: Alone, span: bytes(20781..20782) }, Ident { sym: len, span: bytes(20782..20785) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(20785..20787) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: if, span: bytes(20802..20804) }, Ident { sym: self, span: bytes(20805..20809) }, Punct { char: '.', spacing: Alone, span: bytes(20809..20810) }, Ident { sym: sections, span: bytes(20810..20818) }, Group { delimiter: Bracket, stream: TokenStream [Ident { sym: i, span: bytes(20819..20820) }], span: bytes(20818..20821) }, Punct { char: '.', spacing: Alone, span: bytes(20821..20822) }, Ident { sym: level, span: bytes(20822..20827) }, Punct { char: '>', spacing: Alone, span: bytes(20828..20829) }, Ident { sym: self, span: bytes(20830..20834) }, Punct { char: '.', spacing: Alone, span: bytes(20834..20835) }, Ident { sym: sections, span: bytes(20835..20843) }, Group { delimiter: Bracket, stream: TokenStream [Ident { sym: section_idx, span: bytes(20844..20855) }], span: bytes(20843..20856) }, Punct { char: '.', spacing: Alone, span: bytes(20856..20857) }, Ident { sym: level, span: bytes(20857..20862) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: return, span: bytes(20881..20887) }, Ident { sym: self, span: bytes(20888..20892) }, Punct { char: '.', spacing: Alone, span: bytes(20913..20914) }, Ident { sym: tree_nodes, span: bytes(20914..20924) }, Punct { char: '.', spacing: Alone, span: bytes(20945..20946) }, Ident { sym: iter, span: bytes(20946..20950) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(20950..20952) }, Punct { char: '.', spacing: Alone, span: bytes(20973..20974) }, Ident { sym: position, span: bytes(20974..20982) }, Group { delimiter: Parenthesis, stream: TokenStream [Punct { char: '|', spacing: Alone, span: bytes(20983..20984) }, Ident { sym: n, span: bytes(20984..20985) }, Punct { char: '|', spacing: Alone, span: bytes(20985..20986) }, Ident { sym: n, span: bytes(20987..20988) }, Punct { char: '.', spacing: Alone, span: bytes(20988..20989) }, Ident { sym: section_index, span: bytes(20989..21002) }, Punct { char: '=', spacing: Joint, span: bytes(21003..21004) }, Punct { char: '=', spacing: Alone, span: bytes(21004..21005) }, Ident { sym: Some, span: bytes(21006..21010) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: i, span: bytes(21011..21012) }], span: bytes(21010..21013) }], span: bytes(20982..21014) }, Punct { char: ';', spacing: Alone, span: bytes(21014..21015) }], span: bytes(20863..21029) }], span: bytes(20788..21039) }, Ident { sym: None, span: bytes(21049..21053) }], span: bytes(20327..21059) }) })
[SYNCDOC DEBUG] Processing item type: Function
[SYNCDOC DEBUG] Processing item: Function(FnSig { attributes: Some(Repeats<1, 18446744073709551615, syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing>([Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: doc, span: bytes(21065..21120) }, Punct { char: '=', spacing: Alone, span: bytes(21065..21120) }, Literal { lit: " Finds the next section at the same hierarchy level.", span: bytes(21065..21120) }], span: bytes(21065..21120) }) }, delimiter: Some(Nothing) }, Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: must_use, span: bytes(21127..21135) }], span: bytes(21126..21136) }) }, delimiter: Some(Nothing) }])), visibility: Some(Public(KPub(Cached<proc_macro2::Ident> { value: Ident { sym: pub, span: bytes(21141..21144) }, string: "pub" }))), const_kw: None, async_kw: None, unsafe_kw: None, extern_kw: None, _fn: KFn(Cached<proc_macro2::Ident> { value: Ident { sym: fn, span: bytes(21145..21147) }, string: "fn" }), name: Ident { sym: navigate_to_next_sibling, span: bytes(21148..21172) }, generics: None, params: ParenthesisGroupContaining < core::option::Option<unsynn::container::DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>>>(Some(DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>([Delimited<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>> { value: SelfParam(Ref(Cons<unsynn::operator::Operator<'&'>, syncdoc_core::parse::KSelf> { first: Operator<'&'>, second: KSelf(Cached<proc_macro2::Ident> { value: Ident { sym: self, span: bytes(21174..21178) }, string: "self" }) })), delimiter: None }]))), return_type: Some(ReturnTypeFn { _arrow: Operator<'->'>, return_type: Repeats<1, 18446744073709551615, unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing>([Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::group::BraceGroup>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Ident { sym: Option, span: bytes(21183..21189) })) }, delimiter: Some(Nothing) }, Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::group::BraceGroup>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>> { first: Operator<'<'>, second: [Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::operator::Operator<'>'>>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Ident { sym: usize, span: bytes(21190..21195) })) }], third: Operator<'>'> })) }, delimiter: Some(Nothing) }]) }), where_clause: None, body: BraceGroup(Group { delimiter: Brace, stream: TokenStream [Ident { sym: let, span: bytes(21207..21210) }, Ident { sym: section_idx, span: bytes(21211..21222) }, Punct { char: '=', spacing: Alone, span: bytes(21223..21224) }, Ident { sym: self, span: bytes(21225..21229) }, Punct { char: '.', spacing: Alone, span: bytes(21229..21230) }, Ident { sym: get_current_section_index, span: bytes(21230..21255) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(21255..21257) }, Punct { char: '?', spacing: Joint, span: bytes(21257..21258) }, Punct { char: ';', spacing: Alone, span: bytes(21258..21259) }, Ident { sym: let, span: bytes(21268..21271) }, Ident { sym: current_level, span: bytes(21272..21285) }, Punct { char: '=', spacing: Alone, span: bytes(21286..21287) }, Ident { sym: self, span: bytes(21288..21292) }, Punct { char: '.', spacing: Alone, span: bytes(21292..21293) }, Ident { sym: sections, span: bytes(21293..21301) }, Group { delimiter: Bracket, stream: TokenStream [Ident { sym: section_idx, span: bytes(21302..21313) }], span: bytes(21301..21314) }, Punct { char: '.', spacing: Alone, span: bytes(21314..21315) }, Ident { sym: level, span: bytes(21315..21320) }, Punct { char: ';', spacing: Alone, span: bytes(21320..21321) }, Ident { sym: for, span: bytes(21331..21334) }, Ident { sym: i, span: bytes(21335..21336) }, Ident { sym: in, span: bytes(21337..21339) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: section_idx, span: bytes(21341..21352) }, Punct { char: '+', spacing: Alone, span: bytes(21353..21354) }, Literal { lit: 1, span: bytes(21355..21356) }], span: bytes(21340..21357) }, Punct { char: '.', spacing: Joint, span: bytes(21357..21358) }, Punct { char: '.', spacing: Alone, span: bytes(21358..21359) }, Ident { sym: self, span: bytes(21359..21363) }, Punct { char: '.', spacing: Alone, span: bytes(21363..21364) }, Ident { sym: sections, span: bytes(21364..21372) }, Punct { char: '.', spacing: Alone, span: bytes(21372..21373) }, Ident { sym: len, span: bytes(21373..21376) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(21376..21378) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: if, span: bytes(21393..21395) }, Ident { sym: self, span: bytes(21396..21400) }, Punct { char: '.', spacing: Alone, span: bytes(21400..21401) }, Ident { sym: sections, span: bytes(21401..21409) }, Group { delimiter: Bracket, stream: TokenStream [Ident { sym: i, span: bytes(21410..21411) }], span: bytes(21409..21412) }, Punct { char: '.', spacing: Alone, span: bytes(21412..21413) }, Ident { sym: level, span: bytes(21413..21418) }, Punct { char: '=', spacing: Joint, span: bytes(21419..21420) }, Punct { char: '=', spacing: Alone, span: bytes(21420..21421) }, Ident { sym: current_level, span: bytes(21422..21435) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: return, span: bytes(21454..21460) }, Ident { sym: self, span: bytes(21461..21465) }, Punct { char: '.', spacing: Alone, span: bytes(21486..21487) }, Ident { sym: tree_nodes, span: bytes(21487..21497) }, Punct { char: '.', spacing: Alone, span: bytes(21518..21519) }, Ident { sym: iter, span: bytes(21519..21523) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(21523..21525) }, Punct { char: '.', spacing: Alone, span: bytes(21546..21547) }, Ident { sym: position, span: bytes(21547..21555) }, Group { delimiter: Parenthesis, stream: TokenStream [Punct { char: '|', spacing: Alone, span: bytes(21556..21557) }, Ident { sym: n, span: bytes(21557..21558) }, Punct { char: '|', spacing: Alone, span: bytes(21558..21559) }, Ident { sym: n, span: bytes(21560..21561) }, Punct { char: '.', spacing: Alone, span: bytes(21561..21562) }, Ident { sym: section_index, span: bytes(21562..21575) }, Punct { char: '=', spacing: Joint, span: bytes(21576..21577) }, Punct { char: '=', spacing: Alone, span: bytes(21577..21578) }, Ident { sym: Some, span: bytes(21579..21583) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: i, span: bytes(21584..21585) }], span: bytes(21583..21586) }], span: bytes(21555..21587) }, Punct { char: ';', spacing: Alone, span: bytes(21587..21588) }], span: bytes(21436..21602) }, Ident { sym: if, span: bytes(21615..21617) }, Ident { sym: self, span: bytes(21618..21622) }, Punct { char: '.', spacing: Alone, span: bytes(21622..21623) }, Ident { sym: sections, span: bytes(21623..21631) }, Group { delimiter: Bracket, stream: TokenStream [Ident { sym: i, span: bytes(21632..21633) }], span: bytes(21631..21634) }, Punct { char: '.', spacing: Alone, span: bytes(21634..21635) }, Ident { sym: level, span: bytes(21635..21640) }, Punct { char: '<', spacing: Alone, span: bytes(21641..21642) }, Ident { sym: current_level, span: bytes(21643..21656) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: break, span: bytes(21675..21680) }, Punct { char: ';', spacing: Alone, span: bytes(21680..21681) }], span: bytes(21657..21695) }], span: bytes(21379..21705) }, Ident { sym: None, span: bytes(21715..21719) }], span: bytes(21197..21725) }) })
[SYNCDOC DEBUG] Processing item type: Function
[SYNCDOC DEBUG] Processing item: Function(FnSig { attributes: Some(Repeats<1, 18446744073709551615, syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing>([Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: doc, span: bytes(21731..21790) }, Punct { char: '=', spacing: Alone, span: bytes(21731..21790) }, Literal { lit: " Finds the previous section at the same hierarchy level.", span: bytes(21731..21790) }], span: bytes(21731..21790) }) }, delimiter: Some(Nothing) }, Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: must_use, span: bytes(21797..21805) }], span: bytes(21796..21806) }) }, delimiter: Some(Nothing) }])), visibility: Some(Public(KPub(Cached<proc_macro2::Ident> { value: Ident { sym: pub, span: bytes(21811..21814) }, string: "pub" }))), const_kw: None, async_kw: None, unsafe_kw: None, extern_kw: None, _fn: KFn(Cached<proc_macro2::Ident> { value: Ident { sym: fn, span: bytes(21815..21817) }, string: "fn" }), name: Ident { sym: navigate_to_prev_sibling, span: bytes(21818..21842) }, generics: None, params: ParenthesisGroupContaining < core::option::Option<unsynn::container::DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>>>(Some(DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>([Delimited<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>> { value: SelfParam(Ref(Cons<unsynn::operator::Operator<'&'>, syncdoc_core::parse::KSelf> { first: Operator<'&'>, second: KSelf(Cached<proc_macro2::Ident> { value: Ident { sym: self, span: bytes(21844..21848) }, string: "self" }) })), delimiter: None }]))), return_type: Some(ReturnTypeFn { _arrow: Operator<'->'>, return_type: Repeats<1, 18446744073709551615, unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing>([Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::group::BraceGroup>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Ident { sym: Option, span: bytes(21853..21859) })) }, delimiter: Some(Nothing) }, Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::group::BraceGroup>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>> { first: Operator<'<'>, second: [Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::operator::Operator<'>'>>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Ident { sym: usize, span: bytes(21860..21865) })) }], third: Operator<'>'> })) }, delimiter: Some(Nothing) }]) }), where_clause: None, body: BraceGroup(Group { delimiter: Brace, stream: TokenStream [Ident { sym: let, span: bytes(21877..21880) }, Ident { sym: section_idx, span: bytes(21881..21892) }, Punct { char: '=', spacing: Alone, span: bytes(21893..21894) }, Ident { sym: self, span: bytes(21895..21899) }, Punct { char: '.', spacing: Alone, span: bytes(21899..21900) }, Ident { sym: get_current_section_index, span: bytes(21900..21925) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(21925..21927) }, Punct { char: '?', spacing: Joint, span: bytes(21927..21928) }, Punct { char: ';', spacing: Alone, span: bytes(21928..21929) }, Ident { sym: let, span: bytes(21938..21941) }, Ident { sym: current_level, span: bytes(21942..21955) }, Punct { char: '=', spacing: Alone, span: bytes(21956..21957) }, Ident { sym: self, span: bytes(21958..21962) }, Punct { char: '.', spacing: Alone, span: bytes(21962..21963) }, Ident { sym: sections, span: bytes(21963..21971) }, Group { delimiter: Bracket, stream: TokenStream [Ident { sym: section_idx, span: bytes(21972..21983) }], span: bytes(21971..21984) }, Punct { char: '.', spacing: Alone, span: bytes(21984..21985) }, Ident { sym: level, span: bytes(21985..21990) }, Punct { char: ';', spacing: Alone, span: bytes(21990..21991) }, Ident { sym: for, span: bytes(22001..22004) }, Ident { sym: i, span: bytes(22005..22006) }, Ident { sym: in, span: bytes(22007..22009) }, Group { delimiter: Parenthesis, stream: TokenStream [Literal { lit: 0, span: bytes(22011..22012) }, Punct { char: '.', spacing: Joint, span: bytes(22012..22013) }, Punct { char: '.', spacing: Alone, span: bytes(22013..22014) }, Ident { sym: section_idx, span: bytes(22014..22025) }], span: bytes(22010..22026) }, Punct { char: '.', spacing: Alone, span: bytes(22026..22027) }, Ident { sym: rev, span: bytes(22027..22030) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(22030..22032) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: if, span: bytes(22047..22049) }, Ident { sym: self, span: bytes(22050..22054) }, Punct { char: '.', spacing: Alone, span: bytes(22054..22055) }, Ident { sym: sections, span: bytes(22055..22063) }, Group { delimiter: Bracket, stream: TokenStream [Ident { sym: i, span: bytes(22064..22065) }], span: bytes(22063..22066) }, Punct { char: '.', spacing: Alone, span: bytes(22066..22067) }, Ident { sym: level, span: bytes(22067..22072) }, Punct { char: '=', spacing: Joint, span: bytes(22073..22074) }, Punct { char: '=', spacing: Alone, span: bytes(22074..22075) }, Ident { sym: current_level, span: bytes(22076..22089) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: return, span: bytes(22108..22114) }, Ident { sym: self, span: bytes(22115..22119) }, Punct { char: '.', spacing: Alone, span: bytes(22140..22141) }, Ident { sym: tree_nodes, span: bytes(22141..22151) }, Punct { char: '.', spacing: Alone, span: bytes(22172..22173) }, Ident { sym: iter, span: bytes(22173..22177) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(22177..22179) }, Punct { char: '.', spacing: Alone, span: bytes(22200..22201) }, Ident { sym: position, span: bytes(22201..22209) }, Group { delimiter: Parenthesis, stream: TokenStream [Punct { char: '|', spacing: Alone, span: bytes(22210..22211) }, Ident { sym: n, span: bytes(22211..22212) }, Punct { char: '|', spacing: Alone, span: bytes(22212..22213) }, Ident { sym: n, span: bytes(22214..22215) }, Punct { char: '.', spacing: Alone, span: bytes(22215..22216) }, Ident { sym: section_index, span: bytes(22216..22229) }, Punct { char: '=', spacing: Joint, span: bytes(22230..22231) }, Punct { char: '=', spacing: Alone, span: bytes(22231..22232) }, Ident { sym: Some, span: bytes(22233..22237) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: i, span: bytes(22238..22239) }], span: bytes(22237..22240) }], span: bytes(22209..22241) }, Punct { char: ';', spacing: Alone, span: bytes(22241..22242) }], span: bytes(22090..22256) }, Ident { sym: if, span: bytes(22269..22271) }, Ident { sym: self, span: bytes(22272..22276) }, Punct { char: '.', spacing: Alone, span: bytes(22276..22277) }, Ident { sym: sections, span: bytes(22277..22285) }, Group { delimiter: Bracket, stream: TokenStream [Ident { sym: i, span: bytes(22286..22287) }], span: bytes(22285..22288) }, Punct { char: '.', spacing: Alone, span: bytes(22288..22289) }, Ident { sym: level, span: bytes(22289..22294) }, Punct { char: '<', spacing: Alone, span: bytes(22295..22296) }, Ident { sym: current_level, span: bytes(22297..22310) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: break, span: bytes(22329..22334) }, Punct { char: ';', spacing: Alone, span: bytes(22334..22335) }], span: bytes(22311..22349) }], span: bytes(22033..22359) }, Ident { sym: None, span: bytes(22369..22373) }], span: bytes(21867..22379) }) })
[SYNCDOC DEBUG] Processing item type: Function
[SYNCDOC DEBUG] Processing item: Function(FnSig { attributes: Some(Repeats<1, 18446744073709551615, syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing>([Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: doc, span: bytes(22385..22423) }, Punct { char: '=', spacing: Alone, span: bytes(22385..22423) }, Literal { lit: " Jumps to the first navigable node.", span: bytes(22385..22423) }], span: bytes(22385..22423) }) }, delimiter: Some(Nothing) }, Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: must_use, span: bytes(22430..22438) }], span: bytes(22429..22439) }) }, delimiter: Some(Nothing) }])), visibility: Some(Public(KPub(Cached<proc_macro2::Ident> { value: Ident { sym: pub, span: bytes(22444..22447) }, string: "pub" }))), const_kw: None, async_kw: None, unsafe_kw: None, extern_kw: None, _fn: KFn(Cached<proc_macro2::Ident> { value: Ident { sym: fn, span: bytes(22448..22450) }, string: "fn" }), name: Ident { sym: navigate_to_first, span: bytes(22451..22468) }, generics: None, params: ParenthesisGroupContaining < core::option::Option<unsynn::container::DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>>>(Some(DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>([Delimited<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>> { value: SelfParam(Ref(Cons<unsynn::operator::Operator<'&'>, syncdoc_core::parse::KSelf> { first: Operator<'&'>, second: KSelf(Cached<proc_macro2::Ident> { value: Ident { sym: self, span: bytes(22470..22474) }, string: "self" }) })), delimiter: None }]))), return_type: Some(ReturnTypeFn { _arrow: Operator<'->'>, return_type: Repeats<1, 18446744073709551615, unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing>([Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::group::BraceGroup>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Ident { sym: Option, span: bytes(22479..22485) })) }, delimiter: Some(Nothing) }, Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::group::BraceGroup>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>> { first: Operator<'<'>, second: [Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::operator::Operator<'>'>>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Ident { sym: usize, span: bytes(22486..22491) })) }], third: Operator<'>'> })) }, delimiter: Some(Nothing) }]) }), where_clause: None, body: BraceGroup(Group { delimiter: Brace, stream: TokenStream [Ident { sym: self, span: bytes(22503..22507) }, Punct { char: '.', spacing: Alone, span: bytes(22507..22508) }, Ident { sym: tree_nodes, span: bytes(22508..22518) }, Punct { char: '.', spacing: Alone, span: bytes(22518..22519) }, Ident { sym: iter, span: bytes(22519..22523) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(22523..22525) }, Punct { char: '.', spacing: Alone, span: bytes(22525..22526) }, Ident { sym: position, span: bytes(22526..22534) }, Group { delimiter: Parenthesis, stream: TokenStream [Punct { char: '|', spacing: Alone, span: bytes(22535..22536) }, Ident { sym: n, span: bytes(22536..22537) }, Punct { char: '|', spacing: Alone, span: bytes(22537..22538) }, Ident { sym: n, span: bytes(22539..22540) }, Punct { char: '.', spacing: Alone, span: bytes(22540..22541) }, Ident { sym: navigable, span: bytes(22541..22550) }], span: bytes(22534..22551) }], span: bytes(22493..22557) }) })
[SYNCDOC DEBUG] Processing item type: Function
[SYNCDOC DEBUG] Processing item: Function(FnSig { attributes: Some(Repeats<1, 18446744073709551615, syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing>([Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: doc, span: bytes(22563..22600) }, Punct { char: '=', spacing: Alone, span: bytes(22563..22600) }, Literal { lit: " Jumps to the last navigable node.", span: bytes(22563..22600) }], span: bytes(22563..22600) }) }, delimiter: Some(Nothing) }, Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: must_use, span: bytes(22607..22615) }], span: bytes(22606..22616) }) }, delimiter: Some(Nothing) }])), visibility: Some(Public(KPub(Cached<proc_macro2::Ident> { value: Ident { sym: pub, span: bytes(22621..22624) }, string: "pub" }))), const_kw: None, async_kw: None, unsafe_kw: None, extern_kw: None, _fn: KFn(Cached<proc_macro2::Ident> { value: Ident { sym: fn, span: bytes(22625..22627) }, string: "fn" }), name: Ident { sym: navigate_to_last, span: bytes(22628..22644) }, generics: None, params: ParenthesisGroupContaining < core::option::Option<unsynn::container::DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>>>(Some(DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>([Delimited<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>> { value: SelfParam(Ref(Cons<unsynn::operator::Operator<'&'>, syncdoc_core::parse::KSelf> { first: Operator<'&'>, second: KSelf(Cached<proc_macro2::Ident> { value: Ident { sym: self, span: bytes(22646..22650) }, string: "self" }) })), delimiter: None }]))), return_type: Some(ReturnTypeFn { _arrow: Operator<'->'>, return_type: Repeats<1, 18446744073709551615, unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing>([Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::group::BraceGroup>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Ident { sym: Option, span: bytes(22655..22661) })) }, delimiter: Some(Nothing) }, Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::group::BraceGroup>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>> { first: Operator<'<'>, second: [Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::operator::Operator<'>'>>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Ident { sym: usize, span: bytes(22662..22667) })) }], third: Operator<'>'> })) }, delimiter: Some(Nothing) }]) }), where_clause: None, body: BraceGroup(Group { delimiter: Brace, stream: TokenStream [Ident { sym: self, span: bytes(22679..22683) }, Punct { char: '.', spacing: Alone, span: bytes(22683..22684) }, Ident { sym: tree_nodes, span: bytes(22684..22694) }, Punct { char: '.', spacing: Alone, span: bytes(22694..22695) }, Ident { sym: iter, span: bytes(22695..22699) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(22699..22701) }, Punct { char: '.', spacing: Alone, span: bytes(22701..22702) }, Ident { sym: rposition, span: bytes(22702..22711) }, Group { delimiter: Parenthesis, stream: TokenStream [Punct { char: '|', spacing: Alone, span: bytes(22712..22713) }, Ident { sym: n, span: bytes(22713..22714) }, Punct { char: '|', spacing: Alone, span: bytes(22714..22715) }, Ident { sym: n, span: bytes(22716..22717) }, Punct { char: '.', spacing: Alone, span: bytes(22717..22718) }, Ident { sym: navigable, span: bytes(22718..22727) }], span: bytes(22711..22728) }], span: bytes(22669..22734) }) })
[SYNCDOC DEBUG] Processing item type: Function
[SYNCDOC DEBUG] Processing item: Function(FnSig { attributes: Some(Repeats<1, 18446744073709551615, syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing>([Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: doc, span: bytes(22740..22796) }, Punct { char: '=', spacing: Alone, span: bytes(22740..22796) }, Literal { lit: " Finds the first section at the same hierarchy level.", span: bytes(22740..22796) }], span: bytes(22740..22796) }) }, delimiter: Some(Nothing) }, Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: must_use, span: bytes(22803..22811) }], span: bytes(22802..22812) }) }, delimiter: Some(Nothing) }])), visibility: Some(Public(KPub(Cached<proc_macro2::Ident> { value: Ident { sym: pub, span: bytes(22817..22820) }, string: "pub" }))), const_kw: None, async_kw: None, unsafe_kw: None, extern_kw: None, _fn: KFn(Cached<proc_macro2::Ident> { value: Ident { sym: fn, span: bytes(22821..22823) }, string: "fn" }), name: Ident { sym: navigate_to_first_at_level, span: bytes(22824..22850) }, generics: None, params: ParenthesisGroupContaining < core::option::Option<unsynn::container::DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>>>(Some(DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>([Delimited<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>> { value: SelfParam(Ref(Cons<unsynn::operator::Operator<'&'>, syncdoc_core::parse::KSelf> { first: Operator<'&'>, second: KSelf(Cached<proc_macro2::Ident> { value: Ident { sym: self, span: bytes(22852..22856) }, string: "self" }) })), delimiter: None }]))), return_type: Some(ReturnTypeFn { _arrow: Operator<'->'>, return_type: Repeats<1, 18446744073709551615, unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing>([Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::group::BraceGroup>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Ident { sym: Option, span: bytes(22861..22867) })) }, delimiter: Some(Nothing) }, Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::group::BraceGroup>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>> { first: Operator<'<'>, second: [Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::operator::Operator<'>'>>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Ident { sym: usize, span: bytes(22868..22873) })) }], third: Operator<'>'> })) }, delimiter: Some(Nothing) }]) }), where_clause: None, body: BraceGroup(Group { delimiter: Brace, stream: TokenStream [Ident { sym: let, span: bytes(22885..22888) }, Ident { sym: section_idx, span: bytes(22889..22900) }, Punct { char: '=', spacing: Alone, span: bytes(22901..22902) }, Ident { sym: self, span: bytes(22903..22907) }, Punct { char: '.', spacing: Alone, span: bytes(22907..22908) }, Ident { sym: get_current_section_index, span: bytes(22908..22933) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(22933..22935) }, Punct { char: '?', spacing: Joint, span: bytes(22935..22936) }, Punct { char: ';', spacing: Alone, span: bytes(22936..22937) }, Ident { sym: let, span: bytes(22946..22949) }, Ident { sym: current_level, span: bytes(22950..22963) }, Punct { char: '=', spacing: Alone, span: bytes(22964..22965) }, Ident { sym: self, span: bytes(22966..22970) }, Punct { char: '.', spacing: Alone, span: bytes(22970..22971) }, Ident { sym: sections, span: bytes(22971..22979) }, Group { delimiter: Bracket, stream: TokenStream [Ident { sym: section_idx, span: bytes(22980..22991) }], span: bytes(22979..22992) }, Punct { char: '.', spacing: Alone, span: bytes(22992..22993) }, Ident { sym: level, span: bytes(22993..22998) }, Punct { char: ';', spacing: Alone, span: bytes(22998..22999) }, Ident { sym: for, span: bytes(23009..23012) }, Ident { sym: i, span: bytes(23013..23014) }, Ident { sym: in, span: bytes(23015..23017) }, Literal { lit: 0, span: bytes(23018..23019) }, Punct { char: '.', spacing: Joint, span: bytes(23019..23020) }, Punct { char: '.', spacing: Alone, span: bytes(23020..23021) }, Ident { sym: self, span: bytes(23021..23025) }, Punct { char: '.', spacing: Alone, span: bytes(23025..23026) }, Ident { sym: sections, span: bytes(23026..23034) }, Punct { char: '.', spacing: Alone, span: bytes(23034..23035) }, Ident { sym: len, span: bytes(23035..23038) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(23038..23040) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: if, span: bytes(23055..23057) }, Ident { sym: self, span: bytes(23058..23062) }, Punct { char: '.', spacing: Alone, span: bytes(23062..23063) }, Ident { sym: sections, span: bytes(23063..23071) }, Group { delimiter: Bracket, stream: TokenStream [Ident { sym: i, span: bytes(23072..23073) }], span: bytes(23071..23074) }, Punct { char: '.', spacing: Alone, span: bytes(23074..23075) }, Ident { sym: level, span: bytes(23075..23080) }, Punct { char: '=', spacing: Joint, span: bytes(23081..23082) }, Punct { char: '=', spacing: Alone, span: bytes(23082..23083) }, Ident { sym: current_level, span: bytes(23084..23097) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: return, span: bytes(23116..23122) }, Ident { sym: self, span: bytes(23123..23127) }, Punct { char: '.', spacing: Alone, span: bytes(23148..23149) }, Ident { sym: tree_nodes, span: bytes(23149..23159) }, Punct { char: '.', spacing: Alone, span: bytes(23180..23181) }, Ident { sym: iter, span: bytes(23181..23185) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(23185..23187) }, Punct { char: '.', spacing: Alone, span: bytes(23208..23209) }, Ident { sym: position, span: bytes(23209..23217) }, Group { delimiter: Parenthesis, stream: TokenStream [Punct { char: '|', spacing: Alone, span: bytes(23218..23219) }, Ident { sym: n, span: bytes(23219..23220) }, Punct { char: '|', spacing: Alone, span: bytes(23220..23221) }, Ident { sym: n, span: bytes(23222..23223) }, Punct { char: '.', spacing: Alone, span: bytes(23223..23224) }, Ident { sym: section_index, span: bytes(23224..23237) }, Punct { char: '=', spacing: Joint, span: bytes(23238..23239) }, Punct { char: '=', spacing: Alone, span: bytes(23239..23240) }, Ident { sym: Some, span: bytes(23241..23245) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: i, span: bytes(23246..23247) }], span: bytes(23245..23248) }], span: bytes(23217..23249) }, Punct { char: ';', spacing: Alone, span: bytes(23249..23250) }], span: bytes(23098..23264) }], span: bytes(23041..23274) }, Ident { sym: None, span: bytes(23284..23288) }], span: bytes(22875..23294) }) })
[SYNCDOC DEBUG] Processing item type: Function
[SYNCDOC DEBUG] Processing item: Function(FnSig { attributes: Some(Repeats<1, 18446744073709551615, syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing>([Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: doc, span: bytes(23300..23355) }, Punct { char: '=', spacing: Alone, span: bytes(23300..23355) }, Literal { lit: " Finds the last section at the same hierarchy level.", span: bytes(23300..23355) }], span: bytes(23300..23355) }) }, delimiter: Some(Nothing) }, Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: must_use, span: bytes(23362..23370) }], span: bytes(23361..23371) }) }, delimiter: Some(Nothing) }])), visibility: Some(Public(KPub(Cached<proc_macro2::Ident> { value: Ident { sym: pub, span: bytes(23376..23379) }, string: "pub" }))), const_kw: None, async_kw: None, unsafe_kw: None, extern_kw: None, _fn: KFn(Cached<proc_macro2::Ident> { value: Ident { sym: fn, span: bytes(23380..23382) }, string: "fn" }), name: Ident { sym: navigate_to_last_at_level, span: bytes(23383..23408) }, generics: None, params: ParenthesisGroupContaining < core::option::Option<unsynn::container::DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>>>(Some(DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>([Delimited<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>> { value: SelfParam(Ref(Cons<unsynn::operator::Operator<'&'>, syncdoc_core::parse::KSelf> { first: Operator<'&'>, second: KSelf(Cached<proc_macro2::Ident> { value: Ident { sym: self, span: bytes(23410..23414) }, string: "self" }) })), delimiter: None }]))), return_type: Some(ReturnTypeFn { _arrow: Operator<'->'>, return_type: Repeats<1, 18446744073709551615, unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing>([Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::group::BraceGroup>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Ident { sym: Option, span: bytes(23419..23425) })) }, delimiter: Some(Nothing) }, Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::group::BraceGroup>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>> { first: Operator<'<'>, second: [Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::operator::Operator<'>'>>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Ident { sym: usize, span: bytes(23426..23431) })) }], third: Operator<'>'> })) }, delimiter: Some(Nothing) }]) }), where_clause: None, body: BraceGroup(Group { delimiter: Brace, stream: TokenStream [Ident { sym: let, span: bytes(23443..23446) }, Ident { sym: section_idx, span: bytes(23447..23458) }, Punct { char: '=', spacing: Alone, span: bytes(23459..23460) }, Ident { sym: self, span: bytes(23461..23465) }, Punct { char: '.', spacing: Alone, span: bytes(23465..23466) }, Ident { sym: get_current_section_index, span: bytes(23466..23491) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(23491..23493) }, Punct { char: '?', spacing: Joint, span: bytes(23493..23494) }, Punct { char: ';', spacing: Alone, span: bytes(23494..23495) }, Ident { sym: let, span: bytes(23504..23507) }, Ident { sym: current_level, span: bytes(23508..23521) }, Punct { char: '=', spacing: Alone, span: bytes(23522..23523) }, Ident { sym: self, span: bytes(23524..23528) }, Punct { char: '.', spacing: Alone, span: bytes(23528..23529) }, Ident { sym: sections, span: bytes(23529..23537) }, Group { delimiter: Bracket, stream: TokenStream [Ident { sym: section_idx, span: bytes(23538..23549) }], span: bytes(23537..23550) }, Punct { char: '.', spacing: Alone, span: bytes(23550..23551) }, Ident { sym: level, span: bytes(23551..23556) }, Punct { char: ';', spacing: Alone, span: bytes(23556..23557) }, Ident { sym: for, span: bytes(23567..23570) }, Ident { sym: i, span: bytes(23571..23572) }, Ident { sym: in, span: bytes(23573..23575) }, Group { delimiter: Parenthesis, stream: TokenStream [Literal { lit: 0, span: bytes(23577..23578) }, Punct { char: '.', spacing: Joint, span: bytes(23578..23579) }, Punct { char: '.', spacing: Alone, span: bytes(23579..23580) }, Ident { sym: self, span: bytes(23580..23584) }, Punct { char: '.', spacing: Alone, span: bytes(23584..23585) }, Ident { sym: sections, span: bytes(23585..23593) }, Punct { char: '.', spacing: Alone, span: bytes(23593..23594) }, Ident { sym: len, span: bytes(23594..23597) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(23597..23599) }], span: bytes(23576..23600) }, Punct { char: '.', spacing: Alone, span: bytes(23600..23601) }, Ident { sym: rev, span: bytes(23601..23604) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(23604..23606) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: if, span: bytes(23621..23623) }, Ident { sym: self, span: bytes(23624..23628) }, Punct { char: '.', spacing: Alone, span: bytes(23628..23629) }, Ident { sym: sections, span: bytes(23629..23637) }, Group { delimiter: Bracket, stream: TokenStream [Ident { sym: i, span: bytes(23638..23639) }], span: bytes(23637..23640) }, Punct { char: '.', spacing: Alone, span: bytes(23640..23641) }, Ident { sym: level, span: bytes(23641..23646) }, Punct { char: '=', spacing: Joint, span: bytes(23647..23648) }, Punct { char: '=', spacing: Alone, span: bytes(23648..23649) }, Ident { sym: current_level, span: bytes(23650..23663) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: return, span: bytes(23682..23688) }, Ident { sym: self, span: bytes(23689..23693) }, Punct { char: '.', spacing: Alone, span: bytes(23714..23715) }, Ident { sym: tree_nodes, span: bytes(23715..23725) }, Punct { char: '.', spacing: Alone, span: bytes(23746..23747) }, Ident { sym: iter, span: bytes(23747..23751) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(23751..23753) }, Punct { char: '.', spacing: Alone, span: bytes(23774..23775) }, Ident { sym: position, span: bytes(23775..23783) }, Group { delimiter: Parenthesis, stream: TokenStream [Punct { char: '|', spacing: Alone, span: bytes(23784..23785) }, Ident { sym: n, span: bytes(23785..23786) }, Punct { char: '|', spacing: Alone, span: bytes(23786..23787) }, Ident { sym: n, span: bytes(23788..23789) }, Punct { char: '.', spacing: Alone, span: bytes(23789..23790) }, Ident { sym: section_index, span: bytes(23790..23803) }, Punct { char: '=', spacing: Joint, span: bytes(23804..23805) }, Punct { char: '=', spacing: Alone, span: bytes(23805..23806) }, Ident { sym: Some, span: bytes(23807..23811) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: i, span: bytes(23812..23813) }], span: bytes(23811..23814) }], span: bytes(23783..23815) }, Punct { char: ';', spacing: Alone, span: bytes(23815..23816) }], span: bytes(23664..23830) }], span: bytes(23607..23840) }, Ident { sym: None, span: bytes(23850..23854) }], span: bytes(23433..23860) }) })
[SYNCDOC DEBUG] Processing item type: Function
[SYNCDOC DEBUG] Processing item: Function(FnSig { attributes: Some(Repeats<1, 18446744073709551615, syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing>([Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: doc, span: bytes(23866..23930) }, Punct { char: '=', spacing: Alone, span: bytes(23866..23930) }, Literal { lit: " Calculates indentation width based on section nesting level.", span: bytes(23866..23930) }], span: bytes(23866..23930) }) }, delimiter: Some(Nothing) }, Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: must_use, span: bytes(23937..23945) }], span: bytes(23936..23946) }) }, delimiter: Some(Nothing) }])), visibility: Some(Public(KPub(Cached<proc_macro2::Ident> { value: Ident { sym: pub, span: bytes(23951..23954) }, string: "pub" }))), const_kw: None, async_kw: None, unsafe_kw: None, extern_kw: None, _fn: KFn(Cached<proc_macro2::Ident> { value: Ident { sym: fn, span: bytes(23955..23957) }, string: "fn" }), name: Ident { sym: get_indent, span: bytes(23958..23968) }, generics: None, params: ParenthesisGroupContaining < core::option::Option<unsynn::container::DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>>>(Some(DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>([Delimited<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>> { value: SelfParam(Ref(Cons<unsynn::operator::Operator<'&'>, syncdoc_core::parse::KSelf> { first: Operator<'&'>, second: KSelf(Cached<proc_macro2::Ident> { value: Ident { sym: self, span: bytes(23970..23974) }, string: "self" }) })), delimiter: None }]))), return_type: Some(ReturnTypeFn { _arrow: Operator<'->'>, return_type: Repeats<1, 18446744073709551615, unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing>([Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::group::BraceGroup>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Ident { sym: usize, span: bytes(23979..23984) })) }, delimiter: Some(Nothing) }]) }), where_clause: None, body: BraceGroup(Group { delimiter: Brace, stream: TokenStream [Ident { sym: if, span: bytes(23995..23997) }, Ident { sym: let, span: bytes(23998..24001) }, Ident { sym: Some, span: bytes(24002..24006) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: section, span: bytes(24007..24014) }], span: bytes(24006..24015) }, Punct { char: '=', spacing: Alone, span: bytes(24016..24017) }, Ident { sym: self, span: bytes(24018..24022) }, Punct { char: '.', spacing: Alone, span: bytes(24022..24023) }, Ident { sym: get_current_section, span: bytes(24023..24042) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(24042..24044) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: section, span: bytes(24059..24066) }, Punct { char: '.', spacing: Alone, span: bytes(24066..24067) }, Ident { sym: level, span: bytes(24067..24072) }, Punct { char: '*', spacing: Alone, span: bytes(24073..24074) }, Literal { lit: 2, span: bytes(24075..24076) }], span: bytes(24045..24086) }, Ident { sym: else, span: bytes(24087..24091) }, Group { delimiter: Brace, stream: TokenStream [Literal { lit: 0, span: bytes(24106..24107) }], span: bytes(24092..24117) }], span: bytes(23985..24123) }) })
[SYNCDOC DEBUG] Processing item type: Function
[SYNCDOC DEBUG] Processing item: Function(FnSig { attributes: Some(Repeats<1, 18446744073709551615, syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing>([Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: doc, span: bytes(24129..24202) }, Punct { char: '=', spacing: Alone, span: bytes(24129..24202) }, Literal { lit: " Determines available width for text after accounting for indentation.", span: bytes(24129..24202) }], span: bytes(24129..24202) }) }, delimiter: Some(Nothing) }, Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: must_use, span: bytes(24209..24217) }], span: bytes(24208..24218) }) }, delimiter: Some(Nothing) }])), visibility: Some(Public(KPub(Cached<proc_macro2::Ident> { value: Ident { sym: pub, span: bytes(24223..24226) }, string: "pub" }))), const_kw: None, async_kw: None, unsafe_kw: None, extern_kw: None, _fn: KFn(Cached<proc_macro2::Ident> { value: Ident { sym: fn, span: bytes(24227..24229) }, string: "fn" }), name: Ident { sym: get_max_line_width, span: bytes(24230..24248) }, generics: None, params: ParenthesisGroupContaining < core::option::Option<unsynn::container::DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>>>(Some(DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>([Delimited<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>> { value: SelfParam(Ref(Cons<unsynn::operator::Operator<'&'>, syncdoc_core::parse::KSelf> { first: Operator<'&'>, second: KSelf(Cached<proc_macro2::Ident> { value: Ident { sym: self, span: bytes(24250..24254) }, string: "self" }) })), delimiter: None }]))), return_type: Some(ReturnTypeFn { _arrow: Operator<'->'>, return_type: Repeats<1, 18446744073709551615, unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing>([Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::group::BraceGroup>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Ident { sym: usize, span: bytes(24259..24264) })) }, delimiter: Some(Nothing) }]) }), where_clause: None, body: BraceGroup(Group { delimiter: Brace, stream: TokenStream [Ident { sym: let, span: bytes(24275..24278) }, Ident { sym: indent, span: bytes(24279..24285) }, Punct { char: '=', spacing: Alone, span: bytes(24286..24287) }, Ident { sym: self, span: bytes(24288..24292) }, Punct { char: '.', spacing: Alone, span: bytes(24292..24293) }, Ident { sym: get_indent, span: bytes(24293..24303) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(24303..24305) }, Punct { char: ';', spacing: Alone, span: bytes(24305..24306) }, Ident { sym: self, span: bytes(24315..24319) }, Punct { char: '.', spacing: Alone, span: bytes(24319..24320) }, Ident { sym: wrap_width, span: bytes(24320..24330) }, Punct { char: '.', spacing: Alone, span: bytes(24330..24331) }, Ident { sym: saturating_sub, span: bytes(24331..24345) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: indent, span: bytes(24346..24352) }], span: bytes(24345..24353) }], span: bytes(24265..24359) }) })
[SYNCDOC DEBUG] Processing item type: Function
[SYNCDOC DEBUG] Processing item: Function(FnSig { attributes: Some(Repeats<1, 18446744073709551615, syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing>([Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: doc, span: bytes(24403..24439) }, Punct { char: '=', spacing: Alone, span: bytes(24403..24439) }, Literal { lit: " Start moving the current section", span: bytes(24403..24439) }], span: bytes(24403..24439) }) }, delimiter: Some(Nothing) }])), visibility: Some(Public(KPub(Cached<proc_macro2::Ident> { value: Ident { sym: pub, span: bytes(24444..24447) }, string: "pub" }))), const_kw: None, async_kw: None, unsafe_kw: None, extern_kw: None, _fn: KFn(Cached<proc_macro2::Ident> { value: Ident { sym: fn, span: bytes(24448..24450) }, string: "fn" }), name: Ident { sym: start_move, span: bytes(24451..24461) }, generics: None, params: ParenthesisGroupContaining < core::option::Option<unsynn::container::DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>>>(Some(DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>([Delimited<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>> { value: SelfParam(RefMut(Cons<unsynn::operator::Operator<'&'>, unsynn::combinator::Cons<syncdoc_core::parse::KMut, syncdoc_core::parse::KSelf>> { first: Operator<'&'>, second: Cons<syncdoc_core::parse::KMut, syncdoc_core::parse::KSelf> { first: KMut(Cached<proc_macro2::Ident> { value: Ident { sym: mut, span: bytes(24463..24466) }, string: "mut" }), second: KSelf(Cached<proc_macro2::Ident> { value: Ident { sym: self, span: bytes(24467..24471) }, string: "self" }) } })), delimiter: None }]))), return_type: None, where_clause: None, body: BraceGroup(Group { delimiter: Brace, stream: TokenStream [Ident { sym: if, span: bytes(24483..24485) }, Ident { sym: let, span: bytes(24486..24489) }, Ident { sym: Some, span: bytes(24490..24494) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: section_idx, span: bytes(24495..24506) }], span: bytes(24494..24507) }, Punct { char: '=', spacing: Alone, span: bytes(24508..24509) }, Ident { sym: self, span: bytes(24510..24514) }, Punct { char: '.', spacing: Alone, span: bytes(24514..24515) }, Ident { sym: get_current_section_index, span: bytes(24515..24540) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(24540..24542) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: self, span: bytes(24557..24561) }, Punct { char: '.', spacing: Alone, span: bytes(24561..24562) }, Ident { sym: moving_section_index, span: bytes(24562..24582) }, Punct { char: '=', spacing: Alone, span: bytes(24583..24584) }, Ident { sym: Some, span: bytes(24585..24589) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: section_idx, span: bytes(24590..24601) }], span: bytes(24589..24602) }, Punct { char: ';', spacing: Alone, span: bytes(24602..24603) }, Ident { sym: self, span: bytes(24616..24620) }, Punct { char: '.', spacing: Alone, span: bytes(24620..24621) }, Ident { sym: move_state, span: bytes(24621..24631) }, Punct { char: '=', spacing: Alone, span: bytes(24632..24633) }, Ident { sym: MoveState, span: bytes(24634..24643) }, Punct { char: ':', spacing: Joint, span: bytes(24643..24644) }, Punct { char: ':', spacing: Alone, span: bytes(24644..24645) }, Ident { sym: Selected, span: bytes(24645..24653) }, Punct { char: ';', spacing: Alone, span: bytes(24653..24654) }], span: bytes(24543..24664) }], span: bytes(24473..24670) }) })
[SYNCDOC DEBUG] Processing item type: Function
[SYNCDOC DEBUG] Processing item: Function(FnSig { attributes: Some(Repeats<1, 18446744073709551615, syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing>([Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: doc, span: bytes(24676..24713) }, Punct { char: '=', spacing: Alone, span: bytes(24676..24713) }, Literal { lit: " Cancel the current move operation", span: bytes(24676..24713) }], span: bytes(24676..24713) }) }, delimiter: Some(Nothing) }])), visibility: Some(Public(KPub(Cached<proc_macro2::Ident> { value: Ident { sym: pub, span: bytes(24718..24721) }, string: "pub" }))), const_kw: None, async_kw: None, unsafe_kw: None, extern_kw: None, _fn: KFn(Cached<proc_macro2::Ident> { value: Ident { sym: fn, span: bytes(24722..24724) }, string: "fn" }), name: Ident { sym: cancel_move, span: bytes(24725..24736) }, generics: None, params: ParenthesisGroupContaining < core::option::Option<unsynn::container::DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>>>(Some(DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>([Delimited<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>> { value: SelfParam(RefMut(Cons<unsynn::operator::Operator<'&'>, unsynn::combinator::Cons<syncdoc_core::parse::KMut, syncdoc_core::parse::KSelf>> { first: Operator<'&'>, second: Cons<syncdoc_core::parse::KMut, syncdoc_core::parse::KSelf> { first: KMut(Cached<proc_macro2::Ident> { value: Ident { sym: mut, span: bytes(24738..24741) }, string: "mut" }), second: KSelf(Cached<proc_macro2::Ident> { value: Ident { sym: self, span: bytes(24742..24746) }, string: "self" }) } })), delimiter: None }]))), return_type: None, where_clause: None, body: BraceGroup(Group { delimiter: Brace, stream: TokenStream [Ident { sym: self, span: bytes(24758..24762) }, Punct { char: '.', spacing: Alone, span: bytes(24762..24763) }, Ident { sym: moving_section_index, span: bytes(24763..24783) }, Punct { char: '=', spacing: Alone, span: bytes(24784..24785) }, Ident { sym: None, span: bytes(24786..24790) }, Punct { char: ';', spacing: Alone, span: bytes(24790..24791) }, Ident { sym: self, span: bytes(24800..24804) }, Punct { char: '.', spacing: Alone, span: bytes(24804..24805) }, Ident { sym: move_state, span: bytes(24805..24815) }, Punct { char: '=', spacing: Alone, span: bytes(24816..24817) }, Ident { sym: MoveState, span: bytes(24818..24827) }, Punct { char: ':', spacing: Joint, span: bytes(24827..24828) }, Punct { char: ':', spacing: Alone, span: bytes(24828..24829) }, Ident { sym: None, span: bytes(24829..24833) }, Punct { char: ';', spacing: Alone, span: bytes(24833..24834) }], span: bytes(24748..24840) }) })
[SYNCDOC DEBUG] Processing item type: Function
[SYNCDOC DEBUG] Processing item: Function(FnSig { attributes: Some(Repeats<1, 18446744073709551615, syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing>([Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: doc, span: bytes(24846..24889) }, Punct { char: '=', spacing: Alone, span: bytes(24846..24889) }, Literal { lit: " Mark section as moved but not yet saved", span: bytes(24846..24889) }], span: bytes(24846..24889) }) }, delimiter: Some(Nothing) }])), visibility: Some(Public(KPub(Cached<proc_macro2::Ident> { value: Ident { sym: pub, span: bytes(24894..24897) }, string: "pub" }))), const_kw: None, async_kw: None, unsafe_kw: None, extern_kw: None, _fn: KFn(Cached<proc_macro2::Ident> { value: Ident { sym: fn, span: bytes(24898..24900) }, string: "fn" }), name: Ident { sym: mark_moved, span: bytes(24901..24911) }, generics: None, params: ParenthesisGroupContaining < core::option::Option<unsynn::container::DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>>>(Some(DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>([Delimited<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>> { value: SelfParam(RefMut(Cons<unsynn::operator::Operator<'&'>, unsynn::combinator::Cons<syncdoc_core::parse::KMut, syncdoc_core::parse::KSelf>> { first: Operator<'&'>, second: Cons<syncdoc_core::parse::KMut, syncdoc_core::parse::KSelf> { first: KMut(Cached<proc_macro2::Ident> { value: Ident { sym: mut, span: bytes(24913..24916) }, string: "mut" }), second: KSelf(Cached<proc_macro2::Ident> { value: Ident { sym: self, span: bytes(24917..24921) }, string: "self" }) } })), delimiter: None }]))), return_type: None, where_clause: None, body: BraceGroup(Group { delimiter: Brace, stream: TokenStream [Ident { sym: self, span: bytes(24933..24937) }, Punct { char: '.', spacing: Alone, span: bytes(24937..24938) }, Ident { sym: move_state, span: bytes(24938..24948) }, Punct { char: '=', spacing: Alone, span: bytes(24949..24950) }, Ident { sym: MoveState, span: bytes(24951..24960) }, Punct { char: ':', spacing: Joint, span: bytes(24960..24961) }, Punct { char: ':', spacing: Alone, span: bytes(24961..24962) }, Ident { sym: Moved, span: bytes(24962..24967) }, Punct { char: ';', spacing: Alone, span: bytes(24967..24968) }], span: bytes(24923..24974) }) })
[SYNCDOC DEBUG] Processing item type: Function
[SYNCDOC DEBUG] Processing item: Function(FnSig { attributes: Some(Repeats<1, 18446744073709551615, syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing>([Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: doc, span: bytes(24980..25015) }, Punct { char: '=', spacing: Alone, span: bytes(24980..25015) }, Literal { lit: " Move section up by one position", span: bytes(24980..25015) }], span: bytes(24980..25015) }) }, delimiter: Some(Nothing) }])), visibility: Some(Public(KPub(Cached<proc_macro2::Ident> { value: Ident { sym: pub, span: bytes(25020..25023) }, string: "pub" }))), const_kw: None, async_kw: None, unsafe_kw: None, extern_kw: None, _fn: KFn(Cached<proc_macro2::Ident> { value: Ident { sym: fn, span: bytes(25024..25026) }, string: "fn" }), name: Ident { sym: move_section_up, span: bytes(25027..25042) }, generics: None, params: ParenthesisGroupContaining < core::option::Option<unsynn::container::DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>>>(Some(DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>([Delimited<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>> { value: SelfParam(RefMut(Cons<unsynn::operator::Operator<'&'>, unsynn::combinator::Cons<syncdoc_core::parse::KMut, syncdoc_core::parse::KSelf>> { first: Operator<'&'>, second: Cons<syncdoc_core::parse::KMut, syncdoc_core::parse::KSelf> { first: KMut(Cached<proc_macro2::Ident> { value: Ident { sym: mut, span: bytes(25044..25047) }, string: "mut" }), second: KSelf(Cached<proc_macro2::Ident> { value: Ident { sym: self, span: bytes(25048..25052) }, string: "self" }) } })), delimiter: None }]))), return_type: Some(ReturnTypeFn { _arrow: Operator<'->'>, return_type: Repeats<1, 18446744073709551615, unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing>([Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::group::BraceGroup>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Ident { sym: bool, span: bytes(25057..25061) })) }, delimiter: Some(Nothing) }]) }), where_clause: None, body: BraceGroup(Group { delimiter: Brace, stream: TokenStream [Ident { sym: if, span: bytes(25072..25074) }, Ident { sym: let, span: bytes(25075..25078) }, Ident { sym: Some, span: bytes(25079..25083) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: moving_idx, span: bytes(25084..25094) }], span: bytes(25083..25095) }, Punct { char: '=', spacing: Alone, span: bytes(25096..25097) }, Ident { sym: self, span: bytes(25098..25102) }, Punct { char: '.', spacing: Alone, span: bytes(25102..25103) }, Ident { sym: moving_section_index, span: bytes(25103..25123) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: if, span: bytes(25138..25140) }, Ident { sym: moving_idx, span: bytes(25141..25151) }, Punct { char: '>', spacing: Alone, span: bytes(25152..25153) }, Literal { lit: 0, span: bytes(25154..25155) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: self, span: bytes(25174..25178) }, Punct { char: '.', spacing: Alone, span: bytes(25178..25179) }, Ident { sym: sections, span: bytes(25179..25187) }, Punct { char: '.', spacing: Alone, span: bytes(25187..25188) }, Ident { sym: swap, span: bytes(25188..25192) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: moving_idx, span: bytes(25193..25203) }, Punct { char: ',', spacing: Alone, span: bytes(25203..25204) }, Ident { sym: moving_idx, span: bytes(25205..25215) }, Punct { char: '-', spacing: Alone, span: bytes(25216..25217) }, Literal { lit: 1, span: bytes(25218..25219) }], span: bytes(25192..25220) }, Punct { char: ';', spacing: Alone, span: bytes(25220..25221) }, Ident { sym: self, span: bytes(25238..25242) }, Punct { char: '.', spacing: Alone, span: bytes(25242..25243) }, Ident { sym: moving_section_index, span: bytes(25243..25263) }, Punct { char: '=', spacing: Alone, span: bytes(25264..25265) }, Ident { sym: Some, span: bytes(25266..25270) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: moving_idx, span: bytes(25271..25281) }, Punct { char: '-', spacing: Alone, span: bytes(25282..25283) }, Literal { lit: 1, span: bytes(25284..25285) }], span: bytes(25270..25286) }, Punct { char: ';', spacing: Alone, span: bytes(25286..25287) }, Ident { sym: self, span: bytes(25304..25308) }, Punct { char: '.', spacing: Alone, span: bytes(25308..25309) }, Ident { sym: rebuild_tree, span: bytes(25309..25321) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(25321..25323) }, Punct { char: ';', spacing: Alone, span: bytes(25323..25324) }, Ident { sym: if, span: bytes(25409..25411) }, Ident { sym: let, span: bytes(25412..25415) }, Ident { sym: Some, span: bytes(25416..25420) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: node_idx, span: bytes(25421..25429) }], span: bytes(25420..25430) }, Punct { char: '=', spacing: Alone, span: bytes(25431..25432) }, Ident { sym: self, span: bytes(25433..25437) }, Punct { char: '.', spacing: Alone, span: bytes(25458..25459) }, Ident { sym: tree_nodes, span: bytes(25459..25469) }, Punct { char: '.', spacing: Alone, span: bytes(25490..25491) }, Ident { sym: iter, span: bytes(25491..25495) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(25495..25497) }, Punct { char: '.', spacing: Alone, span: bytes(25518..25519) }, Ident { sym: position, span: bytes(25519..25527) }, Group { delimiter: Parenthesis, stream: TokenStream [Punct { char: '|', spacing: Alone, span: bytes(25528..25529) }, Ident { sym: n, span: bytes(25529..25530) }, Punct { char: '|', spacing: Alone, span: bytes(25530..25531) }, Ident { sym: n, span: bytes(25532..25533) }, Punct { char: '.', spacing: Alone, span: bytes(25533..25534) }, Ident { sym: section_index, span: bytes(25534..25547) }, Punct { char: '=', spacing: Joint, span: bytes(25548..25549) }, Punct { char: '=', spacing: Alone, span: bytes(25549..25550) }, Ident { sym: Some, span: bytes(25551..25555) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: moving_idx, span: bytes(25556..25566) }, Punct { char: '-', spacing: Alone, span: bytes(25567..25568) }, Literal { lit: 1, span: bytes(25569..25570) }], span: bytes(25555..25571) }], span: bytes(25527..25572) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: self, span: bytes(25611..25615) }, Punct { char: '.', spacing: Alone, span: bytes(25615..25616) }, Ident { sym: current_node_index, span: bytes(25616..25634) }, Punct { char: '=', spacing: Alone, span: bytes(25635..25636) }, Ident { sym: node_idx, span: bytes(25637..25645) }, Punct { char: ';', spacing: Alone, span: bytes(25645..25646) }], span: bytes(25589..25664) }, Ident { sym: self, span: bytes(25682..25686) }, Punct { char: '.', spacing: Alone, span: bytes(25686..25687) }, Ident { sym: mark_moved, span: bytes(25687..25697) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(25697..25699) }, Punct { char: ';', spacing: Alone, span: bytes(25699..25700) }, Ident { sym: return, span: bytes(25717..25723) }, Ident { sym: true, span: bytes(25724..25728) }, Punct { char: ';', spacing: Alone, span: bytes(25728..25729) }], span: bytes(25156..25743) }], span: bytes(25124..25753) }, Ident { sym: false, span: bytes(25762..25767) }], span: bytes(25062..25773) }) })
[SYNCDOC DEBUG] Processing item type: Function
[SYNCDOC DEBUG] Processing item: Function(FnSig { attributes: Some(Repeats<1, 18446744073709551615, syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing>([Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: doc, span: bytes(25779..25816) }, Punct { char: '=', spacing: Alone, span: bytes(25779..25816) }, Literal { lit: " Move section down by one position", span: bytes(25779..25816) }], span: bytes(25779..25816) }) }, delimiter: Some(Nothing) }])), visibility: Some(Public(KPub(Cached<proc_macro2::Ident> { value: Ident { sym: pub, span: bytes(25821..25824) }, string: "pub" }))), const_kw: None, async_kw: None, unsafe_kw: None, extern_kw: None, _fn: KFn(Cached<proc_macro2::Ident> { value: Ident { sym: fn, span: bytes(25825..25827) }, string: "fn" }), name: Ident { sym: move_section_down, span: bytes(25828..25845) }, generics: None, params: ParenthesisGroupContaining < core::option::Option<unsynn::container::DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>>>(Some(DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>([Delimited<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>> { value: SelfParam(RefMut(Cons<unsynn::operator::Operator<'&'>, unsynn::combinator::Cons<syncdoc_core::parse::KMut, syncdoc_core::parse::KSelf>> { first: Operator<'&'>, second: Cons<syncdoc_core::parse::KMut, syncdoc_core::parse::KSelf> { first: KMut(Cached<proc_macro2::Ident> { value: Ident { sym: mut, span: bytes(25847..25850) }, string: "mut" }), second: KSelf(Cached<proc_macro2::Ident> { value: Ident { sym: self, span: bytes(25851..25855) }, string: "self" }) } })), delimiter: None }]))), return_type: Some(ReturnTypeFn { _arrow: Operator<'->'>, return_type: Repeats<1, 18446744073709551615, unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing>([Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::group::BraceGroup>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Ident { sym: bool, span: bytes(25860..25864) })) }, delimiter: Some(Nothing) }]) }), where_clause: None, body: BraceGroup(Group { delimiter: Brace, stream: TokenStream [Ident { sym: if, span: bytes(25875..25877) }, Ident { sym: let, span: bytes(25878..25881) }, Ident { sym: Some, span: bytes(25882..25886) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: moving_idx, span: bytes(25887..25897) }], span: bytes(25886..25898) }, Punct { char: '=', spacing: Alone, span: bytes(25899..25900) }, Ident { sym: self, span: bytes(25901..25905) }, Punct { char: '.', spacing: Alone, span: bytes(25905..25906) }, Ident { sym: moving_section_index, span: bytes(25906..25926) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: if, span: bytes(25941..25943) }, Ident { sym: moving_idx, span: bytes(25944..25954) }, Punct { char: '<', spacing: Alone, span: bytes(25955..25956) }, Ident { sym: self, span: bytes(25957..25961) }, Punct { char: '.', spacing: Alone, span: bytes(25961..25962) }, Ident { sym: sections, span: bytes(25962..25970) }, Punct { char: '.', spacing: Alone, span: bytes(25970..25971) }, Ident { sym: len, span: bytes(25971..25974) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(25974..25976) }, Punct { char: '-', spacing: Alone, span: bytes(25977..25978) }, Literal { lit: 1, span: bytes(25979..25980) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: self, span: bytes(25999..26003) }, Punct { char: '.', spacing: Alone, span: bytes(26003..26004) }, Ident { sym: sections, span: bytes(26004..26012) }, Punct { char: '.', spacing: Alone, span: bytes(26012..26013) }, Ident { sym: swap, span: bytes(26013..26017) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: moving_idx, span: bytes(26018..26028) }, Punct { char: ',', spacing: Alone, span: bytes(26028..26029) }, Ident { sym: moving_idx, span: bytes(26030..26040) }, Punct { char: '+', spacing: Alone, span: bytes(26041..26042) }, Literal { lit: 1, span: bytes(26043..26044) }], span: bytes(26017..26045) }, Punct { char: ';', spacing: Alone, span: bytes(26045..26046) }, Ident { sym: self, span: bytes(26063..26067) }, Punct { char: '.', spacing: Alone, span: bytes(26067..26068) }, Ident { sym: moving_section_index, span: bytes(26068..26088) }, Punct { char: '=', spacing: Alone, span: bytes(26089..26090) }, Ident { sym: Some, span: bytes(26091..26095) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: moving_idx, span: bytes(26096..26106) }, Punct { char: '+', spacing: Alone, span: bytes(26107..26108) }, Literal { lit: 1, span: bytes(26109..26110) }], span: bytes(26095..26111) }, Punct { char: ';', spacing: Alone, span: bytes(26111..26112) }, Ident { sym: self, span: bytes(26129..26133) }, Punct { char: '.', spacing: Alone, span: bytes(26133..26134) }, Ident { sym: rebuild_tree, span: bytes(26134..26146) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(26146..26148) }, Punct { char: ';', spacing: Alone, span: bytes(26148..26149) }, Ident { sym: if, span: bytes(26167..26169) }, Ident { sym: let, span: bytes(26170..26173) }, Ident { sym: Some, span: bytes(26174..26178) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: node_idx, span: bytes(26179..26187) }], span: bytes(26178..26188) }, Punct { char: '=', spacing: Alone, span: bytes(26189..26190) }, Ident { sym: self, span: bytes(26191..26195) }, Punct { char: '.', spacing: Alone, span: bytes(26216..26217) }, Ident { sym: tree_nodes, span: bytes(26217..26227) }, Punct { char: '.', spacing: Alone, span: bytes(26248..26249) }, Ident { sym: iter, span: bytes(26249..26253) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(26253..26255) }, Punct { char: '.', spacing: Alone, span: bytes(26276..26277) }, Ident { sym: position, span: bytes(26277..26285) }, Group { delimiter: Parenthesis, stream: TokenStream [Punct { char: '|', spacing: Alone, span: bytes(26286..26287) }, Ident { sym: n, span: bytes(26287..26288) }, Punct { char: '|', spacing: Alone, span: bytes(26288..26289) }, Ident { sym: n, span: bytes(26290..26291) }, Punct { char: '.', spacing: Alone, span: bytes(26291..26292) }, Ident { sym: section_index, span: bytes(26292..26305) }, Punct { char: '=', spacing: Joint, span: bytes(26306..26307) }, Punct { char: '=', spacing: Alone, span: bytes(26307..26308) }, Ident { sym: Some, span: bytes(26309..26313) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: moving_idx, span: bytes(26314..26324) }, Punct { char: '+', spacing: Alone, span: bytes(26325..26326) }, Literal { lit: 1, span: bytes(26327..26328) }], span: bytes(26313..26329) }], span: bytes(26285..26330) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: self, span: bytes(26369..26373) }, Punct { char: '.', spacing: Alone, span: bytes(26373..26374) }, Ident { sym: current_node_index, span: bytes(26374..26392) }, Punct { char: '=', spacing: Alone, span: bytes(26393..26394) }, Ident { sym: node_idx, span: bytes(26395..26403) }, Punct { char: ';', spacing: Alone, span: bytes(26403..26404) }], span: bytes(26347..26422) }, Ident { sym: self, span: bytes(26440..26444) }, Punct { char: '.', spacing: Alone, span: bytes(26444..26445) }, Ident { sym: mark_moved, span: bytes(26445..26455) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(26455..26457) }, Punct { char: ';', spacing: Alone, span: bytes(26457..26458) }, Ident { sym: return, span: bytes(26475..26481) }, Ident { sym: true, span: bytes(26482..26486) }, Punct { char: ';', spacing: Alone, span: bytes(26486..26487) }], span: bytes(25981..26501) }], span: bytes(25927..26511) }, Ident { sym: false, span: bytes(26520..26525) }], span: bytes(25865..26531) }) })
[SYNCDOC DEBUG] Processing item type: Function
[SYNCDOC DEBUG] Processing item: Function(FnSig { attributes: Some(Repeats<1, 18446744073709551615, syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing>([Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: doc, span: bytes(26537..26572) }, Punct { char: '=', spacing: Alone, span: bytes(26537..26572) }, Literal { lit: " Move section to top of document", span: bytes(26537..26572) }], span: bytes(26537..26572) }) }, delimiter: Some(Nothing) }])), visibility: Some(Public(KPub(Cached<proc_macro2::Ident> { value: Ident { sym: pub, span: bytes(26577..26580) }, string: "pub" }))), const_kw: None, async_kw: None, unsafe_kw: None, extern_kw: None, _fn: KFn(Cached<proc_macro2::Ident> { value: Ident { sym: fn, span: bytes(26581..26583) }, string: "fn" }), name: Ident { sym: move_section_to_top, span: bytes(26584..26603) }, generics: None, params: ParenthesisGroupContaining < core::option::Option<unsynn::container::DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>>>(Some(DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>([Delimited<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>> { value: SelfParam(RefMut(Cons<unsynn::operator::Operator<'&'>, unsynn::combinator::Cons<syncdoc_core::parse::KMut, syncdoc_core::parse::KSelf>> { first: Operator<'&'>, second: Cons<syncdoc_core::parse::KMut, syncdoc_core::parse::KSelf> { first: KMut(Cached<proc_macro2::Ident> { value: Ident { sym: mut, span: bytes(26605..26608) }, string: "mut" }), second: KSelf(Cached<proc_macro2::Ident> { value: Ident { sym: self, span: bytes(26609..26613) }, string: "self" }) } })), delimiter: None }]))), return_type: Some(ReturnTypeFn { _arrow: Operator<'->'>, return_type: Repeats<1, 18446744073709551615, unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing>([Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::group::BraceGroup>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Ident { sym: bool, span: bytes(26618..26622) })) }, delimiter: Some(Nothing) }]) }), where_clause: None, body: BraceGroup(Group { delimiter: Brace, stream: TokenStream [Ident { sym: if, span: bytes(26633..26635) }, Ident { sym: let, span: bytes(26636..26639) }, Ident { sym: Some, span: bytes(26640..26644) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: moving_idx, span: bytes(26645..26655) }], span: bytes(26644..26656) }, Punct { char: '=', spacing: Alone, span: bytes(26657..26658) }, Ident { sym: self, span: bytes(26659..26663) }, Punct { char: '.', spacing: Alone, span: bytes(26663..26664) }, Ident { sym: moving_section_index, span: bytes(26664..26684) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: if, span: bytes(26699..26701) }, Ident { sym: moving_idx, span: bytes(26702..26712) }, Punct { char: '>', spacing: Alone, span: bytes(26713..26714) }, Literal { lit: 0, span: bytes(26715..26716) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: let, span: bytes(26735..26738) }, Ident { sym: section, span: bytes(26739..26746) }, Punct { char: '=', spacing: Alone, span: bytes(26747..26748) }, Ident { sym: self, span: bytes(26749..26753) }, Punct { char: '.', spacing: Alone, span: bytes(26753..26754) }, Ident { sym: sections, span: bytes(26754..26762) }, Punct { char: '.', spacing: Alone, span: bytes(26762..26763) }, Ident { sym: remove, span: bytes(26763..26769) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: moving_idx, span: bytes(26770..26780) }], span: bytes(26769..26781) }, Punct { char: ';', spacing: Alone, span: bytes(26781..26782) }, Ident { sym: self, span: bytes(26799..26803) }, Punct { char: '.', spacing: Alone, span: bytes(26803..26804) }, Ident { sym: sections, span: bytes(26804..26812) }, Punct { char: '.', spacing: Alone, span: bytes(26812..26813) }, Ident { sym: insert, span: bytes(26813..26819) }, Group { delimiter: Parenthesis, stream: TokenStream [Literal { lit: 0, span: bytes(26820..26821) }, Punct { char: ',', spacing: Alone, span: bytes(26821..26822) }, Ident { sym: section, span: bytes(26823..26830) }], span: bytes(26819..26831) }, Punct { char: ';', spacing: Alone, span: bytes(26831..26832) }, Ident { sym: self, span: bytes(26849..26853) }, Punct { char: '.', spacing: Alone, span: bytes(26853..26854) }, Ident { sym: moving_section_index, span: bytes(26854..26874) }, Punct { char: '=', spacing: Alone, span: bytes(26875..26876) }, Ident { sym: Some, span: bytes(26877..26881) }, Group { delimiter: Parenthesis, stream: TokenStream [Literal { lit: 0, span: bytes(26882..26883) }], span: bytes(26881..26884) }, Punct { char: ';', spacing: Alone, span: bytes(26884..26885) }, Ident { sym: self, span: bytes(26902..26906) }, Punct { char: '.', spacing: Alone, span: bytes(26906..26907) }, Ident { sym: rebuild_tree, span: bytes(26907..26919) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(26919..26921) }, Punct { char: ';', spacing: Alone, span: bytes(26921..26922) }, Ident { sym: if, span: bytes(26940..26942) }, Ident { sym: let, span: bytes(26943..26946) }, Ident { sym: Some, span: bytes(26947..26951) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: node_idx, span: bytes(26952..26960) }], span: bytes(26951..26961) }, Punct { char: '=', spacing: Alone, span: bytes(26962..26963) }, Ident { sym: self, span: bytes(26964..26968) }, Punct { char: '.', spacing: Alone, span: bytes(26989..26990) }, Ident { sym: tree_nodes, span: bytes(26990..27000) }, Punct { char: '.', spacing: Alone, span: bytes(27021..27022) }, Ident { sym: iter, span: bytes(27022..27026) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(27026..27028) }, Punct { char: '.', spacing: Alone, span: bytes(27049..27050) }, Ident { sym: position, span: bytes(27050..27058) }, Group { delimiter: Parenthesis, stream: TokenStream [Punct { char: '|', spacing: Alone, span: bytes(27059..27060) }, Ident { sym: n, span: bytes(27060..27061) }, Punct { char: '|', spacing: Alone, span: bytes(27061..27062) }, Ident { sym: n, span: bytes(27063..27064) }, Punct { char: '.', spacing: Alone, span: bytes(27064..27065) }, Ident { sym: section_index, span: bytes(27065..27078) }, Punct { char: '=', spacing: Joint, span: bytes(27079..27080) }, Punct { char: '=', spacing: Alone, span: bytes(27080..27081) }, Ident { sym: Some, span: bytes(27082..27086) }, Group { delimiter: Parenthesis, stream: TokenStream [Literal { lit: 0, span: bytes(27087..27088) }], span: bytes(27086..27089) }], span: bytes(27058..27090) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: self, span: bytes(27129..27133) }, Punct { char: '.', spacing: Alone, span: bytes(27133..27134) }, Ident { sym: current_node_index, span: bytes(27134..27152) }, Punct { char: '=', spacing: Alone, span: bytes(27153..27154) }, Ident { sym: node_idx, span: bytes(27155..27163) }, Punct { char: ';', spacing: Alone, span: bytes(27163..27164) }], span: bytes(27107..27182) }, Ident { sym: self, span: bytes(27200..27204) }, Punct { char: '.', spacing: Alone, span: bytes(27204..27205) }, Ident { sym: mark_moved, span: bytes(27205..27215) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(27215..27217) }, Punct { char: ';', spacing: Alone, span: bytes(27217..27218) }, Ident { sym: return, span: bytes(27235..27241) }, Ident { sym: true, span: bytes(27242..27246) }, Punct { char: ';', spacing: Alone, span: bytes(27246..27247) }], span: bytes(26717..27261) }], span: bytes(26685..27271) }, Ident { sym: false, span: bytes(27280..27285) }], span: bytes(26623..27291) }) })
[SYNCDOC DEBUG] Processing item type: Function
[SYNCDOC DEBUG] Processing item: Function(FnSig { attributes: Some(Repeats<1, 18446744073709551615, syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing>([Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: doc, span: bytes(27297..27335) }, Punct { char: '=', spacing: Alone, span: bytes(27297..27335) }, Literal { lit: " Move section to bottom of document", span: bytes(27297..27335) }], span: bytes(27297..27335) }) }, delimiter: Some(Nothing) }])), visibility: Some(Public(KPub(Cached<proc_macro2::Ident> { value: Ident { sym: pub, span: bytes(27340..27343) }, string: "pub" }))), const_kw: None, async_kw: None, unsafe_kw: None, extern_kw: None, _fn: KFn(Cached<proc_macro2::Ident> { value: Ident { sym: fn, span: bytes(27344..27346) }, string: "fn" }), name: Ident { sym: move_section_to_bottom, span: bytes(27347..27369) }, generics: None, params: ParenthesisGroupContaining < core::option::Option<unsynn::container::DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>>>(Some(DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>([Delimited<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>> { value: SelfParam(RefMut(Cons<unsynn::operator::Operator<'&'>, unsynn::combinator::Cons<syncdoc_core::parse::KMut, syncdoc_core::parse::KSelf>> { first: Operator<'&'>, second: Cons<syncdoc_core::parse::KMut, syncdoc_core::parse::KSelf> { first: KMut(Cached<proc_macro2::Ident> { value: Ident { sym: mut, span: bytes(27371..27374) }, string: "mut" }), second: KSelf(Cached<proc_macro2::Ident> { value: Ident { sym: self, span: bytes(27375..27379) }, string: "self" }) } })), delimiter: None }]))), return_type: Some(ReturnTypeFn { _arrow: Operator<'->'>, return_type: Repeats<1, 18446744073709551615, unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing>([Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::group::BraceGroup>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Ident { sym: bool, span: bytes(27384..27388) })) }, delimiter: Some(Nothing) }]) }), where_clause: None, body: BraceGroup(Group { delimiter: Brace, stream: TokenStream [Ident { sym: if, span: bytes(27399..27401) }, Ident { sym: let, span: bytes(27402..27405) }, Ident { sym: Some, span: bytes(27406..27410) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: moving_idx, span: bytes(27411..27421) }], span: bytes(27410..27422) }, Punct { char: '=', spacing: Alone, span: bytes(27423..27424) }, Ident { sym: self, span: bytes(27425..27429) }, Punct { char: '.', spacing: Alone, span: bytes(27429..27430) }, Ident { sym: moving_section_index, span: bytes(27430..27450) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: let, span: bytes(27465..27468) }, Ident { sym: last_idx, span: bytes(27469..27477) }, Punct { char: '=', spacing: Alone, span: bytes(27478..27479) }, Ident { sym: self, span: bytes(27480..27484) }, Punct { char: '.', spacing: Alone, span: bytes(27484..27485) }, Ident { sym: sections, span: bytes(27485..27493) }, Punct { char: '.', spacing: Alone, span: bytes(27493..27494) }, Ident { sym: len, span: bytes(27494..27497) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(27497..27499) }, Punct { char: '-', spacing: Alone, span: bytes(27500..27501) }, Literal { lit: 1, span: bytes(27502..27503) }, Punct { char: ';', spacing: Alone, span: bytes(27503..27504) }, Ident { sym: if, span: bytes(27517..27519) }, Ident { sym: moving_idx, span: bytes(27520..27530) }, Punct { char: '<', spacing: Alone, span: bytes(27531..27532) }, Ident { sym: last_idx, span: bytes(27533..27541) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: let, span: bytes(27560..27563) }, Ident { sym: section, span: bytes(27564..27571) }, Punct { char: '=', spacing: Alone, span: bytes(27572..27573) }, Ident { sym: self, span: bytes(27574..27578) }, Punct { char: '.', spacing: Alone, span: bytes(27578..27579) }, Ident { sym: sections, span: bytes(27579..27587) }, Punct { char: '.', spacing: Alone, span: bytes(27587..27588) }, Ident { sym: remove, span: bytes(27588..27594) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: moving_idx, span: bytes(27595..27605) }], span: bytes(27594..27606) }, Punct { char: ';', spacing: Alone, span: bytes(27606..27607) }, Ident { sym: self, span: bytes(27624..27628) }, Punct { char: '.', spacing: Alone, span: bytes(27628..27629) }, Ident { sym: sections, span: bytes(27629..27637) }, Punct { char: '.', spacing: Alone, span: bytes(27637..27638) }, Ident { sym: push, span: bytes(27638..27642) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: section, span: bytes(27643..27650) }], span: bytes(27642..27651) }, Punct { char: ';', spacing: Alone, span: bytes(27651..27652) }, Ident { sym: self, span: bytes(27669..27673) }, Punct { char: '.', spacing: Alone, span: bytes(27673..27674) }, Ident { sym: moving_section_index, span: bytes(27674..27694) }, Punct { char: '=', spacing: Alone, span: bytes(27695..27696) }, Ident { sym: Some, span: bytes(27697..27701) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: last_idx, span: bytes(27702..27710) }], span: bytes(27701..27711) }, Punct { char: ';', spacing: Alone, span: bytes(27711..27712) }, Ident { sym: self, span: bytes(27729..27733) }, Punct { char: '.', spacing: Alone, span: bytes(27733..27734) }, Ident { sym: rebuild_tree, span: bytes(27734..27746) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(27746..27748) }, Punct { char: ';', spacing: Alone, span: bytes(27748..27749) }, Ident { sym: if, span: bytes(27767..27769) }, Ident { sym: let, span: bytes(27770..27773) }, Ident { sym: Some, span: bytes(27774..27778) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: node_idx, span: bytes(27779..27787) }], span: bytes(27778..27788) }, Punct { char: '=', spacing: Alone, span: bytes(27789..27790) }, Ident { sym: self, span: bytes(27791..27795) }, Punct { char: '.', spacing: Alone, span: bytes(27816..27817) }, Ident { sym: tree_nodes, span: bytes(27817..27827) }, Punct { char: '.', spacing: Alone, span: bytes(27848..27849) }, Ident { sym: iter, span: bytes(27849..27853) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(27853..27855) }, Punct { char: '.', spacing: Alone, span: bytes(27876..27877) }, Ident { sym: position, span: bytes(27877..27885) }, Group { delimiter: Parenthesis, stream: TokenStream [Punct { char: '|', spacing: Alone, span: bytes(27886..27887) }, Ident { sym: n, span: bytes(27887..27888) }, Punct { char: '|', spacing: Alone, span: bytes(27888..27889) }, Ident { sym: n, span: bytes(27890..27891) }, Punct { char: '.', spacing: Alone, span: bytes(27891..27892) }, Ident { sym: section_index, span: bytes(27892..27905) }, Punct { char: '=', spacing: Joint, span: bytes(27906..27907) }, Punct { char: '=', spacing: Alone, span: bytes(27907..27908) }, Ident { sym: Some, span: bytes(27909..27913) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: last_idx, span: bytes(27914..27922) }], span: bytes(27913..27923) }], span: bytes(27885..27924) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: self, span: bytes(27963..27967) }, Punct { char: '.', spacing: Alone, span: bytes(27967..27968) }, Ident { sym: current_node_index, span: bytes(27968..27986) }, Punct { char: '=', spacing: Alone, span: bytes(27987..27988) }, Ident { sym: node_idx, span: bytes(27989..27997) }, Punct { char: ';', spacing: Alone, span: bytes(27997..27998) }], span: bytes(27941..28016) }, Ident { sym: self, span: bytes(28034..28038) }, Punct { char: '.', spacing: Alone, span: bytes(28038..28039) }, Ident { sym: mark_moved, span: bytes(28039..28049) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(28049..28051) }, Punct { char: ';', spacing: Alone, span: bytes(28051..28052) }, Ident { sym: return, span: bytes(28069..28075) }, Ident { sym: true, span: bytes(28076..28080) }, Punct { char: ';', spacing: Alone, span: bytes(28080..28081) }], span: bytes(27542..28095) }], span: bytes(27451..28105) }, Ident { sym: false, span: bytes(28114..28119) }], span: bytes(27389..28125) }) })
[SYNCDOC DEBUG] Processing item type: Function
[SYNCDOC DEBUG] Processing item: Function(FnSig { attributes: Some(Repeats<1, 18446744073709551615, syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing>([Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: doc, span: bytes(28131..28188) }, Punct { char: '=', spacing: Alone, span: bytes(28131..28188) }, Literal { lit: " Increase section level (move in - lower level number)", span: bytes(28131..28188) }], span: bytes(28131..28188) }) }, delimiter: Some(Nothing) }])), visibility: Some(Public(KPub(Cached<proc_macro2::Ident> { value: Ident { sym: pub, span: bytes(28193..28196) }, string: "pub" }))), const_kw: None, async_kw: None, unsafe_kw: None, extern_kw: None, _fn: KFn(Cached<proc_macro2::Ident> { value: Ident { sym: fn, span: bytes(28197..28199) }, string: "fn" }), name: Ident { sym: move_section_in, span: bytes(28200..28215) }, generics: None, params: ParenthesisGroupContaining < core::option::Option<unsynn::container::DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>>>(Some(DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>([Delimited<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>> { value: SelfParam(RefMut(Cons<unsynn::operator::Operator<'&'>, unsynn::combinator::Cons<syncdoc_core::parse::KMut, syncdoc_core::parse::KSelf>> { first: Operator<'&'>, second: Cons<syncdoc_core::parse::KMut, syncdoc_core::parse::KSelf> { first: KMut(Cached<proc_macro2::Ident> { value: Ident { sym: mut, span: bytes(28217..28220) }, string: "mut" }), second: KSelf(Cached<proc_macro2::Ident> { value: Ident { sym: self, span: bytes(28221..28225) }, string: "self" }) } })), delimiter: None }]))), return_type: Some(ReturnTypeFn { _arrow: Operator<'->'>, return_type: Repeats<1, 18446744073709551615, unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing>([Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::group::BraceGroup>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Ident { sym: bool, span: bytes(28230..28234) })) }, delimiter: Some(Nothing) }]) }), where_clause: None, body: BraceGroup(Group { delimiter: Brace, stream: TokenStream [Ident { sym: if, span: bytes(28245..28247) }, Ident { sym: let, span: bytes(28248..28251) }, Ident { sym: Some, span: bytes(28252..28256) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: moving_idx, span: bytes(28257..28267) }], span: bytes(28256..28268) }, Punct { char: '=', spacing: Alone, span: bytes(28269..28270) }, Ident { sym: self, span: bytes(28271..28275) }, Punct { char: '.', spacing: Alone, span: bytes(28275..28276) }, Ident { sym: moving_section_index, span: bytes(28276..28296) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: if, span: bytes(28311..28313) }, Ident { sym: self, span: bytes(28314..28318) }, Punct { char: '.', spacing: Alone, span: bytes(28318..28319) }, Ident { sym: sections, span: bytes(28319..28327) }, Group { delimiter: Bracket, stream: TokenStream [Ident { sym: moving_idx, span: bytes(28328..28338) }], span: bytes(28327..28339) }, Punct { char: '.', spacing: Alone, span: bytes(28339..28340) }, Ident { sym: level, span: bytes(28340..28345) }, Punct { char: '>', spacing: Alone, span: bytes(28346..28347) }, Literal { lit: 1, span: bytes(28348..28349) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: self, span: bytes(28368..28372) }, Punct { char: '.', spacing: Alone, span: bytes(28372..28373) }, Ident { sym: sections, span: bytes(28373..28381) }, Group { delimiter: Bracket, stream: TokenStream [Ident { sym: moving_idx, span: bytes(28382..28392) }], span: bytes(28381..28393) }, Punct { char: '.', spacing: Alone, span: bytes(28393..28394) }, Ident { sym: level, span: bytes(28394..28399) }, Punct { char: '-', spacing: Joint, span: bytes(28400..28401) }, Punct { char: '=', spacing: Alone, span: bytes(28401..28402) }, Literal { lit: 1, span: bytes(28403..28404) }, Punct { char: ';', spacing: Alone, span: bytes(28404..28405) }, Ident { sym: self, span: bytes(28422..28426) }, Punct { char: '.', spacing: Alone, span: bytes(28426..28427) }, Ident { sym: rebuild_tree, span: bytes(28427..28439) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(28439..28441) }, Punct { char: ';', spacing: Alone, span: bytes(28441..28442) }, Ident { sym: self, span: bytes(28459..28463) }, Punct { char: '.', spacing: Alone, span: bytes(28463..28464) }, Ident { sym: mark_moved, span: bytes(28464..28474) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(28474..28476) }, Punct { char: ';', spacing: Alone, span: bytes(28476..28477) }, Ident { sym: return, span: bytes(28494..28500) }, Ident { sym: true, span: bytes(28501..28505) }, Punct { char: ';', spacing: Alone, span: bytes(28505..28506) }], span: bytes(28350..28520) }], span: bytes(28297..28530) }, Ident { sym: false, span: bytes(28539..28544) }], span: bytes(28235..28550) }) })
[SYNCDOC DEBUG] Processing item type: Function
[SYNCDOC DEBUG] Processing item: Function(FnSig { attributes: Some(Repeats<1, 18446744073709551615, syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing>([Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: doc, span: bytes(28556..28615) }, Punct { char: '=', spacing: Alone, span: bytes(28556..28615) }, Literal { lit: " Decrease section level (move out - higher level number)", span: bytes(28556..28615) }], span: bytes(28556..28615) }) }, delimiter: Some(Nothing) }])), visibility: Some(Public(KPub(Cached<proc_macro2::Ident> { value: Ident { sym: pub, span: bytes(28620..28623) }, string: "pub" }))), const_kw: None, async_kw: None, unsafe_kw: None, extern_kw: None, _fn: KFn(Cached<proc_macro2::Ident> { value: Ident { sym: fn, span: bytes(28624..28626) }, string: "fn" }), name: Ident { sym: move_section_out, span: bytes(28627..28643) }, generics: None, params: ParenthesisGroupContaining < core::option::Option<unsynn::container::DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>>>(Some(DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>([Delimited<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>> { value: SelfParam(RefMut(Cons<unsynn::operator::Operator<'&'>, unsynn::combinator::Cons<syncdoc_core::parse::KMut, syncdoc_core::parse::KSelf>> { first: Operator<'&'>, second: Cons<syncdoc_core::parse::KMut, syncdoc_core::parse::KSelf> { first: KMut(Cached<proc_macro2::Ident> { value: Ident { sym: mut, span: bytes(28645..28648) }, string: "mut" }), second: KSelf(Cached<proc_macro2::Ident> { value: Ident { sym: self, span: bytes(28649..28653) }, string: "self" }) } })), delimiter: None }]))), return_type: Some(ReturnTypeFn { _arrow: Operator<'->'>, return_type: Repeats<1, 18446744073709551615, unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing>([Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::group::BraceGroup>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Ident { sym: bool, span: bytes(28658..28662) })) }, delimiter: Some(Nothing) }]) }), where_clause: None, body: BraceGroup(Group { delimiter: Brace, stream: TokenStream [Ident { sym: if, span: bytes(28673..28675) }, Ident { sym: let, span: bytes(28676..28679) }, Ident { sym: Some, span: bytes(28680..28684) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: moving_idx, span: bytes(28685..28695) }], span: bytes(28684..28696) }, Punct { char: '=', spacing: Alone, span: bytes(28697..28698) }, Ident { sym: self, span: bytes(28699..28703) }, Punct { char: '.', spacing: Alone, span: bytes(28703..28704) }, Ident { sym: moving_section_index, span: bytes(28704..28724) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: if, span: bytes(28739..28741) }, Ident { sym: self, span: bytes(28742..28746) }, Punct { char: '.', spacing: Alone, span: bytes(28746..28747) }, Ident { sym: sections, span: bytes(28747..28755) }, Group { delimiter: Bracket, stream: TokenStream [Ident { sym: moving_idx, span: bytes(28756..28766) }], span: bytes(28755..28767) }, Punct { char: '.', spacing: Alone, span: bytes(28767..28768) }, Ident { sym: level, span: bytes(28768..28773) }, Punct { char: '<', spacing: Alone, span: bytes(28774..28775) }, Literal { lit: 6, span: bytes(28776..28777) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: self, span: bytes(28796..28800) }, Punct { char: '.', spacing: Alone, span: bytes(28800..28801) }, Ident { sym: sections, span: bytes(28801..28809) }, Group { delimiter: Bracket, stream: TokenStream [Ident { sym: moving_idx, span: bytes(28810..28820) }], span: bytes(28809..28821) }, Punct { char: '.', spacing: Alone, span: bytes(28821..28822) }, Ident { sym: level, span: bytes(28822..28827) }, Punct { char: '+', spacing: Joint, span: bytes(28828..28829) }, Punct { char: '=', spacing: Alone, span: bytes(28829..28830) }, Literal { lit: 1, span: bytes(28831..28832) }, Punct { char: ';', spacing: Alone, span: bytes(28832..28833) }, Ident { sym: self, span: bytes(28850..28854) }, Punct { char: '.', spacing: Alone, span: bytes(28854..28855) }, Ident { sym: rebuild_tree, span: bytes(28855..28867) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(28867..28869) }, Punct { char: ';', spacing: Alone, span: bytes(28869..28870) }, Ident { sym: self, span: bytes(28887..28891) }, Punct { char: '.', spacing: Alone, span: bytes(28891..28892) }, Ident { sym: mark_moved, span: bytes(28892..28902) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(28902..28904) }, Punct { char: ';', spacing: Alone, span: bytes(28904..28905) }, Ident { sym: return, span: bytes(28922..28928) }, Ident { sym: true, span: bytes(28929..28933) }, Punct { char: ';', spacing: Alone, span: bytes(28933..28934) }], span: bytes(28778..28948) }], span: bytes(28725..28958) }, Ident { sym: false, span: bytes(28967..28972) }], span: bytes(28663..28978) }) })
[SYNCDOC DEBUG] Processing item type: Function
[SYNCDOC DEBUG] Processing item: Function(FnSig { attributes: Some(Repeats<1, 18446744073709551615, syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing>([Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: doc, span: bytes(28984..29020) }, Punct { char: '=', spacing: Alone, span: bytes(28984..29020) }, Literal { lit: " Apply section reordering to disk", span: bytes(28984..29020) }], span: bytes(28984..29020) }) }, delimiter: Some(Nothing) }, Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: doc, span: bytes(29025..29028) }, Punct { char: '=', spacing: Alone, span: bytes(29025..29028) }, Literal { lit: "", span: bytes(29025..29028) }], span: bytes(29025..29028) }) }, delimiter: Some(Nothing) }, Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: doc, span: bytes(29033..29045) }, Punct { char: '=', spacing: Alone, span: bytes(29033..29045) }, Literal { lit: " # Errors", span: bytes(29033..29045) }], span: bytes(29033..29045) }) }, delimiter: Some(Nothing) }, Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: doc, span: bytes(29050..29053) }, Punct { char: '=', spacing: Alone, span: bytes(29050..29053) }, Literal { lit: "", span: bytes(29050..29053) }], span: bytes(29050..29053) }) }, delimiter: Some(Nothing) }, Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: doc, span: bytes(29058..29142) }, Punct { char: '=', spacing: Alone, span: bytes(29058..29142) }, Literal { lit: " Returns an error if writing to disk fails or if file operations cannot complete.", span: bytes(29058..29142) }], span: bytes(29058..29142) }) }, delimiter: Some(Nothing) }])), visibility: Some(Public(KPub(Cached<proc_macro2::Ident> { value: Ident { sym: pub, span: bytes(29147..29150) }, string: "pub" }))), const_kw: None, async_kw: None, unsafe_kw: None, extern_kw: None, _fn: KFn(Cached<proc_macro2::Ident> { value: Ident { sym: fn, span: bytes(29151..29153) }, string: "fn" }), name: Ident { sym: save_section_reorder, span: bytes(29154..29174) }, generics: None, params: ParenthesisGroupContaining < core::option::Option<unsynn::container::DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>>>(Some(DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>([Delimited<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>> { value: SelfParam(RefMut(Cons<unsynn::operator::Operator<'&'>, unsynn::combinator::Cons<syncdoc_core::parse::KMut, syncdoc_core::parse::KSelf>> { first: Operator<'&'>, second: Cons<syncdoc_core::parse::KMut, syncdoc_core::parse::KSelf> { first: KMut(Cached<proc_macro2::Ident> { value: Ident { sym: mut, span: bytes(29176..29179) }, string: "mut" }), second: KSelf(Cached<proc_macro2::Ident> { value: Ident { sym: self, span: bytes(29180..29184) }, string: "self" }) } })), delimiter: None }]))), return_type: Some(ReturnTypeFn { _arrow: Operator<'->'>, return_type: Repeats<1, 18446744073709551615, unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing>([Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::group::BraceGroup>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Ident { sym: io, span: bytes(29189..29191) })) }, delimiter: Some(Nothing) }, Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::group::BraceGroup>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Punct { char: ':', spacing: Joint, span: bytes(29191..29192) })) }, delimiter: Some(Nothing) }, Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::group::BraceGroup>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Punct { char: ':', spacing: Alone, span: bytes(29192..29193) })) }, delimiter: Some(Nothing) }, Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::group::BraceGroup>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Ident { sym: Result, span: bytes(29193..29199) })) }, delimiter: Some(Nothing) }, Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::group::BraceGroup>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>> { first: Operator<'<'>, second: [Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::operator::Operator<'>'>>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(29200..29202) })) }], third: Operator<'>'> })) }, delimiter: Some(Nothing) }]) }), where_clause: None, body: BraceGroup(Group { delimiter: Brace, stream: TokenStream [Ident { sym: if, span: bytes(29214..29216) }, Ident { sym: self, span: bytes(29217..29221) }, Punct { char: '.', spacing: Alone, span: bytes(29221..29222) }, Ident { sym: move_state, span: bytes(29222..29232) }, Punct { char: '!', spacing: Joint, span: bytes(29233..29234) }, Punct { char: '=', spacing: Alone, span: bytes(29234..29235) }, Ident { sym: MoveState, span: bytes(29236..29245) }, Punct { char: ':', spacing: Joint, span: bytes(29245..29246) }, Punct { char: ':', spacing: Alone, span: bytes(29246..29247) }, Ident { sym: Moved, span: bytes(29247..29252) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: return, span: bytes(29267..29273) }, Ident { sym: Ok, span: bytes(29274..29276) }, Group { delimiter: Parenthesis, stream: TokenStream [Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(29277..29279) }], span: bytes(29276..29280) }, Punct { char: ';', spacing: Alone, span: bytes(29280..29281) }], span: bytes(29253..29291) }, Ident { sym: let, span: bytes(29335..29338) }, Ident { sym: mut, span: bytes(29339..29342) }, Ident { sym: file_sections, span: bytes(29343..29356) }, Punct { char: ':', spacing: Alone, span: bytes(29356..29357) }, Ident { sym: HashMap, span: bytes(29358..29365) }, Punct { char: '<', spacing: Alone, span: bytes(29365..29366) }, Ident { sym: String, span: bytes(29366..29372) }, Punct { char: ',', spacing: Alone, span: bytes(29372..29373) }, Ident { sym: Vec, span: bytes(29374..29377) }, Punct { char: '<', spacing: Joint, span: bytes(29377..29378) }, Punct { char: '&', spacing: Alone, span: bytes(29378..29379) }, Ident { sym: Section, span: bytes(29379..29386) }, Punct { char: '>', spacing: Joint, span: bytes(29386..29387) }, Punct { char: '>', spacing: Alone, span: bytes(29387..29388) }, Punct { char: '=', spacing: Alone, span: bytes(29389..29390) }, Ident { sym: HashMap, span: bytes(29391..29398) }, Punct { char: ':', spacing: Joint, span: bytes(29398..29399) }, Punct { char: ':', spacing: Alone, span: bytes(29399..29400) }, Ident { sym: new, span: bytes(29400..29403) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(29403..29405) }, Punct { char: ';', spacing: Alone, span: bytes(29405..29406) }, Ident { sym: for, span: bytes(29415..29418) }, Ident { sym: section, span: bytes(29419..29426) }, Ident { sym: in, span: bytes(29427..29429) }, Punct { char: '&', spacing: Alone, span: bytes(29430..29431) }, Ident { sym: self, span: bytes(29431..29435) }, Punct { char: '.', spacing: Alone, span: bytes(29435..29436) }, Ident { sym: sections, span: bytes(29436..29444) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: file_sections, span: bytes(29459..29472) }, Punct { char: '.', spacing: Alone, span: bytes(29489..29490) }, Ident { sym: entry, span: bytes(29490..29495) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: section, span: bytes(29496..29503) }, Punct { char: '.', spacing: Alone, span: bytes(29503..29504) }, Ident { sym: file_path, span: bytes(29504..29513) }, Punct { char: '.', spacing: Alone, span: bytes(29513..29514) }, Ident { sym: clone, span: bytes(29514..29519) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(29519..29521) }], span: bytes(29495..29522) }, Punct { char: '.', spacing: Alone, span: bytes(29539..29540) }, Ident { sym: or_default, span: bytes(29540..29550) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(29550..29552) }, Punct { char: '.', spacing: Alone, span: bytes(29569..29570) }, Ident { sym: push, span: bytes(29570..29574) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: section, span: bytes(29575..29582) }], span: bytes(29574..29583) }, Punct { char: ';', spacing: Alone, span: bytes(29583..29584) }], span: bytes(29445..29594) }, Ident { sym: for, span: bytes(29633..29636) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: file_path, span: bytes(29638..29647) }, Punct { char: ',', spacing: Alone, span: bytes(29647..29648) }, Ident { sym: sections, span: bytes(29649..29657) }], span: bytes(29637..29658) }, Ident { sym: in, span: bytes(29659..29661) }, Ident { sym: file_sections, span: bytes(29662..29675) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: Self, span: bytes(29690..29694) }, Punct { char: ':', spacing: Joint, span: bytes(29694..29695) }, Punct { char: ':', spacing: Alone, span: bytes(29695..29696) }, Ident { sym: rewrite_file_sections, span: bytes(29696..29717) }, Group { delimiter: Parenthesis, stream: TokenStream [Punct { char: '&', spacing: Alone, span: bytes(29718..29719) }, Ident { sym: file_path, span: bytes(29719..29728) }, Punct { char: ',', spacing: Alone, span: bytes(29728..29729) }, Punct { char: '&', spacing: Alone, span: bytes(29730..29731) }, Ident { sym: sections, span: bytes(29731..29739) }], span: bytes(29717..29740) }, Punct { char: '?', spacing: Joint, span: bytes(29740..29741) }, Punct { char: ';', spacing: Alone, span: bytes(29741..29742) }], span: bytes(29676..29752) }, Ident { sym: let, span: bytes(29814..29817) }, Ident { sym: format, span: bytes(29818..29824) }, Punct { char: '=', spacing: Alone, span: bytes(29825..29826) }, Ident { sym: MarkdownFormat, span: bytes(29827..29841) }, Punct { char: ';', spacing: Alone, span: bytes(29841..29842) }, Ident { sym: let, span: bytes(29851..29854) }, Ident { sym: mut, span: bytes(29855..29858) }, Ident { sym: new_sections, span: bytes(29859..29871) }, Punct { char: '=', spacing: Alone, span: bytes(29872..29873) }, Ident { sym: Vec, span: bytes(29874..29877) }, Punct { char: ':', spacing: Joint, span: bytes(29877..29878) }, Punct { char: ':', spacing: Alone, span: bytes(29878..29879) }, Ident { sym: new, span: bytes(29879..29882) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(29882..29884) }, Punct { char: ';', spacing: Alone, span: bytes(29884..29885) }, Ident { sym: for, span: bytes(29894..29897) }, Ident { sym: file, span: bytes(29898..29902) }, Ident { sym: in, span: bytes(29903..29905) }, Punct { char: '&', spacing: Alone, span: bytes(29906..29907) }, Ident { sym: self, span: bytes(29907..29911) }, Punct { char: '.', spacing: Alone, span: bytes(29911..29912) }, Ident { sym: files, span: bytes(29912..29917) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: if, span: bytes(29932..29934) }, Ident { sym: let, span: bytes(29935..29938) }, Ident { sym: Ok, span: bytes(29939..29941) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: secs, span: bytes(29942..29946) }], span: bytes(29941..29947) }, Punct { char: '=', spacing: Alone, span: bytes(29948..29949) }, Ident { sym: input, span: bytes(29950..29955) }, Punct { char: ':', spacing: Joint, span: bytes(29955..29956) }, Punct { char: ':', spacing: Alone, span: bytes(29956..29957) }, Ident { sym: extract_sections, span: bytes(29957..29973) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: file, span: bytes(29974..29978) }, Punct { char: ',', spacing: Alone, span: bytes(29978..29979) }, Punct { char: '&', spacing: Alone, span: bytes(29980..29981) }, Ident { sym: format, span: bytes(29981..29987) }], span: bytes(29973..29988) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: new_sections, span: bytes(30007..30019) }, Punct { char: '.', spacing: Alone, span: bytes(30019..30020) }, Ident { sym: extend, span: bytes(30020..30026) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: secs, span: bytes(30027..30031) }], span: bytes(30026..30032) }, Punct { char: ';', spacing: Alone, span: bytes(30032..30033) }], span: bytes(29989..30047) }], span: bytes(29918..30057) }, Ident { sym: self, span: bytes(30067..30071) }, Punct { char: '.', spacing: Alone, span: bytes(30071..30072) }, Ident { sym: sections, span: bytes(30072..30080) }, Punct { char: '=', spacing: Alone, span: bytes(30081..30082) }, Ident { sym: new_sections, span: bytes(30083..30095) }, Punct { char: ';', spacing: Alone, span: bytes(30095..30096) }, Ident { sym: self, span: bytes(30105..30109) }, Punct { char: '.', spacing: Alone, span: bytes(30109..30110) }, Ident { sym: rebuild_tree, span: bytes(30110..30122) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(30122..30124) }, Punct { char: ';', spacing: Alone, span: bytes(30124..30125) }, Ident { sym: self, span: bytes(30134..30138) }, Punct { char: '.', spacing: Alone, span: bytes(30138..30139) }, Ident { sym: cancel_move, span: bytes(30139..30150) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(30150..30152) }, Punct { char: ';', spacing: Alone, span: bytes(30152..30153) }, Ident { sym: self, span: bytes(30162..30166) }, Punct { char: '.', spacing: Alone, span: bytes(30166..30167) }, Ident { sym: message, span: bytes(30167..30174) }, Punct { char: '=', spacing: Alone, span: bytes(30175..30176) }, Ident { sym: Some, span: bytes(30177..30181) }, Group { delimiter: Parenthesis, stream: TokenStream [Literal { lit: "Sections reordered", span: bytes(30182..30202) }, Punct { char: '.', spacing: Alone, span: bytes(30202..30203) }, Ident { sym: to_string, span: bytes(30203..30212) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(30212..30214) }], span: bytes(30181..30215) }, Punct { char: ';', spacing: Alone, span: bytes(30215..30216) }, Ident { sym: Ok, span: bytes(30226..30228) }, Group { delimiter: Parenthesis, stream: TokenStream [Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(30229..30231) }], span: bytes(30228..30232) }], span: bytes(29204..30238) }) })
[SYNCDOC DEBUG] Processing item type: Function
[SYNCDOC DEBUG] Processing item: Function(FnSig { attributes: Some(Repeats<1, 18446744073709551615, syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing>([Delimited<syncdoc_core::parse::Attribute, unsynn::fundamental::Nothing> { value: Attribute { _hash: Operator<'#'>, content: BracketGroup(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: doc, span: bytes(30244..30294) }, Punct { char: '=', spacing: Alone, span: bytes(30244..30294) }, Literal { lit: " Rewrite an entire file with reordered sections", span: bytes(30244..30294) }], span: bytes(30244..30294) }) }, delimiter: Some(Nothing) }])), visibility: None, const_kw: None, async_kw: None, unsafe_kw: None, extern_kw: None, _fn: KFn(Cached<proc_macro2::Ident> { value: Ident { sym: fn, span: bytes(30299..30301) }, string: "fn" }), name: Ident { sym: rewrite_file_sections, span: bytes(30302..30323) }, generics: None, params: ParenthesisGroupContaining < core::option::Option<unsynn::container::DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>>>(Some(DelimitedVec<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>>([Delimited<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>> { value: Named(NamedParam { mut_kw: None, name: Ident { sym: file_path, span: bytes(30324..30333) }, _colon: Operator<':'>, param_type: Repeats<1, 18446744073709551615, unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<','>>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing>([Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<','>>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::operator::Operator<','>>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::operator::Operator<','>>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Punct { char: '&', spacing: Alone, span: bytes(30335..30336) })) }, delimiter: Some(Nothing) }, Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<','>>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::operator::Operator<','>>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::operator::Operator<','>>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Ident { sym: str, span: bytes(30336..30339) })) }, delimiter: Some(Nothing) }]) }), delimiter: Some(Operator<','>) }, Delimited<syncdoc_core::parse::FnParam, unsynn::operator::Operator<','>> { value: Named(NamedParam { mut_kw: None, name: Ident { sym: sections, span: bytes(30341..30349) }, _colon: Operator<':'>, param_type: Repeats<1, 18446744073709551615, unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<','>>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing>([Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<','>>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::operator::Operator<','>>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::operator::Operator<','>>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Punct { char: '&', spacing: Alone, span: bytes(30351..30352) })) }, delimiter: Some(Nothing) }, Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<','>>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::operator::Operator<','>>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::operator::Operator<','>>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Group { delimiter: Bracket, stream: TokenStream [Punct { char: '&', spacing: Alone, span: bytes(30353..30354) }, Ident { sym: Section, span: bytes(30354..30361) }], span: bytes(30352..30362) })) }, delimiter: Some(Nothing) }]) }), delimiter: None }]))), return_type: Some(ReturnTypeFn { _arrow: Operator<'->'>, return_type: Repeats<1, 18446744073709551615, unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing>([Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::group::BraceGroup>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Ident { sym: io, span: bytes(30367..30369) })) }, delimiter: Some(Nothing) }, Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::group::BraceGroup>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Punct { char: ':', spacing: Joint, span: bytes(30369..30370) })) }, delimiter: Some(Nothing) }, Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::group::BraceGroup>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Punct { char: ':', spacing: Alone, span: bytes(30370..30371) })) }, delimiter: Some(Nothing) }, Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::group::BraceGroup>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Ident { sym: Result, span: bytes(30371..30377) })) }, delimiter: Some(Nothing) }, Delimited<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree>, unsynn::fundamental::Nothing> { value: Cons<unsynn::fundamental::Except<unsynn::group::BraceGroup>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::group::BraceGroup>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>> { first: Operator<'<'>, second: [Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree> { first: Except<unsynn::operator::Operator<'>'>>, second: AngleTokenTree(Either<unsynn::combinator::Cons<unsynn::operator::Operator<'<'>, alloc::vec::Vec<unsynn::combinator::Cons<unsynn::fundamental::Except<unsynn::operator::Operator<'>'>>, syncdoc_core::parse::AngleTokenTree>>, unsynn::operator::Operator<'>'>>, proc_macro2::TokenTree>(Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(30378..30380) })) }], third: Operator<'>'> })) }, delimiter: Some(Nothing) }]) }), where_clause: None, body: BraceGroup(Group { delimiter: Brace, stream: TokenStream [Ident { sym: let, span: bytes(30392..30395) }, Ident { sym: content, span: bytes(30396..30403) }, Punct { char: '=', spacing: Alone, span: bytes(30404..30405) }, Ident { sym: fs, span: bytes(30406..30408) }, Punct { char: ':', spacing: Joint, span: bytes(30408..30409) }, Punct { char: ':', spacing: Alone, span: bytes(30409..30410) }, Ident { sym: read_to_string, span: bytes(30410..30424) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: file_path, span: bytes(30425..30434) }], span: bytes(30424..30435) }, Punct { char: '?', spacing: Joint, span: bytes(30435..30436) }, Punct { char: ';', spacing: Alone, span: bytes(30436..30437) }, Ident { sym: let, span: bytes(30446..30449) }, Ident { sym: mut, span: bytes(30450..30453) }, Ident { sym: new_content, span: bytes(30454..30465) }, Punct { char: '=', spacing: Alone, span: bytes(30466..30467) }, Ident { sym: String, span: bytes(30468..30474) }, Punct { char: ':', spacing: Joint, span: bytes(30474..30475) }, Punct { char: ':', spacing: Alone, span: bytes(30475..30476) }, Ident { sym: new, span: bytes(30476..30479) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(30479..30481) }, Punct { char: ';', spacing: Alone, span: bytes(30481..30482) }, Ident { sym: for, span: bytes(30492..30495) }, Ident { sym: section, span: bytes(30496..30503) }, Ident { sym: in, span: bytes(30504..30506) }, Ident { sym: sections, span: bytes(30507..30515) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: let, span: bytes(30530..30533) }, Ident { sym: heading_prefix, span: bytes(30534..30548) }, Punct { char: '=', spacing: Alone, span: bytes(30549..30550) }, Literal { lit: "#", span: bytes(30551..30554) }, Punct { char: '.', spacing: Alone, span: bytes(30554..30555) }, Ident { sym: repeat, span: bytes(30555..30561) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: section, span: bytes(30562..30569) }, Punct { char: '.', spacing: Alone, span: bytes(30569..30570) }, Ident { sym: level, span: bytes(30570..30575) }], span: bytes(30561..30576) }, Punct { char: ';', spacing: Alone, span: bytes(30576..30577) }, Ident { sym: let, span: bytes(30590..30593) }, Ident { sym: heading, span: bytes(30594..30601) }, Punct { char: '=', spacing: Alone, span: bytes(30602..30603) }, Ident { sym: format, span: bytes(30604..30610) }, Punct { char: '!', spacing: Alone, span: bytes(30610..30611) }, Group { delimiter: Parenthesis, stream: TokenStream [Literal { lit: "{} {}", span: bytes(30612..30619) }, Punct { char: ',', spacing: Alone, span: bytes(30619..30620) }, Ident { sym: heading_prefix, span: bytes(30621..30635) }, Punct { char: ',', spacing: Alone, span: bytes(30635..30636) }, Ident { sym: section, span: bytes(30637..30644) }, Punct { char: '.', spacing: Alone, span: bytes(30644..30645) }, Ident { sym: title, span: bytes(30645..30650) }], span: bytes(30611..30651) }, Punct { char: ';', spacing: Alone, span: bytes(30651..30652) }, Ident { sym: let, span: bytes(30666..30669) }, Ident { sym: bytes, span: bytes(30670..30675) }, Punct { char: '=', spacing: Alone, span: bytes(30676..30677) }, Ident { sym: content, span: bytes(30678..30685) }, Punct { char: '.', spacing: Alone, span: bytes(30685..30686) }, Ident { sym: as_bytes, span: bytes(30686..30694) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(30694..30696) }, Punct { char: ';', spacing: Alone, span: bytes(30696..30697) }, Ident { sym: let, span: bytes(30710..30713) }, Ident { sym: section_text, span: bytes(30714..30726) }, Punct { char: '=', spacing: Alone, span: bytes(30727..30728) }, Ident { sym: if, span: bytes(30745..30747) }, Ident { sym: section, span: bytes(30748..30755) }, Punct { char: '.', spacing: Alone, span: bytes(30755..30756) }, Ident { sym: byte_start, span: bytes(30756..30766) }, Punct { char: '<', spacing: Alone, span: bytes(30767..30768) }, Ident { sym: bytes, span: bytes(30769..30774) }, Punct { char: '.', spacing: Alone, span: bytes(30774..30775) }, Ident { sym: len, span: bytes(30775..30778) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(30778..30780) }, Punct { char: '&', spacing: Joint, span: bytes(30781..30782) }, Punct { char: '&', spacing: Alone, span: bytes(30782..30783) }, Ident { sym: section, span: bytes(30784..30791) }, Punct { char: '.', spacing: Alone, span: bytes(30791..30792) }, Ident { sym: byte_end, span: bytes(30792..30800) }, Punct { char: '<', spacing: Joint, span: bytes(30801..30802) }, Punct { char: '=', spacing: Alone, span: bytes(30802..30803) }, Ident { sym: bytes, span: bytes(30804..30809) }, Punct { char: '.', spacing: Alone, span: bytes(30809..30810) }, Ident { sym: len, span: bytes(30810..30813) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(30813..30815) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: String, span: bytes(30838..30844) }, Punct { char: ':', spacing: Joint, span: bytes(30844..30845) }, Punct { char: ':', spacing: Alone, span: bytes(30845..30846) }, Ident { sym: from_utf8_lossy, span: bytes(30846..30861) }, Group { delimiter: Parenthesis, stream: TokenStream [Punct { char: '&', spacing: Alone, span: bytes(30862..30863) }, Ident { sym: bytes, span: bytes(30863..30868) }, Group { delimiter: Bracket, stream: TokenStream [Ident { sym: section, span: bytes(30869..30876) }, Punct { char: '.', spacing: Alone, span: bytes(30876..30877) }, Ident { sym: byte_start, span: bytes(30877..30887) }, Punct { char: '.', spacing: Joint, span: bytes(30887..30888) }, Punct { char: '.', spacing: Alone, span: bytes(30888..30889) }, Ident { sym: section, span: bytes(30889..30896) }, Punct { char: '.', spacing: Alone, span: bytes(30896..30897) }, Ident { sym: byte_end, span: bytes(30897..30905) }], span: bytes(30868..30906) }], span: bytes(30861..30907) }, Punct { char: '.', spacing: Alone, span: bytes(30932..30933) }, Ident { sym: to_string, span: bytes(30933..30942) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(30942..30944) }, Punct { char: '.', spacing: Alone, span: bytes(30969..30970) }, Ident { sym: trim, span: bytes(30970..30974) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(30974..30976) }, Punct { char: '.', spacing: Alone, span: bytes(31001..31002) }, Ident { sym: to_string, span: bytes(31002..31011) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(31011..31013) }], span: bytes(30816..31031) }, Ident { sym: else, span: bytes(31032..31036) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: String, span: bytes(31059..31065) }, Punct { char: ':', spacing: Joint, span: bytes(31065..31066) }, Punct { char: ':', spacing: Alone, span: bytes(31066..31067) }, Ident { sym: new, span: bytes(31067..31070) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(31070..31072) }], span: bytes(31037..31090) }, Punct { char: ';', spacing: Alone, span: bytes(31090..31091) }, Ident { sym: new_content, span: bytes(31105..31116) }, Punct { char: '.', spacing: Alone, span: bytes(31116..31117) }, Ident { sym: push_str, span: bytes(31117..31125) }, Group { delimiter: Parenthesis, stream: TokenStream [Punct { char: '&', spacing: Alone, span: bytes(31126..31127) }, Ident { sym: heading, span: bytes(31127..31134) }], span: bytes(31125..31135) }, Punct { char: ';', spacing: Alone, span: bytes(31135..31136) }, Ident { sym: new_content, span: bytes(31149..31160) }, Punct { char: '.', spacing: Alone, span: bytes(31160..31161) }, Ident { sym: push_str, span: bytes(31161..31169) }, Group { delimiter: Parenthesis, stream: TokenStream [Literal { lit: "\n\n", span: bytes(31170..31176) }], span: bytes(31169..31177) }, Punct { char: ';', spacing: Alone, span: bytes(31177..31178) }, Ident { sym: if, span: bytes(31191..31193) }, Punct { char: '!', spacing: Alone, span: bytes(31194..31195) }, Ident { sym: section_text, span: bytes(31195..31207) }, Punct { char: '.', spacing: Alone, span: bytes(31207..31208) }, Ident { sym: is_empty, span: bytes(31208..31216) }, Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(31216..31218) }, Group { delimiter: Brace, stream: TokenStream [Ident { sym: new_content, span: bytes(31237..31248) }, Punct { char: '.', spacing: Alone, span: bytes(31248..31249) }, Ident { sym: push_str, span: bytes(31249..31257) }, Group { delimiter: Parenthesis, stream: TokenStream [Punct { char: '&', spacing: Alone, span: bytes(31258..31259) }, Ident { sym: section_text, span: bytes(31259..31271) }], span: bytes(31257..31272) }, Punct { char: ';', spacing: Alone, span: bytes(31272..31273) }, Ident { sym: new_content, span: bytes(31290..31301) }, Punct { char: '.', spacing: Alone, span: bytes(31301..31302) }, Ident { sym: push_str, span: bytes(31302..31310) }, Group { delimiter: Parenthesis, stream: TokenStream [Literal { lit: "\n\n", span: bytes(31311..31317) }], span: bytes(31310..31318) }, Punct { char: ';', spacing: Alone, span: bytes(31318..31319) }], span: bytes(31219..31333) }], span: bytes(30516..31343) }, Ident { sym: fs, span: bytes(31353..31355) }, Punct { char: ':', spacing: Joint, span: bytes(31355..31356) }, Punct { char: ':', spacing: Alone, span: bytes(31356..31357) }, Ident { sym: write, span: bytes(31357..31362) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: file_path, span: bytes(31363..31372) }, Punct { char: ',', spacing: Alone, span: bytes(31372..31373) }, Ident { sym: new_content, span: bytes(31374..31385) }], span: bytes(31362..31386) }, Punct { char: '?', spacing: Joint, span: bytes(31386..31387) }, Punct { char: ';', spacing: Alone, span: bytes(31387..31388) }, Ident { sym: Ok, span: bytes(31397..31399) }, Group { delimiter: Parenthesis, stream: TokenStream [Group { delimiter: Parenthesis, stream: TokenStream [], span: bytes(31400..31402) }], span: bytes(31399..31403) }], span: bytes(30382..31409) }) })
[SYNCDOC DEBUG] Processing item type: Other
[SYNCDOC DEBUG] Processing item: Other(Punct { char: '#', spacing: Alone, span: bytes(31413..31414) })
[SYNCDOC DEBUG] Processing item type: Other
[SYNCDOC DEBUG] Processing item: Other(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: cfg, span: bytes(31415..31418) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { sym: test, span: bytes(31419..31423) }], span: bytes(31418..31424) }], span: bytes(31414..31425) })
[SYNCDOC DEBUG] Processing item type: Other
[SYNCDOC DEBUG] Processing item: Other(Punct { char: '#', spacing: Alone, span: bytes(31426..31427) })
[SYNCDOC DEBUG] Processing item type: Other
[SYNCDOC DEBUG] Processing item: Other(Group { delimiter: Bracket, stream: TokenStream [Ident { sym: path, span: bytes(31428..31432) }, Punct { char: '=', spacing: Alone, span: bytes(31433..31434) }, Literal { lit: "tests/app_state.rs", span: bytes(31435..31455) }], span: bytes(31427..31456) })
[SYNCDOC DEBUG] Processing item type: Other
[SYNCDOC DEBUG] Processing item: Other(Ident { sym: mod, span: bytes(31457..31460) })
[SYNCDOC DEBUG] Processing item type: Other
[SYNCDOC DEBUG] Processing item: Other(Ident { sym: tests, span: bytes(31461..31466) })
[SYNCDOC DEBUG] Processing item type: Other
[SYNCDOC DEBUG] Processing item: Other(Punct { char: ';', spacing: Alone, span: bytes(31466..31467) })
[SYNCDOC DEBUG] 
=== REFORMAT START ===
[SYNCDOC DEBUG] Original length: 31467
[SYNCDOC DEBUG] Transformed length: 19860
[SYNCDOC DEBUG] Formatted original length: 31467
[SYNCDOC DEBUG] Formatted transformed length: 25096
[SYNCDOC DEBUG] 
--- Formatted Original ---
[SYNCDOC DEBUG] //! The core state machine bridging document sections and the interactive editor.
//!
//! A TUI needs a single source of truth that can be interrogated and mutated as the user navigates
//! and edits. We achieve this by syncing the editor save state with the files on disk. We keep
//! track of the cumulative total number of lines that have been added to the file during the
//! session so that we can determine the correct offset to insert content at without re-parsing.

use crate::edit_plan::{Edit, EditPlan};
use crate::formats::markdown::MarkdownFormat;
use crate::input;
use crate::section::ChunkType;
use crate::section::{Section, TreeNode};
use edtui::{EditorState, Lines};
use std::collections::HashMap;
use std::path::PathBuf;
use std::{fs, io};

/// Determines navigation scope and quit behavior based on project size.
#[derive(PartialEq)]
pub enum FileMode {
    /// Single-file mode quits directly to shell.
    Single,
    /// Multi-file mode shows file tree in list view.
    Multi,
}

/// Tracks the lifecycle of a section reordering operation.
#[derive(Clone, PartialEq, Debug)]
pub enum MoveState {
    /// No section is being moved; normal navigation mode.
    None,
    /// A section has been selected for moving but no changes made yet.
    Selected,
    /// Section has been repositioned but changes not yet persisted to disk.
    Moved,
}

/// Bridges document sections and the interactive editor, maintaining session state.
pub struct AppState {
    /// All parsed sections across loaded files.
    pub sections: Vec<Section>,
    /// Unified tree of directories, files, and sections for display
    pub tree_nodes: Vec<TreeNode>,
    /// File paths available for editing.
    pub files: Vec<PathBuf>,
    /// Controls navigation behavior and file tree visibility.
    pub file_mode: FileMode,
    /// Active UI screen determining input handling.
    pub current_view: View,
    /// Selected node index in the tree
    pub current_node_index: usize,
    /// Editor buffer content when detail view is active.
    pub editor_state: Option<EditorState>,
    /// Accumulates vim-style command input after ':' is pressed.
    pub command_buffer: String,
    /// Status feedback displayed in the help bar.
    pub message: Option<String>,
    /// Maximum line width for text wrapping in the editor.
    pub wrap_width: usize,
    /// Tracks line count changes per section to calculate write positions without re-parsing.
    pub file_offsets: HashMap<String, HashMap<i64, usize>>,
    /// Tracks section being moved for visual feedback
    pub move_state: MoveState,
    /// Index of section being moved (if any)
    pub moving_section_index: Option<usize>,
}

/// Determines which UI screen renders and how input is interpreted.
#[derive(PartialEq)]
pub enum View {
    /// Shows hierarchical section tree with navigation.
    List,
    /// Provides vim-like editor for section content.
    Detail,
    /// Captures vim-style command input after ':' keystroke.
    Command,
}

impl AppState {
    /// Initialises application state with parsed sections and determines file mode.
    #[must_use]
    pub fn new(files: Vec<PathBuf>, sections: Vec<Section>, wrap_width: usize) -> Self {
        let file_mode = if files.len() == 1 {
            FileMode::Single
        } else {
            FileMode::Multi
        };

        let tree_nodes = Self::build_tree(&files, &sections);

        // Find first navigable node
        let initial_index = tree_nodes.iter().position(|n| n.navigable).unwrap_or(0);

        Self {
            sections,
            tree_nodes,
            files,
            file_mode,
            current_view: View::List,
            current_node_index: initial_index,
            editor_state: None,
            command_buffer: String::new(),
            message: None,
            wrap_width,
            file_offsets: HashMap::new(),
            move_state: MoveState::None,
            moving_section_index: None,
        }
    }

    fn build_tree(files: &[PathBuf], sections: &[Section]) -> Vec<TreeNode> {
        let mut nodes = Vec::new();

        // Determine if this is difftastic mode by checking if multiple sections share the same file_path
        // (in markdown mode, each section has a unique file path or sections are from the same file)
        let mut file_section_counts: HashMap<String, usize> = HashMap::new();
        for section in sections {
            *file_section_counts
                .entry(section.file_path.clone())
                .or_insert(0) += 1;
        }
        let is_difftastic = file_section_counts.values().any(|&count| count > 1);

        if files.len() == 1 && !is_difftastic {
            // Single markdown file mode: use section level for tree indentation
            for (idx, section) in sections.iter().enumerate() {
                nodes.push(TreeNode::section(section.clone(), section.level, idx));
            }
        } else if is_difftastic {
            // Difftastic mode: group sections by file, show files as non-navigable nodes
            let mut file_tree: HashMap<String, Vec<(usize, &Section)>> = HashMap::new();
            let mut file_status: HashMap<String, Option<String>> = HashMap::new();

            // Group sections by file and infer file statuses
            for (idx, section) in sections.iter().enumerate() {
                file_tree
                    .entry(section.file_path.clone())
                    .or_default()
                    .push((idx, section));

                // Determine file status from hunk headers
                if !file_status.contains_key(&section.file_path) {
                    let status = if section.title.contains("@@ -0,0") {
                        Some("created".to_string())
                    } else if section.title.contains("+0,0 @@") {
                        Some("deleted".to_string())
                    } else if section.title.contains("@@ ") {
                        Some("changed".to_string())
                    } else {
                        None
                    };
                    file_status.insert(section.file_path.clone(), status);
                }
            }

            // Build tree with file nodes and hunk sections
            let mut sorted_files: Vec<_> = file_tree.keys().collect();
            sorted_files.sort();

            for file_path in sorted_files {
                // Add file node (non-navigable)
                let file_name = PathBuf::from(file_path)
                    .file_name()
                    .map_or_else(|| file_path.clone(), |n| n.to_string_lossy().to_string());

                let status_opt = file_status.get(file_path).and_then(|opt| opt.as_deref()); // flatten Option<Option<&str>>

                let label = match status_opt {
                    Some(status) => format!("{file_name} ({status})"),
                    None => file_name.clone(),
                };

                nodes.push(TreeNode::file(label, file_path.clone(), 0));

                // Add hunk sections under this file
                if let Some(file_sections) = file_tree.get(file_path) {
                    for (idx, section) in file_sections {
                        nodes.push(TreeNode::section((*section).clone(), 1, *idx));
                    }
                }
            }
        } else {
            // Multi-file markdown mode: build directory tree with sections nested under files
            let mut file_tree: HashMap<String, Vec<(usize, &Section)>> = HashMap::new();

            // Group sections by file
            for (idx, section) in sections.iter().enumerate() {
                file_tree
                    .entry(section.file_path.clone())
                    .or_default()
                    .push((idx, section));
            }

            // Build tree with directory structure
            let mut sorted_files: Vec<_> = files.iter().collect();
            sorted_files.sort();

            for file_path in sorted_files {
                let path_str = file_path.to_string_lossy().to_string();

                // Add file node (non-navigable)
                let file_name = file_path
                    .file_name()
                    .map_or_else(|| path_str.clone(), |n| n.to_string_lossy().to_string());

                nodes.push(TreeNode::file(file_name.clone(), path_str.clone(), 0));

                // Add sections under this file
                if let Some(file_sections) = file_tree.get(&path_str) {
                    for (idx, section) in file_sections {
                        nodes.push(TreeNode::section((*section).clone(), section.level, *idx));
                    }
                }
            }
        }

        nodes
    }

    /// Rebuild tree after sections change (e.g., after save)
    pub fn rebuild_tree(&mut self) {
        self.tree_nodes = Self::build_tree(&self.files, &self.sections);

        // Try to maintain current position by finding same section
        if let Some(current_section_idx) = self.get_current_section_index() {
            if let Some(node_idx) = self
                .tree_nodes
                .iter()
                .position(|n| n.section_index == Some(current_section_idx))
            {
                self.current_node_index = node_idx;
            }
        }
    }

    /// Get the section index for the currently selected node (if it's a section)
    #[must_use]
    pub fn get_current_section_index(&self) -> Option<usize> {
        if self.current_node_index < self.tree_nodes.len() {
            self.tree_nodes[self.current_node_index].section_index
        } else {
            None
        }
    }

    /// Get the current section (if on a section node)
    #[must_use]
    pub fn get_current_section(&self) -> Option<&Section> {
        self.get_current_section_index()
            .and_then(|idx| self.sections.get(idx))
    }

    fn rebuild_file_offsets(&mut self) {
        self.file_offsets.clear();

        if let Some(section_idx) = self.get_current_section_index() {
            if let Some(section) = self.sections.get(section_idx) {
                let lines_added = self.editor_state.as_ref().map_or(0, |es| es.lines.len());

                let file_map = self
                    .file_offsets
                    .entry(section.file_path.clone())
                    .or_default();

                file_map.insert(section.line_start, lines_added);
            }
        }
    }

    /// Calculates total lines added before a section to determine correct write position.
    #[must_use]
    pub fn cumulative_offset(&self, index: usize) -> usize {
        let section = &self.sections[index];
        let target_file = &section.file_path;
        let target_line = section.line_start;

        if let Some(file_map) = self.file_offsets.get(target_file) {
            file_map
                .iter()
                .filter(|(line, _)| **line < target_line)
                .map(|(_, offset)| offset)
                .sum()
        } else {
            0
        }
    }

    /// Restores previously edited content from a saved edit plan.
    pub fn load_docs(&mut self, plan: EditPlan) {
        let mut doc_map: HashMap<String, Vec<String>> = HashMap::new();
        for edit in plan.edits {
            let key = format!(
                "{}:{}:{}",
                edit.file_name, edit.line_start, edit.column_start
            );
            let lines: Vec<String> = edit
                .section_content
                .lines()
                .map(std::string::ToString::to_string)
                .collect();
            doc_map.insert(key, lines);
        }

        // Match edits to sections and pre-populate editor content
        for section in &mut self.sections {
            let key = format!(
                "{}:{}:{}",
                section.file_path, section.line_start, section.column_start
            );
            if doc_map.contains_key(&key) {
                if let Ok(content) = fs::read_to_string(&section.file_path) {
                    let bytes = content.as_bytes();
                    if section.byte_start < bytes.len() && section.byte_end <= bytes.len() {
                        // Section exists and can be loaded
                    }
                }
            }
        }
    }

    /// Creates a serialisable plan capturing current editor modifications.
    #[must_use]
    pub fn generate_edit_plan(&self) -> EditPlan {
        let mut edits = Vec::new();

        for section in &self.sections {
            if let Some(ref doc_lines) = section.section_content {
                let section_content = doc_lines.join("\n");

                edits.push(Edit {
                    file_name: section.file_path.clone(),
                    line_start: section.line_start,
                    line_end: section.line_end,
                    column_start: section.column_start,
                    column_end: section.column_end,
                    section_content,
                    item_name: section.title.clone(),
                });
            }
        }

        EditPlan { edits }
    }

    /// Loads selected section content into the editor buffer.
    pub fn enter_detail_view(&mut self) {
        let Some(section_idx) = self.get_current_section_index() else {
            return;
        };

        let section = &self.sections[section_idx];

        // Handle difftastic chunks differently
        if let Some(chunk_type) = &section.chunk_type {
            let content = match chunk_type {
                ChunkType::Added => {
                    // Show only RHS for added chunks
                    section.rhs_content.clone().unwrap_or_default()
                }
                ChunkType::Deleted => {
                    // Show LHS with strikethrough or special formatting
                    section.lhs_content.clone().unwrap_or_default()
                }
                ChunkType::Modified => {
                    // Show a unified or side-by-side view
                    let lhs = section.lhs_content.as_deref().unwrap_or("");
                    let rhs = section.rhs_content.as_deref().unwrap_or("");
                    format!("- {lhs}\n+ {rhs}")
                }
                ChunkType::Unchanged => {
                    // Show either side (they're the same)
                    section
                        .lhs_content
                        .clone()
                        .or_else(|| section.rhs_content.clone())
                        .unwrap_or_default()
                }
            };

            let lines = Lines::from(content.as_str());
            self.editor_state = Some(EditorState::new(lines));
        } else if let Ok(content) = fs::read_to_string(&section.file_path) {
            let bytes = content.as_bytes();
            let section_bytes =
                &bytes[section.byte_start.min(bytes.len())..section.byte_end.min(bytes.len())];

            let section_content = String::from_utf8_lossy(section_bytes).to_string();

            let lines_text = if section_content.trim().is_empty() {
                "\n".to_string()
            } else {
                format!("\n{}\n", section_content.trim())
            };

            let lines = Lines::from(lines_text.as_str());
            self.editor_state = Some(EditorState::new(lines));
        }

        self.current_view = View::Detail;
    }

    /// Returns to section list, optionally persisting editor changes.
    pub fn exit_detail_view(&mut self, save: bool) {
        if save {
            if let Some(ref editor_state) = self.editor_state {
                if let Some(section_idx) = self.get_current_section_index() {
                    let lines = editor_state
                        .lines
                        .iter_row()
                        .map(|line| line.iter().collect::<String>())
                        .collect();
                    self.sections[section_idx].section_content = Some(lines);
                }
            }
        }
        self.editor_state = None;
        self.current_view = View::List;
    }

    /// Save the current section's content to disk.
    ///
    /// # Errors
    ///
    /// Returns an error if writing to disk fails or if file operations cannot complete.
    pub fn save_current(&mut self) -> io::Result<()> {
        let editor_lines = if let Some(ref editor_state) = self.editor_state {
            editor_state
                .lines
                .iter_row()
                .map(|line| line.iter().collect::<String>())
                .collect::<Vec<_>>()
        } else {
            return Ok(());
        };

        let Some(section_idx) = self.get_current_section_index() else {
            return Ok(());
        };

        self.sections[section_idx].section_content = Some(editor_lines.clone());

        let section = &self.sections[section_idx];

        let raw_content = editor_lines.join("\n");
        let trimmed_content = raw_content.trim();
        let padded_content = format!("\n{trimmed_content}\n\n");

        let edit = Edit {
            file_name: section.file_path.clone(),
            line_start: section.line_start,
            line_end: section.line_end,
            column_start: section.column_start,
            column_end: section.column_end,
            section_content: padded_content,
            item_name: section.title.clone(),
        };

        let mut plan = EditPlan { edits: vec![edit] };
        plan.apply()?;

        // Reload sections
        let format = MarkdownFormat;
        if let Ok(new_sections) =
            input::extract_sections(&PathBuf::from(&section.file_path), &format)
        {
            let target_title = section.title.clone();
            let target_level = section.level;

            let file_path = section.file_path.clone();
            self.sections.retain(|s| s.file_path != file_path);

            if let Some(local_index) = new_sections
                .iter()
                .position(|s| s.title == target_title && s.level == target_level)
            {
                let new_global_index = self.sections.len() + local_index;
                self.sections.extend(new_sections);

                // Rebuild tree and find the updated section
                self.rebuild_tree();

                // Find node with this section index
                if let Some(node_idx) = self
                    .tree_nodes
                    .iter()
                    .position(|n| n.section_index == Some(new_global_index))
                {
                    self.current_node_index = node_idx;
                }
            } else {
                self.sections.extend(new_sections);
                self.rebuild_tree();
            }
        }

        self.rebuild_file_offsets();
        self.message = Some("Saved".to_string());
        Ok(())
    }

    /// Navigate to next navigable node
    #[must_use]
    pub fn find_next_node(&self) -> Option<usize> {
        ((self.current_node_index + 1)..self.tree_nodes.len())
            .find(|&i| self.tree_nodes[i].navigable)
    }

    /// Navigate to previous navigable node
    #[must_use]
    pub fn find_prev_node(&self) -> Option<usize> {
        (0..self.current_node_index)
            .rev()
            .find(|&i| self.tree_nodes[i].navigable)
    }

    /// Moves to the containing section in the document hierarchy.
    #[must_use]
    pub fn navigate_to_parent(&self) -> Option<usize> {
        let section_idx = self.get_current_section_index()?;
        let parent_section_idx = self.sections[section_idx].parent_index?;

        // Find tree node with this section index
        self.tree_nodes
            .iter()
            .position(|n| n.section_index == Some(parent_section_idx))
    }

    /// Descends to the first child section in the document hierarchy.
    #[must_use]
    pub fn navigate_to_first_child(&self) -> Option<usize> {
        let section_idx = self.get_current_section_index()?;
        let first_child_idx = self.sections[section_idx].children_indices.first()?;

        self.tree_nodes
            .iter()
            .position(|n| n.section_index == Some(*first_child_idx))
    }

    /// Finds the next descendant section at any depth in the hierarchy.
    #[must_use]
    pub fn navigate_to_next_descendant(&self) -> Option<usize> {
        let section_idx = self.get_current_section_index()?;

        // First try immediate children
        if let Some(first_child) = self.sections[section_idx].children_indices.first() {
            return self
                .tree_nodes
                .iter()
                .position(|n| n.section_index == Some(*first_child));
        }

        // Otherwise find next section at deeper level
        for i in (section_idx + 1)..self.sections.len() {
            if self.sections[i].level > self.sections[section_idx].level {
                return self
                    .tree_nodes
                    .iter()
                    .position(|n| n.section_index == Some(i));
            }
        }

        None
    }

    /// Finds the next section at the same hierarchy level.
    #[must_use]
    pub fn navigate_to_next_sibling(&self) -> Option<usize> {
        let section_idx = self.get_current_section_index()?;
        let current_level = self.sections[section_idx].level;

        for i in (section_idx + 1)..self.sections.len() {
            if self.sections[i].level == current_level {
                return self
                    .tree_nodes
                    .iter()
                    .position(|n| n.section_index == Some(i));
            }
            if self.sections[i].level < current_level {
                break;
            }
        }

        None
    }

    /// Finds the previous section at the same hierarchy level.
    #[must_use]
    pub fn navigate_to_prev_sibling(&self) -> Option<usize> {
        let section_idx = self.get_current_section_index()?;
        let current_level = self.sections[section_idx].level;

        for i in (0..section_idx).rev() {
            if self.sections[i].level == current_level {
                return self
                    .tree_nodes
                    .iter()
                    .position(|n| n.section_index == Some(i));
            }
            if self.sections[i].level < current_level {
                break;
            }
        }

        None
    }

    /// Jumps to the first navigable node.
    #[must_use]
    pub fn navigate_to_first(&self) -> Option<usize> {
        self.tree_nodes.iter().position(|n| n.navigable)
    }

    /// Jumps to the last navigable node.
    #[must_use]
    pub fn navigate_to_last(&self) -> Option<usize> {
        self.tree_nodes.iter().rposition(|n| n.navigable)
    }

    /// Finds the first section at the same hierarchy level.
    #[must_use]
    pub fn navigate_to_first_at_level(&self) -> Option<usize> {
        let section_idx = self.get_current_section_index()?;
        let current_level = self.sections[section_idx].level;

        for i in 0..self.sections.len() {
            if self.sections[i].level == current_level {
                return self
                    .tree_nodes
                    .iter()
                    .position(|n| n.section_index == Some(i));
            }
        }

        None
    }

    /// Finds the last section at the same hierarchy level.
    #[must_use]
    pub fn navigate_to_last_at_level(&self) -> Option<usize> {
        let section_idx = self.get_current_section_index()?;
        let current_level = self.sections[section_idx].level;

        for i in (0..self.sections.len()).rev() {
            if self.sections[i].level == current_level {
                return self
                    .tree_nodes
                    .iter()
                    .position(|n| n.section_index == Some(i));
            }
        }

        None
    }

    /// Calculates indentation width based on section nesting level.
    #[must_use]
    pub fn get_indent(&self) -> usize {
        if let Some(section) = self.get_current_section() {
            section.level * 2
        } else {
            0
        }
    }

    /// Determines available width for text after accounting for indentation.
    #[must_use]
    pub fn get_max_line_width(&self) -> usize {
        let indent = self.get_indent();
        self.wrap_width.saturating_sub(indent)
    }

    // --- Section List Movement ---

    /// Start moving the current section
    pub fn start_move(&mut self) {
        if let Some(section_idx) = self.get_current_section_index() {
            self.moving_section_index = Some(section_idx);
            self.move_state = MoveState::Selected;
        }
    }

    /// Cancel the current move operation
    pub fn cancel_move(&mut self) {
        self.moving_section_index = None;
        self.move_state = MoveState::None;
    }

    /// Mark section as moved but not yet saved
    pub fn mark_moved(&mut self) {
        self.move_state = MoveState::Moved;
    }

    /// Move section up by one position
    pub fn move_section_up(&mut self) -> bool {
        if let Some(moving_idx) = self.moving_section_index {
            if moving_idx > 0 {
                self.sections.swap(moving_idx, moving_idx - 1);
                self.moving_section_index = Some(moving_idx - 1);
                self.rebuild_tree();

                // Update current node to follow the moved section
                if let Some(node_idx) = self
                    .tree_nodes
                    .iter()
                    .position(|n| n.section_index == Some(moving_idx - 1))
                {
                    self.current_node_index = node_idx;
                }

                self.mark_moved();
                return true;
            }
        }
        false
    }

    /// Move section down by one position
    pub fn move_section_down(&mut self) -> bool {
        if let Some(moving_idx) = self.moving_section_index {
            if moving_idx < self.sections.len() - 1 {
                self.sections.swap(moving_idx, moving_idx + 1);
                self.moving_section_index = Some(moving_idx + 1);
                self.rebuild_tree();

                if let Some(node_idx) = self
                    .tree_nodes
                    .iter()
                    .position(|n| n.section_index == Some(moving_idx + 1))
                {
                    self.current_node_index = node_idx;
                }

                self.mark_moved();
                return true;
            }
        }
        false
    }

    /// Move section to top of document
    pub fn move_section_to_top(&mut self) -> bool {
        if let Some(moving_idx) = self.moving_section_index {
            if moving_idx > 0 {
                let section = self.sections.remove(moving_idx);
                self.sections.insert(0, section);
                self.moving_section_index = Some(0);
                self.rebuild_tree();

                if let Some(node_idx) = self
                    .tree_nodes
                    .iter()
                    .position(|n| n.section_index == Some(0))
                {
                    self.current_node_index = node_idx;
                }

                self.mark_moved();
                return true;
            }
        }
        false
    }

    /// Move section to bottom of document
    pub fn move_section_to_bottom(&mut self) -> bool {
        if let Some(moving_idx) = self.moving_section_index {
            let last_idx = self.sections.len() - 1;
            if moving_idx < last_idx {
                let section = self.sections.remove(moving_idx);
                self.sections.push(section);
                self.moving_section_index = Some(last_idx);
                self.rebuild_tree();

                if let Some(node_idx) = self
                    .tree_nodes
                    .iter()
                    .position(|n| n.section_index == Some(last_idx))
                {
                    self.current_node_index = node_idx;
                }

                self.mark_moved();
                return true;
            }
        }
        false
    }

    /// Increase section level (move in - lower level number)
    pub fn move_section_in(&mut self) -> bool {
        if let Some(moving_idx) = self.moving_section_index {
            if self.sections[moving_idx].level > 1 {
                self.sections[moving_idx].level -= 1;
                self.rebuild_tree();
                self.mark_moved();
                return true;
            }
        }
        false
    }

    /// Decrease section level (move out - higher level number)
    pub fn move_section_out(&mut self) -> bool {
        if let Some(moving_idx) = self.moving_section_index {
            if self.sections[moving_idx].level < 6 {
                self.sections[moving_idx].level += 1;
                self.rebuild_tree();
                self.mark_moved();
                return true;
            }
        }
        false
    }

    /// Apply section reordering to disk
    ///
    /// # Errors
    ///
    /// Returns an error if writing to disk fails or if file operations cannot complete.
    pub fn save_section_reorder(&mut self) -> io::Result<()> {
        if self.move_state != MoveState::Moved {
            return Ok(());
        }

        // Group sections by file
        let mut file_sections: HashMap<String, Vec<&Section>> = HashMap::new();
        for section in &self.sections {
            file_sections
                .entry(section.file_path.clone())
                .or_default()
                .push(section);
        }

        // Process each file
        for (file_path, sections) in file_sections {
            Self::rewrite_file_sections(&file_path, &sections)?;
        }

        // Reload sections to get updated positions
        let format = MarkdownFormat;
        let mut new_sections = Vec::new();
        for file in &self.files {
            if let Ok(secs) = input::extract_sections(file, &format) {
                new_sections.extend(secs);
            }
        }

        self.sections = new_sections;
        self.rebuild_tree();
        self.cancel_move();
        self.message = Some("Sections reordered".to_string());

        Ok(())
    }

    /// Rewrite an entire file with reordered sections
    fn rewrite_file_sections(file_path: &str, sections: &[&Section]) -> io::Result<()> {
        let content = fs::read_to_string(file_path)?;
        let mut new_content = String::new();

        for section in sections {
            let heading_prefix = "#".repeat(section.level);
            let heading = format!("{} {}", heading_prefix, section.title);

            let bytes = content.as_bytes();
            let section_text =
                if section.byte_start < bytes.len() && section.byte_end <= bytes.len() {
                    String::from_utf8_lossy(&bytes[section.byte_start..section.byte_end])
                        .to_string()
                        .trim()
                        .to_string()
                } else {
                    String::new()
                };

            new_content.push_str(&heading);
            new_content.push_str("\n\n");
            if !section_text.is_empty() {
                new_content.push_str(&section_text);
                new_content.push_str("\n\n");
            }
        }

        fs::write(file_path, new_content)?;
        Ok(())
    }
}

#[cfg(test)]
#[path = "tests/app_state.rs"]
mod tests;

[SYNCDOC DEBUG] 
--- Formatted Transformed ---
[SYNCDOC DEBUG] # ! [doc = syncdoc :: module_doc ! ()]
use crate::edit_plan::{Edit, EditPlan};
use crate::formats::markdown::MarkdownFormat;
use crate::input;
use crate::section::ChunkType;
use crate::section::{Section, TreeNode};
use edtui::{EditorState, Lines};
use std::collections::HashMap;
use std::path::PathBuf;
use std::{fs, io};
#[syncdoc::omnidoc]
#[derive(PartialEq)]
pub enum FileMode {
    Single,
    Multi,
}
#[syncdoc::omnidoc]
#[derive(Clone, PartialEq, Debug)]
pub enum MoveState {
    None,
    Selected,
    Moved,
}
#[syncdoc::omnidoc]
pub struct AppState {
    pub sections: Vec<Section>,
    pub tree_nodes: Vec<TreeNode>,
    pub files: Vec<PathBuf>,
    pub file_mode: FileMode,
    pub current_view: View,
    pub current_node_index: usize,
    pub editor_state: Option<EditorState>,
    pub command_buffer: String,
    pub message: Option<String>,
    pub wrap_width: usize,
    pub file_offsets: HashMap<String, HashMap<i64, usize>>,
    pub move_state: MoveState,
    pub moving_section_index: Option<usize>,
}
#[syncdoc::omnidoc]
#[derive(PartialEq)]
pub enum View {
    List,
    Detail,
    Command,
}
#[syncdoc::omnidoc]
impl AppState {
    #[must_use]
    pub fn new(files: Vec<PathBuf>, sections: Vec<Section>, wrap_width: usize) -> Self {
        let file_mode = if files.len() == 1 {
            FileMode::Single
        } else {
            FileMode::Multi
        };
        let tree_nodes = Self::build_tree(&files, &sections);
        let initial_index = tree_nodes.iter().position(|n| n.navigable).unwrap_or(0);
        Self {
            sections,
            tree_nodes,
            files,
            file_mode,
            current_view: View::List,
            current_node_index: initial_index,
            editor_state: None,
            command_buffer: String::new(),
            message: None,
            wrap_width,
            file_offsets: HashMap::new(),
            move_state: MoveState::None,
            moving_section_index: None,
        }
    }
    fn build_tree(files: &[PathBuf], sections: &[Section]) -> Vec<TreeNode> {
        let mut nodes = Vec::new();
        let mut file_section_counts: HashMap<String, usize> = HashMap::new();
        for section in sections {
            *file_section_counts
                .entry(section.file_path.clone())
                .or_insert(0) += 1;
        }
        let is_difftastic = file_section_counts.values().any(|&count| count > 1);
        if files.len() == 1 && !is_difftastic {
            for (idx, section) in sections.iter().enumerate() {
                nodes.push(TreeNode::section(section.clone(), section.level, idx));
            }
        } else if is_difftastic {
            let mut file_tree: HashMap<String, Vec<(usize, &Section)>> = HashMap::new();
            let mut file_status: HashMap<String, Option<String>> = HashMap::new();
            for (idx, section) in sections.iter().enumerate() {
                file_tree
                    .entry(section.file_path.clone())
                    .or_default()
                    .push((idx, section));
                if !file_status.contains_key(&section.file_path) {
                    let status = if section.title.contains("@@ -0,0") {
                        Some("created".to_string())
                    } else if section.title.contains("+0,0 @@") {
                        Some("deleted".to_string())
                    } else if section.title.contains("@@ ") {
                        Some("changed".to_string())
                    } else {
                        None
                    };
                    file_status.insert(section.file_path.clone(), status);
                }
            }
            let mut sorted_files: Vec<_> = file_tree.keys().collect();
            sorted_files.sort();
            for file_path in sorted_files {
                let file_name = PathBuf::from(file_path)
                    .file_name()
                    .map_or_else(|| file_path.clone(), |n| n.to_string_lossy().to_string());
                let status_opt = file_status.get(file_path).and_then(|opt| opt.as_deref());
                let label = match status_opt {
                    Some(status) => format!("{file_name} ({status})"),
                    None => file_name.clone(),
                };
                nodes.push(TreeNode::file(label, file_path.clone(), 0));
                if let Some(file_sections) = file_tree.get(file_path) {
                    for (idx, section) in file_sections {
                        nodes.push(TreeNode::section((*section).clone(), 1, *idx));
                    }
                }
            }
        } else {
            let mut file_tree: HashMap<String, Vec<(usize, &Section)>> = HashMap::new();
            for (idx, section) in sections.iter().enumerate() {
                file_tree
                    .entry(section.file_path.clone())
                    .or_default()
                    .push((idx, section));
            }
            let mut sorted_files: Vec<_> = files.iter().collect();
            sorted_files.sort();
            for file_path in sorted_files {
                let path_str = file_path.to_string_lossy().to_string();
                let file_name = file_path
                    .file_name()
                    .map_or_else(|| path_str.clone(), |n| n.to_string_lossy().to_string());
                nodes.push(TreeNode::file(file_name.clone(), path_str.clone(), 0));
                if let Some(file_sections) = file_tree.get(&path_str) {
                    for (idx, section) in file_sections {
                        nodes.push(TreeNode::section((*section).clone(), section.level, *idx));
                    }
                }
            }
        }
        nodes
    }
    pub fn rebuild_tree(&mut self) {
        self.tree_nodes = Self::build_tree(&self.files, &self.sections);
        if let Some(current_section_idx) = self.get_current_section_index() {
            if let Some(node_idx) = self
                .tree_nodes
                .iter()
                .position(|n| n.section_index == Some(current_section_idx))
            {
                self.current_node_index = node_idx;
            }
        }
    }
    #[must_use]
    pub fn get_current_section_index(&self) -> Option<usize> {
        if self.current_node_index < self.tree_nodes.len() {
            self.tree_nodes[self.current_node_index].section_index
        } else {
            None
        }
    }
    #[must_use]
    pub fn get_current_section(&self) -> Option<&Section> {
        self.get_current_section_index()
            .and_then(|idx| self.sections.get(idx))
    }
    fn rebuild_file_offsets(&mut self) {
        self.file_offsets.clear();
        if let Some(section_idx) = self.get_current_section_index() {
            if let Some(section) = self.sections.get(section_idx) {
                let lines_added = self.editor_state.as_ref().map_or(0, |es| es.lines.len());
                let file_map = self
                    .file_offsets
                    .entry(section.file_path.clone())
                    .or_default();
                file_map.insert(section.line_start, lines_added);
            }
        }
    }
    #[must_use]
    pub fn cumulative_offset(&self, index: usize) -> usize {
        let section = &self.sections[index];
        let target_file = &section.file_path;
        let target_line = section.line_start;
        if let Some(file_map) = self.file_offsets.get(target_file) {
            file_map
                .iter()
                .filter(|(line, _)| **line < target_line)
                .map(|(_, offset)| offset)
                .sum()
        } else {
            0
        }
    }
    pub fn load_docs(&mut self, plan: EditPlan) {
        let mut doc_map: HashMap<String, Vec<String>> = HashMap::new();
        for edit in plan.edits {
            let key = format!(
                "{}:{}:{}",
                edit.file_name, edit.line_start, edit.column_start
            );
            let lines: Vec<String> = edit
                .section_content
                .lines()
                .map(std::string::ToString::to_string)
                .collect();
            doc_map.insert(key, lines);
        }
        for section in &mut self.sections {
            let key = format!(
                "{}:{}:{}",
                section.file_path, section.line_start, section.column_start
            );
            if doc_map.contains_key(&key) {
                if let Ok(content) = fs::read_to_string(&section.file_path) {
                    let bytes = content.as_bytes();
                    if section.byte_start < bytes.len() && section.byte_end <= bytes.len() {}
                }
            }
        }
    }
    #[must_use]
    pub fn generate_edit_plan(&self) -> EditPlan {
        let mut edits = Vec::new();
        for section in &self.sections {
            if let Some(ref doc_lines) = section.section_content {
                let section_content = doc_lines.join("\n");
                edits.push(Edit {
                    file_name: section.file_path.clone(),
                    line_start: section.line_start,
                    line_end: section.line_end,
                    column_start: section.column_start,
                    column_end: section.column_end,
                    section_content,
                    item_name: section.title.clone(),
                });
            }
        }
        EditPlan { edits }
    }
    pub fn enter_detail_view(&mut self) {
        let Some(section_idx) = self.get_current_section_index() else {
            return;
        };
        let section = &self.sections[section_idx];
        if let Some(chunk_type) = &section.chunk_type {
            let content = match chunk_type {
                ChunkType::Added => section.rhs_content.clone().unwrap_or_default(),
                ChunkType::Deleted => section.lhs_content.clone().unwrap_or_default(),
                ChunkType::Modified => {
                    let lhs = section.lhs_content.as_deref().unwrap_or("");
                    let rhs = section.rhs_content.as_deref().unwrap_or("");
                    format!("- {lhs}\n+ {rhs}")
                }
                ChunkType::Unchanged => section
                    .lhs_content
                    .clone()
                    .or_else(|| section.rhs_content.clone())
                    .unwrap_or_default(),
            };
            let lines = Lines::from(content.as_str());
            self.editor_state = Some(EditorState::new(lines));
        } else if let Ok(content) = fs::read_to_string(&section.file_path) {
            let bytes = content.as_bytes();
            let section_bytes =
                &bytes[section.byte_start.min(bytes.len())..section.byte_end.min(bytes.len())];
            let section_content = String::from_utf8_lossy(section_bytes).to_string();
            let lines_text = if section_content.trim().is_empty() {
                "\n".to_string()
            } else {
                format!("\n{}\n", section_content.trim())
            };
            let lines = Lines::from(lines_text.as_str());
            self.editor_state = Some(EditorState::new(lines));
        }
        self.current_view = View::Detail;
    }
    pub fn exit_detail_view(&mut self, save: bool) {
        if save {
            if let Some(ref editor_state) = self.editor_state {
                if let Some(section_idx) = self.get_current_section_index() {
                    let lines = editor_state
                        .lines
                        .iter_row()
                        .map(|line| line.iter().collect::<String>())
                        .collect();
                    self.sections[section_idx].section_content = Some(lines);
                }
            }
        }
        self.editor_state = None;
        self.current_view = View::List;
    }
    pub fn save_current(&mut self) -> io::Result<()> {
        let editor_lines = if let Some(ref editor_state) = self.editor_state {
            editor_state
                .lines
                .iter_row()
                .map(|line| line.iter().collect::<String>())
                .collect::<Vec<_>>()
        } else {
            return Ok(());
        };
        let Some(section_idx) = self.get_current_section_index() else {
            return Ok(());
        };
        self.sections[section_idx].section_content = Some(editor_lines.clone());
        let section = &self.sections[section_idx];
        let raw_content = editor_lines.join("\n");
        let trimmed_content = raw_content.trim();
        let padded_content = format!("\n{trimmed_content}\n\n");
        let edit = Edit {
            file_name: section.file_path.clone(),
            line_start: section.line_start,
            line_end: section.line_end,
            column_start: section.column_start,
            column_end: section.column_end,
            section_content: padded_content,
            item_name: section.title.clone(),
        };
        let mut plan = EditPlan { edits: vec![edit] };
        plan.apply()?;
        let format = MarkdownFormat;
        if let Ok(new_sections) =
            input::extract_sections(&PathBuf::from(&section.file_path), &format)
        {
            let target_title = section.title.clone();
            let target_level = section.level;
            let file_path = section.file_path.clone();
            self.sections.retain(|s| s.file_path != file_path);
            if let Some(local_index) = new_sections
                .iter()
                .position(|s| s.title == target_title && s.level == target_level)
            {
                let new_global_index = self.sections.len() + local_index;
                self.sections.extend(new_sections);
                self.rebuild_tree();
                if let Some(node_idx) = self
                    .tree_nodes
                    .iter()
                    .position(|n| n.section_index == Some(new_global_index))
                {
                    self.current_node_index = node_idx;
                }
            } else {
                self.sections.extend(new_sections);
                self.rebuild_tree();
            }
        }
        self.rebuild_file_offsets();
        self.message = Some("Saved".to_string());
        Ok(())
    }
    #[must_use]
    pub fn find_next_node(&self) -> Option<usize> {
        ((self.current_node_index + 1)..self.tree_nodes.len())
            .find(|&i| self.tree_nodes[i].navigable)
    }
    #[must_use]
    pub fn find_prev_node(&self) -> Option<usize> {
        (0..self.current_node_index)
            .rev()
            .find(|&i| self.tree_nodes[i].navigable)
    }
    #[must_use]
    pub fn navigate_to_parent(&self) -> Option<usize> {
        let section_idx = self.get_current_section_index()?;
        let parent_section_idx = self.sections[section_idx].parent_index?;
        self.tree_nodes
            .iter()
            .position(|n| n.section_index == Some(parent_section_idx))
    }
    #[must_use]
    pub fn navigate_to_first_child(&self) -> Option<usize> {
        let section_idx = self.get_current_section_index()?;
        let first_child_idx = self.sections[section_idx].children_indices.first()?;
        self.tree_nodes
            .iter()
            .position(|n| n.section_index == Some(*first_child_idx))
    }
    #[must_use]
    pub fn navigate_to_next_descendant(&self) -> Option<usize> {
        let section_idx = self.get_current_section_index()?;
        if let Some(first_child) = self.sections[section_idx].children_indices.first() {
            return self
                .tree_nodes
                .iter()
                .position(|n| n.section_index == Some(*first_child));
        }
        for i in (section_idx + 1)..self.sections.len() {
            if self.sections[i].level > self.sections[section_idx].level {
                return self
                    .tree_nodes
                    .iter()
                    .position(|n| n.section_index == Some(i));
            }
        }
        None
    }
    #[must_use]
    pub fn navigate_to_next_sibling(&self) -> Option<usize> {
        let section_idx = self.get_current_section_index()?;
        let current_level = self.sections[section_idx].level;
        for i in (section_idx + 1)..self.sections.len() {
            if self.sections[i].level == current_level {
                return self
                    .tree_nodes
                    .iter()
                    .position(|n| n.section_index == Some(i));
            }
            if self.sections[i].level < current_level {
                break;
            }
        }
        None
    }
    #[must_use]
    pub fn navigate_to_prev_sibling(&self) -> Option<usize> {
        let section_idx = self.get_current_section_index()?;
        let current_level = self.sections[section_idx].level;
        for i in (0..section_idx).rev() {
            if self.sections[i].level == current_level {
                return self
                    .tree_nodes
                    .iter()
                    .position(|n| n.section_index == Some(i));
            }
            if self.sections[i].level < current_level {
                break;
            }
        }
        None
    }
    #[must_use]
    pub fn navigate_to_first(&self) -> Option<usize> {
        self.tree_nodes.iter().position(|n| n.navigable)
    }
    #[must_use]
    pub fn navigate_to_last(&self) -> Option<usize> {
        self.tree_nodes.iter().rposition(|n| n.navigable)
    }
    #[must_use]
    pub fn navigate_to_first_at_level(&self) -> Option<usize> {
        let section_idx = self.get_current_section_index()?;
        let current_level = self.sections[section_idx].level;
        for i in 0..self.sections.len() {
            if self.sections[i].level == current_level {
                return self
                    .tree_nodes
                    .iter()
                    .position(|n| n.section_index == Some(i));
            }
        }
        None
    }
    #[must_use]
    pub fn navigate_to_last_at_level(&self) -> Option<usize> {
        let section_idx = self.get_current_section_index()?;
        let current_level = self.sections[section_idx].level;
        for i in (0..self.sections.len()).rev() {
            if self.sections[i].level == current_level {
                return self
                    .tree_nodes
                    .iter()
                    .position(|n| n.section_index == Some(i));
            }
        }
        None
    }
    #[must_use]
    pub fn get_indent(&self) -> usize {
        if let Some(section) = self.get_current_section() {
            section.level * 2
        } else {
            0
        }
    }
    #[must_use]
    pub fn get_max_line_width(&self) -> usize {
        let indent = self.get_indent();
        self.wrap_width.saturating_sub(indent)
    }
    pub fn start_move(&mut self) {
        if let Some(section_idx) = self.get_current_section_index() {
            self.moving_section_index = Some(section_idx);
            self.move_state = MoveState::Selected;
        }
    }
    pub fn cancel_move(&mut self) {
        self.moving_section_index = None;
        self.move_state = MoveState::None;
    }
    pub fn mark_moved(&mut self) {
        self.move_state = MoveState::Moved;
    }
    pub fn move_section_up(&mut self) -> bool {
        if let Some(moving_idx) = self.moving_section_index {
            if moving_idx > 0 {
                self.sections.swap(moving_idx, moving_idx - 1);
                self.moving_section_index = Some(moving_idx - 1);
                self.rebuild_tree();
                if let Some(node_idx) = self
                    .tree_nodes
                    .iter()
                    .position(|n| n.section_index == Some(moving_idx - 1))
                {
                    self.current_node_index = node_idx;
                }
                self.mark_moved();
                return true;
            }
        }
        false
    }
    pub fn move_section_down(&mut self) -> bool {
        if let Some(moving_idx) = self.moving_section_index {
            if moving_idx < self.sections.len() - 1 {
                self.sections.swap(moving_idx, moving_idx + 1);
                self.moving_section_index = Some(moving_idx + 1);
                self.rebuild_tree();
                if let Some(node_idx) = self
                    .tree_nodes
                    .iter()
                    .position(|n| n.section_index == Some(moving_idx + 1))
                {
                    self.current_node_index = node_idx;
                }
                self.mark_moved();
                return true;
            }
        }
        false
    }
    pub fn move_section_to_top(&mut self) -> bool {
        if let Some(moving_idx) = self.moving_section_index {
            if moving_idx > 0 {
                let section = self.sections.remove(moving_idx);
                self.sections.insert(0, section);
                self.moving_section_index = Some(0);
                self.rebuild_tree();
                if let Some(node_idx) = self
                    .tree_nodes
                    .iter()
                    .position(|n| n.section_index == Some(0))
                {
                    self.current_node_index = node_idx;
                }
                self.mark_moved();
                return true;
            }
        }
        false
    }
    pub fn move_section_to_bottom(&mut self) -> bool {
        if let Some(moving_idx) = self.moving_section_index {
            let last_idx = self.sections.len() - 1;
            if moving_idx < last_idx {
                let section = self.sections.remove(moving_idx);
                self.sections.push(section);
                self.moving_section_index = Some(last_idx);
                self.rebuild_tree();
                if let Some(node_idx) = self
                    .tree_nodes
                    .iter()
                    .position(|n| n.section_index == Some(last_idx))
                {
                    self.current_node_index = node_idx;
                }
                self.mark_moved();
                return true;
            }
        }
        false
    }
    pub fn move_section_in(&mut self) -> bool {
        if let Some(moving_idx) = self.moving_section_index {
            if self.sections[moving_idx].level > 1 {
                self.sections[moving_idx].level -= 1;
                self.rebuild_tree();
                self.mark_moved();
                return true;
            }
        }
        false
    }
    pub fn move_section_out(&mut self) -> bool {
        if let Some(moving_idx) = self.moving_section_index {
            if self.sections[moving_idx].level < 6 {
                self.sections[moving_idx].level += 1;
                self.rebuild_tree();
                self.mark_moved();
                return true;
            }
        }
        false
    }
    pub fn save_section_reorder(&mut self) -> io::Result<()> {
        if self.move_state != MoveState::Moved {
            return Ok(());
        }
        let mut file_sections: HashMap<String, Vec<&Section>> = HashMap::new();
        for section in &self.sections {
            file_sections
                .entry(section.file_path.clone())
                .or_default()
                .push(section);
        }
        for (file_path, sections) in file_sections {
            Self::rewrite_file_sections(&file_path, &sections)?;
        }
        let format = MarkdownFormat;
        let mut new_sections = Vec::new();
        for file in &self.files {
            if let Ok(secs) = input::extract_sections(file, &format) {
                new_sections.extend(secs);
            }
        }
        self.sections = new_sections;
        self.rebuild_tree();
        self.cancel_move();
        self.message = Some("Sections reordered".to_string());
        Ok(())
    }
    fn rewrite_file_sections(file_path: &str, sections: &[&Section]) -> io::Result<()> {
        let content = fs::read_to_string(file_path)?;
        let mut new_content = String::new();
        for section in sections {
            let heading_prefix = "#".repeat(section.level);
            let heading = format!("{} {}", heading_prefix, section.title);
            let bytes = content.as_bytes();
            let section_text =
                if section.byte_start < bytes.len() && section.byte_end <= bytes.len() {
                    String::from_utf8_lossy(&bytes[section.byte_start..section.byte_end])
                        .to_string()
                        .trim()
                        .to_string()
                } else {
                    String::new()
                };
            new_content.push_str(&heading);
            new_content.push_str("\n\n");
            if !section_text.is_empty() {
                new_content.push_str(&section_text);
                new_content.push_str("\n\n");
            }
        }
        fs::write(file_path, new_content)?;
        Ok(())
    }
}
#[cfg(test)]
#[path = "tests/app_state.rs"]
mod tests;

[SYNCDOC DEBUG] === HUNK DEBUG ===
[SYNCDOC DEBUG] Before lines: 891
[SYNCDOC DEBUG] After lines: 662
[SYNCDOC DEBUG] Hunks: 149
[SYNCDOC DEBUG] Hunk 0: before[0..7] -> after[0..1]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [0]: "//! The core state machine bridging document sections and the interactive editor."
[SYNCDOC DEBUG]     [1]: "//!"
[SYNCDOC DEBUG]     [2]: "//! A TUI needs a single source of truth that can be interrogated and mutated as the user navigates"
[SYNCDOC DEBUG]     [3]: "//! and edits. We achieve this by syncing the editor save state with the files on disk. We keep"
[SYNCDOC DEBUG]     [4]: "//! track of the cumulative total number of lines that have been added to the file during the"
[SYNCDOC DEBUG]     [5]: "//! session so that we can determine the correct offset to insert content at without re-parsing."
[SYNCDOC DEBUG]     [6]: ""
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG]     [0]: "# ! [doc = syncdoc :: module_doc ! ()]"
[SYNCDOC DEBUG] Hunk 1: before[16..18] -> after[10..11]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [16]: ""
[SYNCDOC DEBUG]     [17]: "/// Determines navigation scope and quit behavior based on project size."
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG]     [10]: "#[syncdoc::omnidoc]"
[SYNCDOC DEBUG] Hunk 2: before[20..21] -> after[13..13]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [20]: "    /// Single-file mode quits directly to shell."
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 3: before[22..23] -> after[14..14]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [22]: "    /// Multi-file mode shows file tree in list view."
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 4: before[25..27] -> after[16..17]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [25]: ""
[SYNCDOC DEBUG]     [26]: "/// Tracks the lifecycle of a section reordering operation."
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG]     [16]: "#[syncdoc::omnidoc]"
[SYNCDOC DEBUG] Hunk 5: before[29..30] -> after[19..19]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [29]: "    /// No section is being moved; normal navigation mode."
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 6: before[31..32] -> after[20..20]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [31]: "    /// A section has been selected for moving but no changes made yet."
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 7: before[33..34] -> after[21..21]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [33]: "    /// Section has been repositioned but changes not yet persisted to disk."
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 8: before[36..38] -> after[23..24]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [36]: ""
[SYNCDOC DEBUG]     [37]: "/// Bridges document sections and the interactive editor, maintaining session state."
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG]     [23]: "#[syncdoc::omnidoc]"
[SYNCDOC DEBUG] Hunk 9: before[39..40] -> after[25..25]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [39]: "    /// All parsed sections across loaded files."
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 10: before[41..42] -> after[26..26]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [41]: "    /// Unified tree of directories, files, and sections for display"
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 11: before[43..44] -> after[27..27]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [43]: "    /// File paths available for editing."
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 12: before[45..46] -> after[28..28]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [45]: "    /// Controls navigation behavior and file tree visibility."
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 13: before[47..48] -> after[29..29]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [47]: "    /// Active UI screen determining input handling."
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 14: before[49..50] -> after[30..30]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [49]: "    /// Selected node index in the tree"
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 15: before[51..52] -> after[31..31]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [51]: "    /// Editor buffer content when detail view is active."
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 16: before[53..54] -> after[32..32]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [53]: "    /// Accumulates vim-style command input after ':' is pressed."
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 17: before[55..56] -> after[33..33]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [55]: "    /// Status feedback displayed in the help bar."
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 18: before[57..58] -> after[34..34]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [57]: "    /// Maximum line width for text wrapping in the editor."
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 19: before[59..60] -> after[35..35]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [59]: "    /// Tracks line count changes per section to calculate write positions without re-parsing."
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 20: before[61..62] -> after[36..36]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [61]: "    /// Tracks section being moved for visual feedback"
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 21: before[63..64] -> after[37..37]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [63]: "    /// Index of section being moved (if any)"
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 22: before[66..68] -> after[39..40]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [66]: ""
[SYNCDOC DEBUG]     [67]: "/// Determines which UI screen renders and how input is interpreted."
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG]     [39]: "#[syncdoc::omnidoc]"
[SYNCDOC DEBUG] Hunk 23: before[70..71] -> after[42..42]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [70]: "    /// Shows hierarchical section tree with navigation."
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 24: before[72..73] -> after[43..43]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [72]: "    /// Provides vim-like editor for section content."
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 25: before[74..75] -> after[44..44]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [74]: "    /// Captures vim-style command input after ':' keystroke."
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 26: before[77..78] -> after[46..47]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [77]: ""
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG]     [46]: "#[syncdoc::omnidoc]"
[SYNCDOC DEBUG] Hunk 27: before[79..80] -> after[48..48]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [79]: "    /// Initialises application state with parsed sections and determines file mode."
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 28: before[87..88] -> after[55..55]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [87]: ""
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 29: before[89..91] -> after[56..56]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [89]: ""
[SYNCDOC DEBUG]     [90]: "        // Find first navigable node"
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 30: before[92..93] -> after[57..57]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [92]: ""
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 31: before[109..110] -> after[73..73]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [109]: ""
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 32: before[112..115] -> after[75..75]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [112]: ""
[SYNCDOC DEBUG]     [113]: "        // Determine if this is difftastic mode by checking if multiple sections share the same file_path"
[SYNCDOC DEBUG]     [114]: "        // (in markdown mode, each section has a unique file path or sections are from the same file)"
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 33: before[122..123] -> after[82..82]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [122]: ""
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 34: before[124..125] -> after[83..83]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [124]: "            // Single markdown file mode: use section level for tree indentation"
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 35: before[129..130] -> after[87..87]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [129]: "            // Difftastic mode: group sections by file, show files as non-navigable nodes"
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 36: before[132..134] -> after[89..89]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [132]: ""
[SYNCDOC DEBUG]     [133]: "            // Group sections by file and infer file statuses"
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 37: before[139..141] -> after[94..94]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [139]: ""
[SYNCDOC DEBUG]     [140]: "                // Determine file status from hunk headers"
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 38: before[154..156] -> after[107..107]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [154]: ""
[SYNCDOC DEBUG]     [155]: "            // Build tree with file nodes and hunk sections"
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 39: before[158..159] -> after[109..109]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [158]: ""
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 40: before[160..161] -> after[110..110]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [160]: "                // Add file node (non-navigable)"
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 41: before[164..167] -> after[113..114]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [164]: ""
[SYNCDOC DEBUG]     [165]: "                let status_opt = file_status.get(file_path).and_then(|opt| opt.as_deref()); // flatten Option<Option<&str>>"
[SYNCDOC DEBUG]     [166]: ""
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG]     [113]: "                let status_opt = file_status.get(file_path).and_then(|opt| opt.as_deref());"
[SYNCDOC DEBUG] Hunk 42: before[171..172] -> after[118..118]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [171]: ""
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 43: before[173..175] -> after[119..119]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [173]: ""
[SYNCDOC DEBUG]     [174]: "                // Add hunk sections under this file"
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 44: before[182..183] -> after[126..126]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [182]: "            // Multi-file markdown mode: build directory tree with sections nested under files"
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 45: before[184..186] -> after[127..127]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [184]: ""
[SYNCDOC DEBUG]     [185]: "            // Group sections by file"
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 46: before[192..194] -> after[133..133]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [192]: ""
[SYNCDOC DEBUG]     [193]: "            // Build tree with directory structure"
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 47: before[196..197] -> after[135..135]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [196]: ""
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 48: before[199..201] -> after[137..137]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [199]: ""
[SYNCDOC DEBUG]     [200]: "                // Add file node (non-navigable)"
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 49: before[204..205] -> after[140..140]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [204]: ""
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 50: before[206..208] -> after[141..141]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [206]: ""
[SYNCDOC DEBUG]     [207]: "                // Add sections under this file"
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 51: before[215..216] -> after[148..148]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [215]: ""
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 52: before[218..220] -> after[150..150]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [218]: ""
[SYNCDOC DEBUG]     [219]: "    /// Rebuild tree after sections change (e.g., after save)"
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 53: before[222..224] -> after[152..152]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [222]: ""
[SYNCDOC DEBUG]     [223]: "        // Try to maintain current position by finding same section"
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 54: before[234..236] -> after[162..162]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [234]: ""
[SYNCDOC DEBUG]     [235]: "    /// Get the section index for the currently selected node (if it's a section)"
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 55: before[244..246] -> after[170..170]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [244]: ""
[SYNCDOC DEBUG]     [245]: "    /// Get the current section (if on a section node)"
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 56: before[251..252] -> after[175..175]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [251]: ""
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 57: before[254..255] -> after[177..177]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [254]: ""
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 58: before[258..259] -> after[180..180]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [258]: ""
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 59: before[263..264] -> after[184..184]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [263]: ""
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 60: before[268..270] -> after[188..188]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [268]: ""
[SYNCDOC DEBUG]     [269]: "    /// Calculates total lines added before a section to determine correct write position."
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 61: before[275..276] -> after[193..193]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [275]: ""
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 62: before[286..288] -> after[203..203]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [286]: ""
[SYNCDOC DEBUG]     [287]: "    /// Restores previously edited content from a saved edit plan."
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 63: before[302..304] -> after[217..217]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [302]: ""
[SYNCDOC DEBUG]     [303]: "        // Match edits to sections and pre-populate editor content"
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 64: before[312..315] -> after[225..226]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [312]: "                    if section.byte_start < bytes.len() && section.byte_end <= bytes.len() {"
[SYNCDOC DEBUG]     [313]: "                        // Section exists and can be loaded"
[SYNCDOC DEBUG]     [314]: "                    }"
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG]     [225]: "                    if section.byte_start < bytes.len() && section.byte_end <= bytes.len() {}"
[SYNCDOC DEBUG] Hunk 65: before[319..321] -> after[230..230]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [319]: ""
[SYNCDOC DEBUG]     [320]: "    /// Creates a serialisable plan capturing current editor modifications."
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 66: before[324..325] -> after[233..233]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [324]: ""
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 67: before[328..329] -> after[236..236]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [328]: ""
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 68: before[340..341] -> after[247..247]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [340]: ""
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 69: before[343..345] -> after[249..249]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [343]: ""
[SYNCDOC DEBUG]     [344]: "    /// Loads selected section content into the editor buffer."
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 70: before[349..350] -> after[253..253]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [349]: ""
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 71: before[351..353] -> after[254..254]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [351]: ""
[SYNCDOC DEBUG]     [352]: "        // Handle difftastic chunks differently"
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 72: before[355..363] -> after[256..258]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [355]: "                ChunkType::Added => {"
[SYNCDOC DEBUG]     [356]: "                    // Show only RHS for added chunks"
[SYNCDOC DEBUG]     [357]: "                    section.rhs_content.clone().unwrap_or_default()"
[SYNCDOC DEBUG]     [358]: "                }"
[SYNCDOC DEBUG]     [359]: "                ChunkType::Deleted => {"
[SYNCDOC DEBUG]     [360]: "                    // Show LHS with strikethrough or special formatting"
[SYNCDOC DEBUG]     [361]: "                    section.lhs_content.clone().unwrap_or_default()"
[SYNCDOC DEBUG]     [362]: "                }"
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG]     [256]: "                ChunkType::Added => section.rhs_content.clone().unwrap_or_default(),"
[SYNCDOC DEBUG]     [257]: "                ChunkType::Deleted => section.lhs_content.clone().unwrap_or_default(),"
[SYNCDOC DEBUG] Hunk 73: before[364..365] -> after[259..259]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [364]: "                    // Show a unified or side-by-side view"
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 74: before[369..377] -> after[263..268]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [369]: "                ChunkType::Unchanged => {"
[SYNCDOC DEBUG]     [370]: "                    // Show either side (they're the same)"
[SYNCDOC DEBUG]     [371]: "                    section"
[SYNCDOC DEBUG]     [372]: "                        .lhs_content"
[SYNCDOC DEBUG]     [373]: "                        .clone()"
[SYNCDOC DEBUG]     [374]: "                        .or_else(|| section.rhs_content.clone())"
[SYNCDOC DEBUG]     [375]: "                        .unwrap_or_default()"
[SYNCDOC DEBUG]     [376]: "                }"
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG]     [263]: "                ChunkType::Unchanged => section"
[SYNCDOC DEBUG]     [264]: "                    .lhs_content"
[SYNCDOC DEBUG]     [265]: "                    .clone()"
[SYNCDOC DEBUG]     [266]: "                    .or_else(|| section.rhs_content.clone())"
[SYNCDOC DEBUG]     [267]: "                    .unwrap_or_default(),"
[SYNCDOC DEBUG] Hunk 75: before[378..379] -> after[269..269]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [378]: ""
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 76: before[385..386] -> after[275..275]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [385]: ""
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 77: before[387..388] -> after[276..276]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [387]: ""
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 78: before[393..394] -> after[281..281]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [393]: ""
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 79: before[397..398] -> after[284..284]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [397]: ""
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 80: before[400..402] -> after[286..286]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [400]: ""
[SYNCDOC DEBUG]     [401]: "    /// Returns to section list, optionally persisting editor changes."
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 81: before[418..424] -> after[302..302]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [418]: ""
[SYNCDOC DEBUG]     [419]: "    /// Save the current section's content to disk."
[SYNCDOC DEBUG]     [420]: "    ///"
[SYNCDOC DEBUG]     [421]: "    /// # Errors"
[SYNCDOC DEBUG]     [422]: "    ///"
[SYNCDOC DEBUG]     [423]: "    /// Returns an error if writing to disk fails or if file operations cannot complete."
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 82: before[434..435] -> after[312..312]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [434]: ""
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 83: before[438..439] -> after[315..315]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [438]: ""
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 84: before[440..441] -> after[316..316]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [440]: ""
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 85: before[442..443] -> after[317..317]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [442]: ""
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 86: before[446..447] -> after[320..320]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [446]: ""
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 87: before[456..457] -> after[329..329]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [456]: ""
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 88: before[459..461] -> after[331..331]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [459]: ""
[SYNCDOC DEBUG]     [460]: "        // Reload sections"
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 89: before[467..468] -> after[337..337]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [467]: ""
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 90: before[470..471] -> after[339..339]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [470]: ""
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 91: before[477..479] -> after[345..345]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [477]: ""
[SYNCDOC DEBUG]     [478]: "                // Rebuild tree and find the updated section"
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 92: before[480..482] -> after[346..346]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [480]: ""
[SYNCDOC DEBUG]     [481]: "                // Find node with this section index"
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 93: before[494..495] -> after[358..358]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [494]: ""
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 94: before[499..501] -> after[362..362]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [499]: ""
[SYNCDOC DEBUG]     [500]: "    /// Navigate to next navigable node"
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 95: before[506..508] -> after[367..367]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [506]: ""
[SYNCDOC DEBUG]     [507]: "    /// Navigate to previous navigable node"
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 96: before[514..516] -> after[373..373]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [514]: ""
[SYNCDOC DEBUG]     [515]: "    /// Moves to the containing section in the document hierarchy."
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 97: before[520..522] -> after[377..377]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [520]: ""
[SYNCDOC DEBUG]     [521]: "        // Find tree node with this section index"
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 98: before[526..528] -> after[381..381]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [526]: ""
[SYNCDOC DEBUG]     [527]: "    /// Descends to the first child section in the document hierarchy."
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 99: before[532..533] -> after[385..385]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [532]: ""
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 100: before[537..539] -> after[389..389]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [537]: ""
[SYNCDOC DEBUG]     [538]: "    /// Finds the next descendant section at any depth in the hierarchy."
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 101: before[542..544] -> after[392..392]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [542]: ""
[SYNCDOC DEBUG]     [543]: "        // First try immediate children"
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 102: before[550..552] -> after[398..398]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [550]: ""
[SYNCDOC DEBUG]     [551]: "        // Otherwise find next section at deeper level"
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 103: before[560..561] -> after[406..406]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [560]: ""
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 104: before[563..565] -> after[408..408]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [563]: ""
[SYNCDOC DEBUG]     [564]: "    /// Finds the next section at the same hierarchy level."
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 105: before[569..570] -> after[412..412]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [569]: ""
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 106: before[581..582] -> after[423..423]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [581]: ""
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 107: before[584..586] -> after[425..425]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [584]: ""
[SYNCDOC DEBUG]     [585]: "    /// Finds the previous section at the same hierarchy level."
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 108: before[590..591] -> after[429..429]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [590]: ""
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 109: before[602..603] -> after[440..440]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [602]: ""
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 110: before[605..607] -> after[442..442]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [605]: ""
[SYNCDOC DEBUG]     [606]: "    /// Jumps to the first navigable node."
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 111: before[611..613] -> after[446..446]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [611]: ""
[SYNCDOC DEBUG]     [612]: "    /// Jumps to the last navigable node."
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 112: before[617..619] -> after[450..450]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [617]: ""
[SYNCDOC DEBUG]     [618]: "    /// Finds the first section at the same hierarchy level."
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 113: before[623..624] -> after[454..454]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [623]: ""
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 114: before[632..633] -> after[462..462]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [632]: ""
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 115: before[635..637] -> after[464..464]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [635]: ""
[SYNCDOC DEBUG]     [636]: "    /// Finds the last section at the same hierarchy level."
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 116: before[641..642] -> after[468..468]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [641]: ""
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 117: before[650..651] -> after[476..476]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [650]: ""
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 118: before[653..655] -> after[478..478]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [653]: ""
[SYNCDOC DEBUG]     [654]: "    /// Calculates indentation width based on section nesting level."
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 119: before[663..665] -> after[486..486]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [663]: ""
[SYNCDOC DEBUG]     [664]: "    /// Determines available width for text after accounting for indentation."
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 120: before[670..674] -> after[491..491]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [670]: ""
[SYNCDOC DEBUG]     [671]: "    // --- Section List Movement ---"
[SYNCDOC DEBUG]     [672]: ""
[SYNCDOC DEBUG]     [673]: "    /// Start moving the current section"
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 121: before[680..682] -> after[497..497]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [680]: ""
[SYNCDOC DEBUG]     [681]: "    /// Cancel the current move operation"
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 122: before[686..688] -> after[501..501]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [686]: ""
[SYNCDOC DEBUG]     [687]: "    /// Mark section as moved but not yet saved"
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 123: before[691..693] -> after[504..504]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [691]: ""
[SYNCDOC DEBUG]     [692]: "    /// Move section up by one position"
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 124: before[699..701] -> after[510..510]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [699]: ""
[SYNCDOC DEBUG]     [700]: "                // Update current node to follow the moved section"
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 125: before[708..709] -> after[517..517]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [708]: ""
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 126: before[715..717] -> after[523..523]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [715]: ""
[SYNCDOC DEBUG]     [716]: "    /// Move section down by one position"
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 127: before[723..724] -> after[529..529]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [723]: ""
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 128: before[731..732] -> after[536..536]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [731]: ""
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 129: before[738..740] -> after[542..542]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [738]: ""
[SYNCDOC DEBUG]     [739]: "    /// Move section to top of document"
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 130: before[747..748] -> after[549..549]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [747]: ""
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 131: before[755..756] -> after[556..556]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [755]: ""
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 132: before[762..764] -> after[562..562]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [762]: ""
[SYNCDOC DEBUG]     [763]: "    /// Move section to bottom of document"
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 133: before[772..773] -> after[570..570]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [772]: ""
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 134: before[780..781] -> after[577..577]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [780]: ""
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 135: before[787..789] -> after[583..583]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [787]: ""
[SYNCDOC DEBUG]     [788]: "    /// Increase section level (move in - lower level number)"
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 136: before[800..802] -> after[594..594]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [800]: ""
[SYNCDOC DEBUG]     [801]: "    /// Decrease section level (move out - higher level number)"
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 137: before[813..819] -> after[605..605]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [813]: ""
[SYNCDOC DEBUG]     [814]: "    /// Apply section reordering to disk"
[SYNCDOC DEBUG]     [815]: "    ///"
[SYNCDOC DEBUG]     [816]: "    /// # Errors"
[SYNCDOC DEBUG]     [817]: "    ///"
[SYNCDOC DEBUG]     [818]: "    /// Returns an error if writing to disk fails or if file operations cannot complete."
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 138: before[823..825] -> after[609..609]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [823]: ""
[SYNCDOC DEBUG]     [824]: "        // Group sections by file"
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 139: before[832..834] -> after[616..616]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [832]: ""
[SYNCDOC DEBUG]     [833]: "        // Process each file"
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 140: before[837..839] -> after[619..619]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [837]: ""
[SYNCDOC DEBUG]     [838]: "        // Reload sections to get updated positions"
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 141: before[846..847] -> after[626..626]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [846]: ""
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 142: before[851..852] -> after[630..630]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [851]: ""
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 143: before[854..856] -> after[632..632]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [854]: ""
[SYNCDOC DEBUG]     [855]: "    /// Rewrite an entire file with reordered sections"
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 144: before[859..860] -> after[635..635]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [859]: ""
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 145: before[863..864] -> after[638..638]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [863]: ""
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 146: before[874..875] -> after[648..648]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [874]: ""
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 147: before[882..883] -> after[655..655]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [882]: ""
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 148: before[887..888] -> after[659..659]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [887]: ""
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] ==================
[SYNCDOC DEBUG] DEBUG restore: Found 149 hunks
[SYNCDOC DEBUG]   Hunk 0: before[0..7] after[0..1]
[SYNCDOC DEBUG]   Hunk 1: before[16..18] after[10..11]
[SYNCDOC DEBUG]   Hunk 2: before[20..21] after[13..13]
[SYNCDOC DEBUG]   Hunk 3: before[22..23] after[14..14]
[SYNCDOC DEBUG]   Hunk 4: before[25..27] after[16..17]
[SYNCDOC DEBUG]   Hunk 5: before[29..30] after[19..19]
[SYNCDOC DEBUG]   Hunk 6: before[31..32] after[20..20]
[SYNCDOC DEBUG]   Hunk 7: before[33..34] after[21..21]
[SYNCDOC DEBUG]   Hunk 8: before[36..38] after[23..24]
[SYNCDOC DEBUG]   Hunk 9: before[39..40] after[25..25]
[SYNCDOC DEBUG]   Hunk 10: before[41..42] after[26..26]
[SYNCDOC DEBUG]   Hunk 11: before[43..44] after[27..27]
[SYNCDOC DEBUG]   Hunk 12: before[45..46] after[28..28]
[SYNCDOC DEBUG]   Hunk 13: before[47..48] after[29..29]
[SYNCDOC DEBUG]   Hunk 14: before[49..50] after[30..30]
[SYNCDOC DEBUG]   Hunk 15: before[51..52] after[31..31]
[SYNCDOC DEBUG]   Hunk 16: before[53..54] after[32..32]
[SYNCDOC DEBUG]   Hunk 17: before[55..56] after[33..33]
[SYNCDOC DEBUG]   Hunk 18: before[57..58] after[34..34]
[SYNCDOC DEBUG]   Hunk 19: before[59..60] after[35..35]
[SYNCDOC DEBUG]   Hunk 20: before[61..62] after[36..36]
[SYNCDOC DEBUG]   Hunk 21: before[63..64] after[37..37]
[SYNCDOC DEBUG]   Hunk 22: before[66..68] after[39..40]
[SYNCDOC DEBUG]   Hunk 23: before[70..71] after[42..42]
[SYNCDOC DEBUG]   Hunk 24: before[72..73] after[43..43]
[SYNCDOC DEBUG]   Hunk 25: before[74..75] after[44..44]
[SYNCDOC DEBUG]   Hunk 26: before[77..78] after[46..47]
[SYNCDOC DEBUG]   Hunk 27: before[79..80] after[48..48]
[SYNCDOC DEBUG]   Hunk 28: before[87..88] after[55..55]
[SYNCDOC DEBUG]   Hunk 29: before[89..91] after[56..56]
[SYNCDOC DEBUG]   Hunk 30: before[92..93] after[57..57]
[SYNCDOC DEBUG]   Hunk 31: before[109..110] after[73..73]
[SYNCDOC DEBUG]   Hunk 32: before[112..115] after[75..75]
[SYNCDOC DEBUG]   Hunk 33: before[122..123] after[82..82]
[SYNCDOC DEBUG]   Hunk 34: before[124..125] after[83..83]
[SYNCDOC DEBUG]   Hunk 35: before[129..130] after[87..87]
[SYNCDOC DEBUG]   Hunk 36: before[132..134] after[89..89]
[SYNCDOC DEBUG]   Hunk 37: before[139..141] after[94..94]
[SYNCDOC DEBUG]   Hunk 38: before[154..156] after[107..107]
[SYNCDOC DEBUG]   Hunk 39: before[158..159] after[109..109]
[SYNCDOC DEBUG]   Hunk 40: before[160..161] after[110..110]
[SYNCDOC DEBUG]   Hunk 41: before[164..167] after[113..114]
[SYNCDOC DEBUG]   Hunk 42: before[171..172] after[118..118]
[SYNCDOC DEBUG]   Hunk 43: before[173..175] after[119..119]
[SYNCDOC DEBUG]   Hunk 44: before[182..183] after[126..126]
[SYNCDOC DEBUG]   Hunk 45: before[184..186] after[127..127]
[SYNCDOC DEBUG]   Hunk 46: before[192..194] after[133..133]
[SYNCDOC DEBUG]   Hunk 47: before[196..197] after[135..135]
[SYNCDOC DEBUG]   Hunk 48: before[199..201] after[137..137]
[SYNCDOC DEBUG]   Hunk 49: before[204..205] after[140..140]
[SYNCDOC DEBUG]   Hunk 50: before[206..208] after[141..141]
[SYNCDOC DEBUG]   Hunk 51: before[215..216] after[148..148]
[SYNCDOC DEBUG]   Hunk 52: before[218..220] after[150..150]
[SYNCDOC DEBUG]   Hunk 53: before[222..224] after[152..152]
[SYNCDOC DEBUG]   Hunk 54: before[234..236] after[162..162]
[SYNCDOC DEBUG]   Hunk 55: before[244..246] after[170..170]
[SYNCDOC DEBUG]   Hunk 56: before[251..252] after[175..175]
[SYNCDOC DEBUG]   Hunk 57: before[254..255] after[177..177]
[SYNCDOC DEBUG]   Hunk 58: before[258..259] after[180..180]
[SYNCDOC DEBUG]   Hunk 59: before[263..264] after[184..184]
[SYNCDOC DEBUG]   Hunk 60: before[268..270] after[188..188]
[SYNCDOC DEBUG]   Hunk 61: before[275..276] after[193..193]
[SYNCDOC DEBUG]   Hunk 62: before[286..288] after[203..203]
[SYNCDOC DEBUG]   Hunk 63: before[302..304] after[217..217]
[SYNCDOC DEBUG]   Hunk 64: before[312..315] after[225..226]
[SYNCDOC DEBUG]   Hunk 65: before[319..321] after[230..230]
[SYNCDOC DEBUG]   Hunk 66: before[324..325] after[233..233]
[SYNCDOC DEBUG]   Hunk 67: before[328..329] after[236..236]
[SYNCDOC DEBUG]   Hunk 68: before[340..341] after[247..247]
[SYNCDOC DEBUG]   Hunk 69: before[343..345] after[249..249]
[SYNCDOC DEBUG]   Hunk 70: before[349..350] after[253..253]
[SYNCDOC DEBUG]   Hunk 71: before[351..353] after[254..254]
[SYNCDOC DEBUG]   Hunk 72: before[355..363] after[256..258]
[SYNCDOC DEBUG]   Hunk 73: before[364..365] after[259..259]
[SYNCDOC DEBUG]   Hunk 74: before[369..377] after[263..268]
[SYNCDOC DEBUG]   Hunk 75: before[378..379] after[269..269]
[SYNCDOC DEBUG]   Hunk 76: before[385..386] after[275..275]
[SYNCDOC DEBUG]   Hunk 77: before[387..388] after[276..276]
[SYNCDOC DEBUG]   Hunk 78: before[393..394] after[281..281]
[SYNCDOC DEBUG]   Hunk 79: before[397..398] after[284..284]
[SYNCDOC DEBUG]   Hunk 80: before[400..402] after[286..286]
[SYNCDOC DEBUG]   Hunk 81: before[418..424] after[302..302]
[SYNCDOC DEBUG]   Hunk 82: before[434..435] after[312..312]
[SYNCDOC DEBUG]   Hunk 83: before[438..439] after[315..315]
[SYNCDOC DEBUG]   Hunk 84: before[440..441] after[316..316]
[SYNCDOC DEBUG]   Hunk 85: before[442..443] after[317..317]
[SYNCDOC DEBUG]   Hunk 86: before[446..447] after[320..320]
[SYNCDOC DEBUG]   Hunk 87: before[456..457] after[329..329]
[SYNCDOC DEBUG]   Hunk 88: before[459..461] after[331..331]
[SYNCDOC DEBUG]   Hunk 89: before[467..468] after[337..337]
[SYNCDOC DEBUG]   Hunk 90: before[470..471] after[339..339]
[SYNCDOC DEBUG]   Hunk 91: before[477..479] after[345..345]
[SYNCDOC DEBUG]   Hunk 92: before[480..482] after[346..346]
[SYNCDOC DEBUG]   Hunk 93: before[494..495] after[358..358]
[SYNCDOC DEBUG]   Hunk 94: before[499..501] after[362..362]
[SYNCDOC DEBUG]   Hunk 95: before[506..508] after[367..367]
[SYNCDOC DEBUG]   Hunk 96: before[514..516] after[373..373]
[SYNCDOC DEBUG]   Hunk 97: before[520..522] after[377..377]
[SYNCDOC DEBUG]   Hunk 98: before[526..528] after[381..381]
[SYNCDOC DEBUG]   Hunk 99: before[532..533] after[385..385]
[SYNCDOC DEBUG]   Hunk 100: before[537..539] after[389..389]
[SYNCDOC DEBUG]   Hunk 101: before[542..544] after[392..392]
[SYNCDOC DEBUG]   Hunk 102: before[550..552] after[398..398]
[SYNCDOC DEBUG]   Hunk 103: before[560..561] after[406..406]
[SYNCDOC DEBUG]   Hunk 104: before[563..565] after[408..408]
[SYNCDOC DEBUG]   Hunk 105: before[569..570] after[412..412]
[SYNCDOC DEBUG]   Hunk 106: before[581..582] after[423..423]
[SYNCDOC DEBUG]   Hunk 107: before[584..586] after[425..425]
[SYNCDOC DEBUG]   Hunk 108: before[590..591] after[429..429]
[SYNCDOC DEBUG]   Hunk 109: before[602..603] after[440..440]
[SYNCDOC DEBUG]   Hunk 110: before[605..607] after[442..442]
[SYNCDOC DEBUG]   Hunk 111: before[611..613] after[446..446]
[SYNCDOC DEBUG]   Hunk 112: before[617..619] after[450..450]
[SYNCDOC DEBUG]   Hunk 113: before[623..624] after[454..454]
[SYNCDOC DEBUG]   Hunk 114: before[632..633] after[462..462]
[SYNCDOC DEBUG]   Hunk 115: before[635..637] after[464..464]
[SYNCDOC DEBUG]   Hunk 116: before[641..642] after[468..468]
[SYNCDOC DEBUG]   Hunk 117: before[650..651] after[476..476]
[SYNCDOC DEBUG]   Hunk 118: before[653..655] after[478..478]
[SYNCDOC DEBUG]   Hunk 119: before[663..665] after[486..486]
[SYNCDOC DEBUG]   Hunk 120: before[670..674] after[491..491]
[SYNCDOC DEBUG]   Hunk 121: before[680..682] after[497..497]
[SYNCDOC DEBUG]   Hunk 122: before[686..688] after[501..501]
[SYNCDOC DEBUG]   Hunk 123: before[691..693] after[504..504]
[SYNCDOC DEBUG]   Hunk 124: before[699..701] after[510..510]
[SYNCDOC DEBUG]   Hunk 125: before[708..709] after[517..517]
[SYNCDOC DEBUG]   Hunk 126: before[715..717] after[523..523]
[SYNCDOC DEBUG]   Hunk 127: before[723..724] after[529..529]
[SYNCDOC DEBUG]   Hunk 128: before[731..732] after[536..536]
[SYNCDOC DEBUG]   Hunk 129: before[738..740] after[542..542]
[SYNCDOC DEBUG]   Hunk 130: before[747..748] after[549..549]
[SYNCDOC DEBUG]   Hunk 131: before[755..756] after[556..556]
[SYNCDOC DEBUG]   Hunk 132: before[762..764] after[562..562]
[SYNCDOC DEBUG]   Hunk 133: before[772..773] after[570..570]
[SYNCDOC DEBUG]   Hunk 134: before[780..781] after[577..577]
[SYNCDOC DEBUG]   Hunk 135: before[787..789] after[583..583]
[SYNCDOC DEBUG]   Hunk 136: before[800..802] after[594..594]
[SYNCDOC DEBUG]   Hunk 137: before[813..819] after[605..605]
[SYNCDOC DEBUG]   Hunk 138: before[823..825] after[609..609]
[SYNCDOC DEBUG]   Hunk 139: before[832..834] after[616..616]
[SYNCDOC DEBUG]   Hunk 140: before[837..839] after[619..619]
[SYNCDOC DEBUG]   Hunk 141: before[846..847] after[626..626]
[SYNCDOC DEBUG]   Hunk 142: before[851..852] after[630..630]
[SYNCDOC DEBUG]   Hunk 143: before[854..856] after[632..632]
[SYNCDOC DEBUG]   Hunk 144: before[859..860] after[635..635]
[SYNCDOC DEBUG]   Hunk 145: before[863..864] after[638..638]
[SYNCDOC DEBUG]   Hunk 146: before[874..875] after[648..648]
[SYNCDOC DEBUG]   Hunk 147: before[882..883] after[655..655]
[SYNCDOC DEBUG]   Hunk 148: before[887..888] after[659..659]
[SYNCDOC DEBUG] === HUNK DEBUG ===
[SYNCDOC DEBUG] Before lines: 891
[SYNCDOC DEBUG] After lines: 662
[SYNCDOC DEBUG] Hunks: 149
[SYNCDOC DEBUG] Hunk 0: before[0..7] -> after[0..1]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [0]: "//! The core state machine bridging document sections and the interactive editor."
[SYNCDOC DEBUG]     [1]: "//!"
[SYNCDOC DEBUG]     [2]: "//! A TUI needs a single source of truth that can be interrogated and mutated as the user navigates"
[SYNCDOC DEBUG]     [3]: "//! and edits. We achieve this by syncing the editor save state with the files on disk. We keep"
[SYNCDOC DEBUG]     [4]: "//! track of the cumulative total number of lines that have been added to the file during the"
[SYNCDOC DEBUG]     [5]: "//! session so that we can determine the correct offset to insert content at without re-parsing."
[SYNCDOC DEBUG]     [6]: ""
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG]     [0]: "# ! [doc = syncdoc :: module_doc ! ()]"
[SYNCDOC DEBUG] Hunk 1: before[16..18] -> after[10..11]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [16]: ""
[SYNCDOC DEBUG]     [17]: "/// Determines navigation scope and quit behavior based on project size."
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG]     [10]: "#[syncdoc::omnidoc]"
[SYNCDOC DEBUG] Hunk 2: before[20..21] -> after[13..13]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [20]: "    /// Single-file mode quits directly to shell."
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 3: before[22..23] -> after[14..14]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [22]: "    /// Multi-file mode shows file tree in list view."
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 4: before[25..27] -> after[16..17]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [25]: ""
[SYNCDOC DEBUG]     [26]: "/// Tracks the lifecycle of a section reordering operation."
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG]     [16]: "#[syncdoc::omnidoc]"
[SYNCDOC DEBUG] Hunk 5: before[29..30] -> after[19..19]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [29]: "    /// No section is being moved; normal navigation mode."
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 6: before[31..32] -> after[20..20]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [31]: "    /// A section has been selected for moving but no changes made yet."
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 7: before[33..34] -> after[21..21]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [33]: "    /// Section has been repositioned but changes not yet persisted to disk."
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 8: before[36..38] -> after[23..24]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [36]: ""
[SYNCDOC DEBUG]     [37]: "/// Bridges document sections and the interactive editor, maintaining session state."
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG]     [23]: "#[syncdoc::omnidoc]"
[SYNCDOC DEBUG] Hunk 9: before[39..40] -> after[25..25]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [39]: "    /// All parsed sections across loaded files."
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 10: before[41..42] -> after[26..26]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [41]: "    /// Unified tree of directories, files, and sections for display"
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 11: before[43..44] -> after[27..27]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [43]: "    /// File paths available for editing."
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 12: before[45..46] -> after[28..28]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [45]: "    /// Controls navigation behavior and file tree visibility."
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 13: before[47..48] -> after[29..29]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [47]: "    /// Active UI screen determining input handling."
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 14: before[49..50] -> after[30..30]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [49]: "    /// Selected node index in the tree"
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 15: before[51..52] -> after[31..31]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [51]: "    /// Editor buffer content when detail view is active."
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 16: before[53..54] -> after[32..32]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [53]: "    /// Accumulates vim-style command input after ':' is pressed."
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 17: before[55..56] -> after[33..33]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [55]: "    /// Status feedback displayed in the help bar."
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 18: before[57..58] -> after[34..34]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [57]: "    /// Maximum line width for text wrapping in the editor."
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 19: before[59..60] -> after[35..35]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [59]: "    /// Tracks line count changes per section to calculate write positions without re-parsing."
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 20: before[61..62] -> after[36..36]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [61]: "    /// Tracks section being moved for visual feedback"
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 21: before[63..64] -> after[37..37]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [63]: "    /// Index of section being moved (if any)"
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 22: before[66..68] -> after[39..40]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [66]: ""
[SYNCDOC DEBUG]     [67]: "/// Determines which UI screen renders and how input is interpreted."
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG]     [39]: "#[syncdoc::omnidoc]"
[SYNCDOC DEBUG] Hunk 23: before[70..71] -> after[42..42]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [70]: "    /// Shows hierarchical section tree with navigation."
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 24: before[72..73] -> after[43..43]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [72]: "    /// Provides vim-like editor for section content."
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 25: before[74..75] -> after[44..44]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [74]: "    /// Captures vim-style command input after ':' keystroke."
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 26: before[77..78] -> after[46..47]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [77]: ""
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG]     [46]: "#[syncdoc::omnidoc]"
[SYNCDOC DEBUG] Hunk 27: before[79..80] -> after[48..48]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [79]: "    /// Initialises application state with parsed sections and determines file mode."
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 28: before[87..88] -> after[55..55]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [87]: ""
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 29: before[89..91] -> after[56..56]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [89]: ""
[SYNCDOC DEBUG]     [90]: "        // Find first navigable node"
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 30: before[92..93] -> after[57..57]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [92]: ""
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 31: before[109..110] -> after[73..73]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [109]: ""
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 32: before[112..115] -> after[75..75]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [112]: ""
[SYNCDOC DEBUG]     [113]: "        // Determine if this is difftastic mode by checking if multiple sections share the same file_path"
[SYNCDOC DEBUG]     [114]: "        // (in markdown mode, each section has a unique file path or sections are from the same file)"
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 33: before[122..123] -> after[82..82]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [122]: ""
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 34: before[124..125] -> after[83..83]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [124]: "            // Single markdown file mode: use section level for tree indentation"
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 35: before[129..130] -> after[87..87]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [129]: "            // Difftastic mode: group sections by file, show files as non-navigable nodes"
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 36: before[132..134] -> after[89..89]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [132]: ""
[SYNCDOC DEBUG]     [133]: "            // Group sections by file and infer file statuses"
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 37: before[139..141] -> after[94..94]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [139]: ""
[SYNCDOC DEBUG]     [140]: "                // Determine file status from hunk headers"
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 38: before[154..156] -> after[107..107]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [154]: ""
[SYNCDOC DEBUG]     [155]: "            // Build tree with file nodes and hunk sections"
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 39: before[158..159] -> after[109..109]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [158]: ""
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 40: before[160..161] -> after[110..110]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [160]: "                // Add file node (non-navigable)"
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 41: before[164..167] -> after[113..114]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [164]: ""
[SYNCDOC DEBUG]     [165]: "                let status_opt = file_status.get(file_path).and_then(|opt| opt.as_deref()); // flatten Option<Option<&str>>"
[SYNCDOC DEBUG]     [166]: ""
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG]     [113]: "                let status_opt = file_status.get(file_path).and_then(|opt| opt.as_deref());"
[SYNCDOC DEBUG] Hunk 42: before[171..172] -> after[118..118]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [171]: ""
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 43: before[173..175] -> after[119..119]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [173]: ""
[SYNCDOC DEBUG]     [174]: "                // Add hunk sections under this file"
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 44: before[182..183] -> after[126..126]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [182]: "            // Multi-file markdown mode: build directory tree with sections nested under files"
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 45: before[184..186] -> after[127..127]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [184]: ""
[SYNCDOC DEBUG]     [185]: "            // Group sections by file"
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 46: before[192..194] -> after[133..133]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [192]: ""
[SYNCDOC DEBUG]     [193]: "            // Build tree with directory structure"
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 47: before[196..197] -> after[135..135]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [196]: ""
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 48: before[199..201] -> after[137..137]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [199]: ""
[SYNCDOC DEBUG]     [200]: "                // Add file node (non-navigable)"
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 49: before[204..205] -> after[140..140]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [204]: ""
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 50: before[206..208] -> after[141..141]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [206]: ""
[SYNCDOC DEBUG]     [207]: "                // Add sections under this file"
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 51: before[215..216] -> after[148..148]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [215]: ""
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 52: before[218..220] -> after[150..150]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [218]: ""
[SYNCDOC DEBUG]     [219]: "    /// Rebuild tree after sections change (e.g., after save)"
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 53: before[222..224] -> after[152..152]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [222]: ""
[SYNCDOC DEBUG]     [223]: "        // Try to maintain current position by finding same section"
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 54: before[234..236] -> after[162..162]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [234]: ""
[SYNCDOC DEBUG]     [235]: "    /// Get the section index for the currently selected node (if it's a section)"
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 55: before[244..246] -> after[170..170]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [244]: ""
[SYNCDOC DEBUG]     [245]: "    /// Get the current section (if on a section node)"
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 56: before[251..252] -> after[175..175]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [251]: ""
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 57: before[254..255] -> after[177..177]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [254]: ""
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 58: before[258..259] -> after[180..180]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [258]: ""
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 59: before[263..264] -> after[184..184]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [263]: ""
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 60: before[268..270] -> after[188..188]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [268]: ""
[SYNCDOC DEBUG]     [269]: "    /// Calculates total lines added before a section to determine correct write position."
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 61: before[275..276] -> after[193..193]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [275]: ""
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 62: before[286..288] -> after[203..203]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [286]: ""
[SYNCDOC DEBUG]     [287]: "    /// Restores previously edited content from a saved edit plan."
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 63: before[302..304] -> after[217..217]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [302]: ""
[SYNCDOC DEBUG]     [303]: "        // Match edits to sections and pre-populate editor content"
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 64: before[312..315] -> after[225..226]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [312]: "                    if section.byte_start < bytes.len() && section.byte_end <= bytes.len() {"
[SYNCDOC DEBUG]     [313]: "                        // Section exists and can be loaded"
[SYNCDOC DEBUG]     [314]: "                    }"
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG]     [225]: "                    if section.byte_start < bytes.len() && section.byte_end <= bytes.len() {}"
[SYNCDOC DEBUG] Hunk 65: before[319..321] -> after[230..230]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [319]: ""
[SYNCDOC DEBUG]     [320]: "    /// Creates a serialisable plan capturing current editor modifications."
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 66: before[324..325] -> after[233..233]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [324]: ""
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 67: before[328..329] -> after[236..236]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [328]: ""
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 68: before[340..341] -> after[247..247]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [340]: ""
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 69: before[343..345] -> after[249..249]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [343]: ""
[SYNCDOC DEBUG]     [344]: "    /// Loads selected section content into the editor buffer."
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 70: before[349..350] -> after[253..253]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [349]: ""
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 71: before[351..353] -> after[254..254]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [351]: ""
[SYNCDOC DEBUG]     [352]: "        // Handle difftastic chunks differently"
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 72: before[355..363] -> after[256..258]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [355]: "                ChunkType::Added => {"
[SYNCDOC DEBUG]     [356]: "                    // Show only RHS for added chunks"
[SYNCDOC DEBUG]     [357]: "                    section.rhs_content.clone().unwrap_or_default()"
[SYNCDOC DEBUG]     [358]: "                }"
[SYNCDOC DEBUG]     [359]: "                ChunkType::Deleted => {"
[SYNCDOC DEBUG]     [360]: "                    // Show LHS with strikethrough or special formatting"
[SYNCDOC DEBUG]     [361]: "                    section.lhs_content.clone().unwrap_or_default()"
[SYNCDOC DEBUG]     [362]: "                }"
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG]     [256]: "                ChunkType::Added => section.rhs_content.clone().unwrap_or_default(),"
[SYNCDOC DEBUG]     [257]: "                ChunkType::Deleted => section.lhs_content.clone().unwrap_or_default(),"
[SYNCDOC DEBUG] Hunk 73: before[364..365] -> after[259..259]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [364]: "                    // Show a unified or side-by-side view"
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 74: before[369..377] -> after[263..268]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [369]: "                ChunkType::Unchanged => {"
[SYNCDOC DEBUG]     [370]: "                    // Show either side (they're the same)"
[SYNCDOC DEBUG]     [371]: "                    section"
[SYNCDOC DEBUG]     [372]: "                        .lhs_content"
[SYNCDOC DEBUG]     [373]: "                        .clone()"
[SYNCDOC DEBUG]     [374]: "                        .or_else(|| section.rhs_content.clone())"
[SYNCDOC DEBUG]     [375]: "                        .unwrap_or_default()"
[SYNCDOC DEBUG]     [376]: "                }"
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG]     [263]: "                ChunkType::Unchanged => section"
[SYNCDOC DEBUG]     [264]: "                    .lhs_content"
[SYNCDOC DEBUG]     [265]: "                    .clone()"
[SYNCDOC DEBUG]     [266]: "                    .or_else(|| section.rhs_content.clone())"
[SYNCDOC DEBUG]     [267]: "                    .unwrap_or_default(),"
[SYNCDOC DEBUG] Hunk 75: before[378..379] -> after[269..269]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [378]: ""
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 76: before[385..386] -> after[275..275]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [385]: ""
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 77: before[387..388] -> after[276..276]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [387]: ""
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 78: before[393..394] -> after[281..281]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [393]: ""
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 79: before[397..398] -> after[284..284]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [397]: ""
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 80: before[400..402] -> after[286..286]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [400]: ""
[SYNCDOC DEBUG]     [401]: "    /// Returns to section list, optionally persisting editor changes."
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 81: before[418..424] -> after[302..302]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [418]: ""
[SYNCDOC DEBUG]     [419]: "    /// Save the current section's content to disk."
[SYNCDOC DEBUG]     [420]: "    ///"
[SYNCDOC DEBUG]     [421]: "    /// # Errors"
[SYNCDOC DEBUG]     [422]: "    ///"
[SYNCDOC DEBUG]     [423]: "    /// Returns an error if writing to disk fails or if file operations cannot complete."
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 82: before[434..435] -> after[312..312]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [434]: ""
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 83: before[438..439] -> after[315..315]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [438]: ""
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 84: before[440..441] -> after[316..316]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [440]: ""
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 85: before[442..443] -> after[317..317]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [442]: ""
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 86: before[446..447] -> after[320..320]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [446]: ""
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 87: before[456..457] -> after[329..329]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [456]: ""
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 88: before[459..461] -> after[331..331]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [459]: ""
[SYNCDOC DEBUG]     [460]: "        // Reload sections"
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 89: before[467..468] -> after[337..337]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [467]: ""
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 90: before[470..471] -> after[339..339]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [470]: ""
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 91: before[477..479] -> after[345..345]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [477]: ""
[SYNCDOC DEBUG]     [478]: "                // Rebuild tree and find the updated section"
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 92: before[480..482] -> after[346..346]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [480]: ""
[SYNCDOC DEBUG]     [481]: "                // Find node with this section index"
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 93: before[494..495] -> after[358..358]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [494]: ""
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 94: before[499..501] -> after[362..362]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [499]: ""
[SYNCDOC DEBUG]     [500]: "    /// Navigate to next navigable node"
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 95: before[506..508] -> after[367..367]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [506]: ""
[SYNCDOC DEBUG]     [507]: "    /// Navigate to previous navigable node"
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 96: before[514..516] -> after[373..373]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [514]: ""
[SYNCDOC DEBUG]     [515]: "    /// Moves to the containing section in the document hierarchy."
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 97: before[520..522] -> after[377..377]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [520]: ""
[SYNCDOC DEBUG]     [521]: "        // Find tree node with this section index"
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 98: before[526..528] -> after[381..381]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [526]: ""
[SYNCDOC DEBUG]     [527]: "    /// Descends to the first child section in the document hierarchy."
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 99: before[532..533] -> after[385..385]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [532]: ""
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 100: before[537..539] -> after[389..389]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [537]: ""
[SYNCDOC DEBUG]     [538]: "    /// Finds the next descendant section at any depth in the hierarchy."
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 101: before[542..544] -> after[392..392]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [542]: ""
[SYNCDOC DEBUG]     [543]: "        // First try immediate children"
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 102: before[550..552] -> after[398..398]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [550]: ""
[SYNCDOC DEBUG]     [551]: "        // Otherwise find next section at deeper level"
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 103: before[560..561] -> after[406..406]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [560]: ""
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 104: before[563..565] -> after[408..408]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [563]: ""
[SYNCDOC DEBUG]     [564]: "    /// Finds the next section at the same hierarchy level."
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 105: before[569..570] -> after[412..412]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [569]: ""
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 106: before[581..582] -> after[423..423]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [581]: ""
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 107: before[584..586] -> after[425..425]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [584]: ""
[SYNCDOC DEBUG]     [585]: "    /// Finds the previous section at the same hierarchy level."
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 108: before[590..591] -> after[429..429]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [590]: ""
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 109: before[602..603] -> after[440..440]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [602]: ""
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 110: before[605..607] -> after[442..442]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [605]: ""
[SYNCDOC DEBUG]     [606]: "    /// Jumps to the first navigable node."
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 111: before[611..613] -> after[446..446]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [611]: ""
[SYNCDOC DEBUG]     [612]: "    /// Jumps to the last navigable node."
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 112: before[617..619] -> after[450..450]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [617]: ""
[SYNCDOC DEBUG]     [618]: "    /// Finds the first section at the same hierarchy level."
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 113: before[623..624] -> after[454..454]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [623]: ""
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 114: before[632..633] -> after[462..462]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [632]: ""
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 115: before[635..637] -> after[464..464]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [635]: ""
[SYNCDOC DEBUG]     [636]: "    /// Finds the last section at the same hierarchy level."
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 116: before[641..642] -> after[468..468]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [641]: ""
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 117: before[650..651] -> after[476..476]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [650]: ""
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 118: before[653..655] -> after[478..478]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [653]: ""
[SYNCDOC DEBUG]     [654]: "    /// Calculates indentation width based on section nesting level."
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 119: before[663..665] -> after[486..486]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [663]: ""
[SYNCDOC DEBUG]     [664]: "    /// Determines available width for text after accounting for indentation."
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 120: before[670..674] -> after[491..491]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [670]: ""
[SYNCDOC DEBUG]     [671]: "    // --- Section List Movement ---"
[SYNCDOC DEBUG]     [672]: ""
[SYNCDOC DEBUG]     [673]: "    /// Start moving the current section"
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 121: before[680..682] -> after[497..497]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [680]: ""
[SYNCDOC DEBUG]     [681]: "    /// Cancel the current move operation"
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 122: before[686..688] -> after[501..501]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [686]: ""
[SYNCDOC DEBUG]     [687]: "    /// Mark section as moved but not yet saved"
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 123: before[691..693] -> after[504..504]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [691]: ""
[SYNCDOC DEBUG]     [692]: "    /// Move section up by one position"
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 124: before[699..701] -> after[510..510]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [699]: ""
[SYNCDOC DEBUG]     [700]: "                // Update current node to follow the moved section"
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 125: before[708..709] -> after[517..517]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [708]: ""
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 126: before[715..717] -> after[523..523]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [715]: ""
[SYNCDOC DEBUG]     [716]: "    /// Move section down by one position"
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 127: before[723..724] -> after[529..529]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [723]: ""
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 128: before[731..732] -> after[536..536]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [731]: ""
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 129: before[738..740] -> after[542..542]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [738]: ""
[SYNCDOC DEBUG]     [739]: "    /// Move section to top of document"
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 130: before[747..748] -> after[549..549]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [747]: ""
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 131: before[755..756] -> after[556..556]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [755]: ""
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 132: before[762..764] -> after[562..562]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [762]: ""
[SYNCDOC DEBUG]     [763]: "    /// Move section to bottom of document"
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 133: before[772..773] -> after[570..570]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [772]: ""
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 134: before[780..781] -> after[577..577]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [780]: ""
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 135: before[787..789] -> after[583..583]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [787]: ""
[SYNCDOC DEBUG]     [788]: "    /// Increase section level (move in - lower level number)"
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 136: before[800..802] -> after[594..594]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [800]: ""
[SYNCDOC DEBUG]     [801]: "    /// Decrease section level (move out - higher level number)"
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 137: before[813..819] -> after[605..605]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [813]: ""
[SYNCDOC DEBUG]     [814]: "    /// Apply section reordering to disk"
[SYNCDOC DEBUG]     [815]: "    ///"
[SYNCDOC DEBUG]     [816]: "    /// # Errors"
[SYNCDOC DEBUG]     [817]: "    ///"
[SYNCDOC DEBUG]     [818]: "    /// Returns an error if writing to disk fails or if file operations cannot complete."
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 138: before[823..825] -> after[609..609]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [823]: ""
[SYNCDOC DEBUG]     [824]: "        // Group sections by file"
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 139: before[832..834] -> after[616..616]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [832]: ""
[SYNCDOC DEBUG]     [833]: "        // Process each file"
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 140: before[837..839] -> after[619..619]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [837]: ""
[SYNCDOC DEBUG]     [838]: "        // Reload sections to get updated positions"
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 141: before[846..847] -> after[626..626]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [846]: ""
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 142: before[851..852] -> after[630..630]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [851]: ""
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 143: before[854..856] -> after[632..632]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [854]: ""
[SYNCDOC DEBUG]     [855]: "    /// Rewrite an entire file with reordered sections"
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 144: before[859..860] -> after[635..635]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [859]: ""
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 145: before[863..864] -> after[638..638]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [863]: ""
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 146: before[874..875] -> after[648..648]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [874]: ""
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 147: before[882..883] -> after[655..655]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [882]: ""
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] Hunk 148: before[887..888] -> after[659..659]
[SYNCDOC DEBUG]   Before snippet:
[SYNCDOC DEBUG]     [887]: ""
[SYNCDOC DEBUG]   After snippet:
[SYNCDOC DEBUG] ==================
[SYNCDOC DEBUG] APPLYING relevant hunk at lines 0..7 (adds 1 lines, removes 7 lines)
[SYNCDOC DEBUG] APPLYING relevant hunk at lines 16..18 (adds 1 lines, removes 2 lines)
[SYNCDOC DEBUG] APPLYING relevant hunk at lines 20..21 (adds 0 lines, removes 1 lines)
[SYNCDOC DEBUG] APPLYING relevant hunk at lines 22..23 (adds 0 lines, removes 1 lines)
[SYNCDOC DEBUG] APPLYING relevant hunk at lines 25..27 (adds 1 lines, removes 2 lines)
[SYNCDOC DEBUG] APPLYING relevant hunk at lines 29..30 (adds 0 lines, removes 1 lines)
[SYNCDOC DEBUG] APPLYING relevant hunk at lines 31..32 (adds 0 lines, removes 1 lines)
[SYNCDOC DEBUG] APPLYING relevant hunk at lines 33..34 (adds 0 lines, removes 1 lines)
[SYNCDOC DEBUG] APPLYING relevant hunk at lines 36..38 (adds 1 lines, removes 2 lines)
[SYNCDOC DEBUG] APPLYING relevant hunk at lines 39..40 (adds 0 lines, removes 1 lines)
[SYNCDOC DEBUG] APPLYING relevant hunk at lines 41..42 (adds 0 lines, removes 1 lines)
[SYNCDOC DEBUG] APPLYING relevant hunk at lines 43..44 (adds 0 lines, removes 1 lines)
[SYNCDOC DEBUG] APPLYING relevant hunk at lines 45..46 (adds 0 lines, removes 1 lines)
[SYNCDOC DEBUG] APPLYING relevant hunk at lines 47..48 (adds 0 lines, removes 1 lines)
[SYNCDOC DEBUG] APPLYING relevant hunk at lines 49..50 (adds 0 lines, removes 1 lines)
[SYNCDOC DEBUG] APPLYING relevant hunk at lines 51..52 (adds 0 lines, removes 1 lines)
[SYNCDOC DEBUG] APPLYING relevant hunk at lines 53..54 (adds 0 lines, removes 1 lines)
[SYNCDOC DEBUG] APPLYING relevant hunk at lines 55..56 (adds 0 lines, removes 1 lines)
[SYNCDOC DEBUG] APPLYING relevant hunk at lines 57..58 (adds 0 lines, removes 1 lines)
[SYNCDOC DEBUG] APPLYING relevant hunk at lines 59..60 (adds 0 lines, removes 1 lines)
[SYNCDOC DEBUG] APPLYING relevant hunk at lines 61..62 (adds 0 lines, removes 1 lines)
[SYNCDOC DEBUG] APPLYING relevant hunk at lines 63..64 (adds 0 lines, removes 1 lines)
[SYNCDOC DEBUG] APPLYING relevant hunk at lines 66..68 (adds 1 lines, removes 2 lines)
[SYNCDOC DEBUG] APPLYING relevant hunk at lines 70..71 (adds 0 lines, removes 1 lines)
[SYNCDOC DEBUG] APPLYING relevant hunk at lines 72..73 (adds 0 lines, removes 1 lines)
[SYNCDOC DEBUG] APPLYING relevant hunk at lines 74..75 (adds 0 lines, removes 1 lines)
[SYNCDOC DEBUG] APPLYING relevant hunk at lines 77..78 (adds 1 lines, removes 1 lines)
[SYNCDOC DEBUG] APPLYING relevant hunk at lines 79..80 (adds 0 lines, removes 1 lines)
[SYNCDOC DEBUG] Skipping irrelevant hunk at lines 87..88
[SYNCDOC DEBUG] Skipping irrelevant hunk at lines 89..91
[SYNCDOC DEBUG] Skipping irrelevant hunk at lines 92..93
[SYNCDOC DEBUG] Skipping irrelevant hunk at lines 109..110
[SYNCDOC DEBUG] Skipping irrelevant hunk at lines 112..115
[SYNCDOC DEBUG] Skipping irrelevant hunk at lines 122..123
[SYNCDOC DEBUG] Skipping irrelevant hunk at lines 124..125
[SYNCDOC DEBUG] Skipping irrelevant hunk at lines 129..130
[SYNCDOC DEBUG] Skipping irrelevant hunk at lines 132..134
[SYNCDOC DEBUG] Skipping irrelevant hunk at lines 139..141
[SYNCDOC DEBUG] Skipping irrelevant hunk at lines 154..156
[SYNCDOC DEBUG] Skipping irrelevant hunk at lines 158..159
[SYNCDOC DEBUG] Skipping irrelevant hunk at lines 160..161
[SYNCDOC DEBUG] Skipping irrelevant hunk at lines 164..167
[SYNCDOC DEBUG] Skipping irrelevant hunk at lines 171..172
[SYNCDOC DEBUG] Skipping irrelevant hunk at lines 173..175
[SYNCDOC DEBUG] Skipping irrelevant hunk at lines 182..183
[SYNCDOC DEBUG] Skipping irrelevant hunk at lines 184..186
[SYNCDOC DEBUG] Skipping irrelevant hunk at lines 192..194
[SYNCDOC DEBUG] Skipping irrelevant hunk at lines 196..197
[SYNCDOC DEBUG] Skipping irrelevant hunk at lines 199..201
[SYNCDOC DEBUG] Skipping irrelevant hunk at lines 204..205
[SYNCDOC DEBUG] Skipping irrelevant hunk at lines 206..208
[SYNCDOC DEBUG] Skipping irrelevant hunk at lines 215..216
[SYNCDOC DEBUG] APPLYING relevant hunk at lines 218..220 (adds 0 lines, removes 2 lines)
[SYNCDOC DEBUG] Skipping irrelevant hunk at lines 222..224
[SYNCDOC DEBUG] APPLYING relevant hunk at lines 234..236 (adds 0 lines, removes 2 lines)
[SYNCDOC DEBUG] APPLYING relevant hunk at lines 244..246 (adds 0 lines, removes 2 lines)
[SYNCDOC DEBUG] Skipping irrelevant hunk at lines 251..252
[SYNCDOC DEBUG] Skipping irrelevant hunk at lines 254..255
[SYNCDOC DEBUG] Skipping irrelevant hunk at lines 258..259
[SYNCDOC DEBUG] Skipping irrelevant hunk at lines 263..264
[SYNCDOC DEBUG] APPLYING relevant hunk at lines 268..270 (adds 0 lines, removes 2 lines)
[SYNCDOC DEBUG] Skipping irrelevant hunk at lines 275..276
[SYNCDOC DEBUG] APPLYING relevant hunk at lines 286..288 (adds 0 lines, removes 2 lines)
[SYNCDOC DEBUG] Skipping irrelevant hunk at lines 302..304
[SYNCDOC DEBUG] Skipping irrelevant hunk at lines 312..315
[SYNCDOC DEBUG] APPLYING relevant hunk at lines 319..321 (adds 0 lines, removes 2 lines)
[SYNCDOC DEBUG] Skipping irrelevant hunk at lines 324..325
[SYNCDOC DEBUG] Skipping irrelevant hunk at lines 328..329
[SYNCDOC DEBUG] Skipping irrelevant hunk at lines 340..341
[SYNCDOC DEBUG] APPLYING relevant hunk at lines 343..345 (adds 0 lines, removes 2 lines)
[SYNCDOC DEBUG] Skipping irrelevant hunk at lines 349..350
[SYNCDOC DEBUG] Skipping irrelevant hunk at lines 351..353
[SYNCDOC DEBUG] Skipping irrelevant hunk at lines 355..363
[SYNCDOC DEBUG] Skipping irrelevant hunk at lines 364..365
[SYNCDOC DEBUG] Skipping irrelevant hunk at lines 369..377
[SYNCDOC DEBUG] Skipping irrelevant hunk at lines 378..379
[SYNCDOC DEBUG] Skipping irrelevant hunk at lines 385..386
[SYNCDOC DEBUG] Skipping irrelevant hunk at lines 387..388
[SYNCDOC DEBUG] Skipping irrelevant hunk at lines 393..394
[SYNCDOC DEBUG] Skipping irrelevant hunk at lines 397..398
[SYNCDOC DEBUG] APPLYING relevant hunk at lines 400..402 (adds 0 lines, removes 2 lines)
[SYNCDOC DEBUG] APPLYING relevant hunk at lines 418..424 (adds 0 lines, removes 6 lines)
[SYNCDOC DEBUG] Skipping irrelevant hunk at lines 434..435
[SYNCDOC DEBUG] Skipping irrelevant hunk at lines 438..439
[SYNCDOC DEBUG] Skipping irrelevant hunk at lines 440..441
[SYNCDOC DEBUG] Skipping irrelevant hunk at lines 442..443
[SYNCDOC DEBUG] Skipping irrelevant hunk at lines 446..447
[SYNCDOC DEBUG] Skipping irrelevant hunk at lines 456..457
[SYNCDOC DEBUG] Skipping irrelevant hunk at lines 459..461
[SYNCDOC DEBUG] Skipping irrelevant hunk at lines 467..468
[SYNCDOC DEBUG] Skipping irrelevant hunk at lines 470..471
[SYNCDOC DEBUG] Skipping irrelevant hunk at lines 477..479
[SYNCDOC DEBUG] Skipping irrelevant hunk at lines 480..482
[SYNCDOC DEBUG] Skipping irrelevant hunk at lines 494..495
[SYNCDOC DEBUG] APPLYING relevant hunk at lines 499..501 (adds 0 lines, removes 2 lines)
[SYNCDOC DEBUG] APPLYING relevant hunk at lines 506..508 (adds 0 lines, removes 2 lines)
[SYNCDOC DEBUG] APPLYING relevant hunk at lines 514..516 (adds 0 lines, removes 2 lines)
[SYNCDOC DEBUG] Skipping irrelevant hunk at lines 520..522
[SYNCDOC DEBUG] APPLYING relevant hunk at lines 526..528 (adds 0 lines, removes 2 lines)
[SYNCDOC DEBUG] Skipping irrelevant hunk at lines 532..533
[SYNCDOC DEBUG] APPLYING relevant hunk at lines 537..539 (adds 0 lines, removes 2 lines)
[SYNCDOC DEBUG] Skipping irrelevant hunk at lines 542..544
[SYNCDOC DEBUG] Skipping irrelevant hunk at lines 550..552
[SYNCDOC DEBUG] Skipping irrelevant hunk at lines 560..561
[SYNCDOC DEBUG] APPLYING relevant hunk at lines 563..565 (adds 0 lines, removes 2 lines)
[SYNCDOC DEBUG] Skipping irrelevant hunk at lines 569..570
[SYNCDOC DEBUG] Skipping irrelevant hunk at lines 581..582
[SYNCDOC DEBUG] APPLYING relevant hunk at lines 584..586 (adds 0 lines, removes 2 lines)
[SYNCDOC DEBUG] Skipping irrelevant hunk at lines 590..591
[SYNCDOC DEBUG] Skipping irrelevant hunk at lines 602..603
[SYNCDOC DEBUG] APPLYING relevant hunk at lines 605..607 (adds 0 lines, removes 2 lines)
[SYNCDOC DEBUG] APPLYING relevant hunk at lines 611..613 (adds 0 lines, removes 2 lines)
[SYNCDOC DEBUG] APPLYING relevant hunk at lines 617..619 (adds 0 lines, removes 2 lines)
[SYNCDOC DEBUG] Skipping irrelevant hunk at lines 623..624
[SYNCDOC DEBUG] Skipping irrelevant hunk at lines 632..633
[SYNCDOC DEBUG] APPLYING relevant hunk at lines 635..637 (adds 0 lines, removes 2 lines)
[SYNCDOC DEBUG] Skipping irrelevant hunk at lines 641..642
[SYNCDOC DEBUG] Skipping irrelevant hunk at lines 650..651
[SYNCDOC DEBUG] APPLYING relevant hunk at lines 653..655 (adds 0 lines, removes 2 lines)
[SYNCDOC DEBUG] APPLYING relevant hunk at lines 663..665 (adds 0 lines, removes 2 lines)
[SYNCDOC DEBUG] APPLYING relevant hunk at lines 670..674 (adds 0 lines, removes 4 lines)
[SYNCDOC DEBUG] APPLYING relevant hunk at lines 680..682 (adds 0 lines, removes 2 lines)
[SYNCDOC DEBUG] APPLYING relevant hunk at lines 686..688 (adds 0 lines, removes 2 lines)
[SYNCDOC DEBUG] APPLYING relevant hunk at lines 691..693 (adds 0 lines, removes 2 lines)
[SYNCDOC DEBUG] Skipping irrelevant hunk at lines 699..701
[SYNCDOC DEBUG] Skipping irrelevant hunk at lines 708..709
[SYNCDOC DEBUG] APPLYING relevant hunk at lines 715..717 (adds 0 lines, removes 2 lines)
[SYNCDOC DEBUG] Skipping irrelevant hunk at lines 723..724
[SYNCDOC DEBUG] Skipping irrelevant hunk at lines 731..732
[SYNCDOC DEBUG] APPLYING relevant hunk at lines 738..740 (adds 0 lines, removes 2 lines)
[SYNCDOC DEBUG] Skipping irrelevant hunk at lines 747..748
[SYNCDOC DEBUG] Skipping irrelevant hunk at lines 755..756
[SYNCDOC DEBUG] APPLYING relevant hunk at lines 762..764 (adds 0 lines, removes 2 lines)
[SYNCDOC DEBUG] Skipping irrelevant hunk at lines 772..773
[SYNCDOC DEBUG] Skipping irrelevant hunk at lines 780..781
[SYNCDOC DEBUG] APPLYING relevant hunk at lines 787..789 (adds 0 lines, removes 2 lines)
[SYNCDOC DEBUG] APPLYING relevant hunk at lines 800..802 (adds 0 lines, removes 2 lines)
[SYNCDOC DEBUG] APPLYING relevant hunk at lines 813..819 (adds 0 lines, removes 6 lines)
[SYNCDOC DEBUG] Skipping irrelevant hunk at lines 823..825
[SYNCDOC DEBUG] Skipping irrelevant hunk at lines 832..834
[SYNCDOC DEBUG] Skipping irrelevant hunk at lines 837..839
[SYNCDOC DEBUG] Skipping irrelevant hunk at lines 846..847
[SYNCDOC DEBUG] Skipping irrelevant hunk at lines 851..852
[SYNCDOC DEBUG] APPLYING relevant hunk at lines 854..856 (adds 0 lines, removes 2 lines)
[SYNCDOC DEBUG] Skipping irrelevant hunk at lines 859..860
[SYNCDOC DEBUG] Skipping irrelevant hunk at lines 863..864
[SYNCDOC DEBUG] Skipping irrelevant hunk at lines 874..875
[SYNCDOC DEBUG] Skipping irrelevant hunk at lines 882..883
[SYNCDOC DEBUG] Skipping irrelevant hunk at lines 887..888
[SYNCDOC DEBUG] Original != Result: true
[SYNCDOC DEBUG] 
=== BOOKEND DEBUG START ===
[SYNCDOC DEBUG] Input code length: 27375
[SYNCDOC DEBUG] 
Line 0: "# ! [doc = syncdoc :: module_doc ! ()]"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "# ! [doc = syncdoc :: module_doc ! ()]"
[SYNCDOC DEBUG]       no_spaces: "#![doc=syncdoc::module_doc!()]"
[SYNCDOC DEBUG]       -> Starts with #!
[SYNCDOC DEBUG]       -> Checking trigger "syncdoc::module_doc!": true
[SYNCDOC DEBUG]       -> Has trigger: true
[SYNCDOC DEBUG]   -> NEEDS BOOKENDING
[SYNCDOC DEBUG]     reformat_line for: "# ! [doc = syncdoc :: module_doc ! ()]"
[SYNCDOC DEBUG]     extract_bookend_content:
[SYNCDOC DEBUG]       trimmed: "# ! [doc = syncdoc :: module_doc ! ()]"
[SYNCDOC DEBUG]       no_spaces: "#![doc=syncdoc::module_doc!()]"
[SYNCDOC DEBUG]       Found #![ at position: 0
[SYNCDOC DEBUG]       Found ] at position: 29
[SYNCDOC DEBUG]       Extracted content: "doc=syncdoc::module_doc!()"
[SYNCDOC DEBUG]     Got content: "doc=syncdoc::module_doc!()"
[SYNCDOC DEBUG]     Created bookended expr: "const _: i32 = { doc=syncdoc::module_doc!() };"
[SYNCDOC DEBUG]     Rustfmt output: "const _: i32 = { doc = syncdoc::module_doc!() };\n"
[SYNCDOC DEBUG]     Stripped bookends: "doc = syncdoc::module_doc!()"
[SYNCDOC DEBUG]     Final result: "#![doc = syncdoc::module_doc!()]"
[SYNCDOC DEBUG]   -> Reformatted to: "#![doc = syncdoc::module_doc!()]"
[SYNCDOC DEBUG] 
Line 1: ""
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ""
[SYNCDOC DEBUG]       no_spaces: ""
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 2: "use crate::edit_plan::{Edit, EditPlan};"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "use crate::edit_plan::{Edit, EditPlan};"
[SYNCDOC DEBUG]       no_spaces: "usecrate::edit_plan::{Edit,EditPlan};"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 3: "use crate::formats::markdown::MarkdownFormat;"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "use crate::formats::markdown::MarkdownFormat;"
[SYNCDOC DEBUG]       no_spaces: "usecrate::formats::markdown::MarkdownFormat;"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 4: "use crate::input;"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "use crate::input;"
[SYNCDOC DEBUG]       no_spaces: "usecrate::input;"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 5: "use crate::section::ChunkType;"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "use crate::section::ChunkType;"
[SYNCDOC DEBUG]       no_spaces: "usecrate::section::ChunkType;"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 6: "use crate::section::{Section, TreeNode};"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "use crate::section::{Section, TreeNode};"
[SYNCDOC DEBUG]       no_spaces: "usecrate::section::{Section,TreeNode};"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 7: "use edtui::{EditorState, Lines};"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "use edtui::{EditorState, Lines};"
[SYNCDOC DEBUG]       no_spaces: "useedtui::{EditorState,Lines};"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 8: "use std::collections::HashMap;"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "use std::collections::HashMap;"
[SYNCDOC DEBUG]       no_spaces: "usestd::collections::HashMap;"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 9: "use std::path::PathBuf;"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "use std::path::PathBuf;"
[SYNCDOC DEBUG]       no_spaces: "usestd::path::PathBuf;"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 10: "use std::{fs, io};"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "use std::{fs, io};"
[SYNCDOC DEBUG]       no_spaces: "usestd::{fs,io};"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 11: ""
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ""
[SYNCDOC DEBUG]       no_spaces: ""
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 12: "#[syncdoc::omnidoc]"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "#[syncdoc::omnidoc]"
[SYNCDOC DEBUG]       no_spaces: "#[syncdoc::omnidoc]"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 13: "#[derive(PartialEq)]"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "#[derive(PartialEq)]"
[SYNCDOC DEBUG]       no_spaces: "#[derive(PartialEq)]"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 14: "pub enum FileMode {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "pub enum FileMode {"
[SYNCDOC DEBUG]       no_spaces: "pubenumFileMode{"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 15: "    Single,"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "Single,"
[SYNCDOC DEBUG]       no_spaces: "Single,"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 16: "    Multi,"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "Multi,"
[SYNCDOC DEBUG]       no_spaces: "Multi,"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 17: "}"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "}"
[SYNCDOC DEBUG]       no_spaces: "}"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 18: ""
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ""
[SYNCDOC DEBUG]       no_spaces: ""
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 19: "#[syncdoc::omnidoc]"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "#[syncdoc::omnidoc]"
[SYNCDOC DEBUG]       no_spaces: "#[syncdoc::omnidoc]"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 20: "#[derive(Clone, PartialEq, Debug)]"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "#[derive(Clone, PartialEq, Debug)]"
[SYNCDOC DEBUG]       no_spaces: "#[derive(Clone,PartialEq,Debug)]"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 21: "pub enum MoveState {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "pub enum MoveState {"
[SYNCDOC DEBUG]       no_spaces: "pubenumMoveState{"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 22: "    None,"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "None,"
[SYNCDOC DEBUG]       no_spaces: "None,"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 23: "    Selected,"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "Selected,"
[SYNCDOC DEBUG]       no_spaces: "Selected,"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 24: "    Moved,"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "Moved,"
[SYNCDOC DEBUG]       no_spaces: "Moved,"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 25: "}"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "}"
[SYNCDOC DEBUG]       no_spaces: "}"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 26: ""
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ""
[SYNCDOC DEBUG]       no_spaces: ""
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 27: "#[syncdoc::omnidoc]"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "#[syncdoc::omnidoc]"
[SYNCDOC DEBUG]       no_spaces: "#[syncdoc::omnidoc]"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 28: "pub struct AppState {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "pub struct AppState {"
[SYNCDOC DEBUG]       no_spaces: "pubstructAppState{"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 29: "    pub sections: Vec<Section>,"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "pub sections: Vec<Section>,"
[SYNCDOC DEBUG]       no_spaces: "pubsections:Vec<Section>,"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 30: "    pub tree_nodes: Vec<TreeNode>,"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "pub tree_nodes: Vec<TreeNode>,"
[SYNCDOC DEBUG]       no_spaces: "pubtree_nodes:Vec<TreeNode>,"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 31: "    pub files: Vec<PathBuf>,"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "pub files: Vec<PathBuf>,"
[SYNCDOC DEBUG]       no_spaces: "pubfiles:Vec<PathBuf>,"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 32: "    pub file_mode: FileMode,"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "pub file_mode: FileMode,"
[SYNCDOC DEBUG]       no_spaces: "pubfile_mode:FileMode,"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 33: "    pub current_view: View,"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "pub current_view: View,"
[SYNCDOC DEBUG]       no_spaces: "pubcurrent_view:View,"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 34: "    pub current_node_index: usize,"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "pub current_node_index: usize,"
[SYNCDOC DEBUG]       no_spaces: "pubcurrent_node_index:usize,"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 35: "    pub editor_state: Option<EditorState>,"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "pub editor_state: Option<EditorState>,"
[SYNCDOC DEBUG]       no_spaces: "pubeditor_state:Option<EditorState>,"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 36: "    pub command_buffer: String,"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "pub command_buffer: String,"
[SYNCDOC DEBUG]       no_spaces: "pubcommand_buffer:String,"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 37: "    pub message: Option<String>,"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "pub message: Option<String>,"
[SYNCDOC DEBUG]       no_spaces: "pubmessage:Option<String>,"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 38: "    pub wrap_width: usize,"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "pub wrap_width: usize,"
[SYNCDOC DEBUG]       no_spaces: "pubwrap_width:usize,"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 39: "    pub file_offsets: HashMap<String, HashMap<i64, usize>>,"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "pub file_offsets: HashMap<String, HashMap<i64, usize>>,"
[SYNCDOC DEBUG]       no_spaces: "pubfile_offsets:HashMap<String,HashMap<i64,usize>>,"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 40: "    pub move_state: MoveState,"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "pub move_state: MoveState,"
[SYNCDOC DEBUG]       no_spaces: "pubmove_state:MoveState,"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 41: "    pub moving_section_index: Option<usize>,"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "pub moving_section_index: Option<usize>,"
[SYNCDOC DEBUG]       no_spaces: "pubmoving_section_index:Option<usize>,"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 42: "}"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "}"
[SYNCDOC DEBUG]       no_spaces: "}"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 43: ""
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ""
[SYNCDOC DEBUG]       no_spaces: ""
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 44: "#[syncdoc::omnidoc]"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "#[syncdoc::omnidoc]"
[SYNCDOC DEBUG]       no_spaces: "#[syncdoc::omnidoc]"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 45: "#[derive(PartialEq)]"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "#[derive(PartialEq)]"
[SYNCDOC DEBUG]       no_spaces: "#[derive(PartialEq)]"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 46: "pub enum View {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "pub enum View {"
[SYNCDOC DEBUG]       no_spaces: "pubenumView{"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 47: "    List,"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "List,"
[SYNCDOC DEBUG]       no_spaces: "List,"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 48: "    Detail,"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "Detail,"
[SYNCDOC DEBUG]       no_spaces: "Detail,"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 49: "    Command,"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "Command,"
[SYNCDOC DEBUG]       no_spaces: "Command,"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 50: "}"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "}"
[SYNCDOC DEBUG]       no_spaces: "}"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 51: ""
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ""
[SYNCDOC DEBUG]       no_spaces: ""
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 52: "#[syncdoc::omnidoc]"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "#[syncdoc::omnidoc]"
[SYNCDOC DEBUG]       no_spaces: "#[syncdoc::omnidoc]"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 53: "impl AppState {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "impl AppState {"
[SYNCDOC DEBUG]       no_spaces: "implAppState{"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 54: "    #[must_use]"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "#[must_use]"
[SYNCDOC DEBUG]       no_spaces: "#[must_use]"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 55: "    pub fn new(files: Vec<PathBuf>, sections: Vec<Section>, wrap_width: usize) -> Self {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "pub fn new(files: Vec<PathBuf>, sections: Vec<Section>, wrap_width: usize) -> Self {"
[SYNCDOC DEBUG]       no_spaces: "pubfnnew(files:Vec<PathBuf>,sections:Vec<Section>,wrap_width:usize)->Self{"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 56: "        let file_mode = if files.len() == 1 {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "let file_mode = if files.len() == 1 {"
[SYNCDOC DEBUG]       no_spaces: "letfile_mode=iffiles.len()==1{"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 57: "            FileMode::Single"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "FileMode::Single"
[SYNCDOC DEBUG]       no_spaces: "FileMode::Single"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 58: "        } else {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "} else {"
[SYNCDOC DEBUG]       no_spaces: "}else{"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 59: "            FileMode::Multi"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "FileMode::Multi"
[SYNCDOC DEBUG]       no_spaces: "FileMode::Multi"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 60: "        };"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "};"
[SYNCDOC DEBUG]       no_spaces: "};"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 61: ""
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ""
[SYNCDOC DEBUG]       no_spaces: ""
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 62: "        let tree_nodes = Self::build_tree(&files, &sections);"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "let tree_nodes = Self::build_tree(&files, &sections);"
[SYNCDOC DEBUG]       no_spaces: "lettree_nodes=Self::build_tree(&files,&sections);"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 63: ""
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ""
[SYNCDOC DEBUG]       no_spaces: ""
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 64: "        // Find first navigable node"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "// Find first navigable node"
[SYNCDOC DEBUG]       no_spaces: "//Findfirstnavigablenode"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 65: "        let initial_index = tree_nodes.iter().position(|n| n.navigable).unwrap_or(0);"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "let initial_index = tree_nodes.iter().position(|n| n.navigable).unwrap_or(0);"
[SYNCDOC DEBUG]       no_spaces: "letinitial_index=tree_nodes.iter().position(|n|n.navigable).unwrap_or(0);"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 66: ""
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ""
[SYNCDOC DEBUG]       no_spaces: ""
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 67: "        Self {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "Self {"
[SYNCDOC DEBUG]       no_spaces: "Self{"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 68: "            sections,"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "sections,"
[SYNCDOC DEBUG]       no_spaces: "sections,"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 69: "            tree_nodes,"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "tree_nodes,"
[SYNCDOC DEBUG]       no_spaces: "tree_nodes,"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 70: "            files,"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "files,"
[SYNCDOC DEBUG]       no_spaces: "files,"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 71: "            file_mode,"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "file_mode,"
[SYNCDOC DEBUG]       no_spaces: "file_mode,"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 72: "            current_view: View::List,"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "current_view: View::List,"
[SYNCDOC DEBUG]       no_spaces: "current_view:View::List,"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 73: "            current_node_index: initial_index,"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "current_node_index: initial_index,"
[SYNCDOC DEBUG]       no_spaces: "current_node_index:initial_index,"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 74: "            editor_state: None,"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "editor_state: None,"
[SYNCDOC DEBUG]       no_spaces: "editor_state:None,"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 75: "            command_buffer: String::new(),"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "command_buffer: String::new(),"
[SYNCDOC DEBUG]       no_spaces: "command_buffer:String::new(),"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 76: "            message: None,"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "message: None,"
[SYNCDOC DEBUG]       no_spaces: "message:None,"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 77: "            wrap_width,"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "wrap_width,"
[SYNCDOC DEBUG]       no_spaces: "wrap_width,"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 78: "            file_offsets: HashMap::new(),"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "file_offsets: HashMap::new(),"
[SYNCDOC DEBUG]       no_spaces: "file_offsets:HashMap::new(),"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 79: "            move_state: MoveState::None,"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "move_state: MoveState::None,"
[SYNCDOC DEBUG]       no_spaces: "move_state:MoveState::None,"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 80: "            moving_section_index: None,"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "moving_section_index: None,"
[SYNCDOC DEBUG]       no_spaces: "moving_section_index:None,"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 81: "        }"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "}"
[SYNCDOC DEBUG]       no_spaces: "}"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 82: "    }"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "}"
[SYNCDOC DEBUG]       no_spaces: "}"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 83: ""
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ""
[SYNCDOC DEBUG]       no_spaces: ""
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 84: "    fn build_tree(files: &[PathBuf], sections: &[Section]) -> Vec<TreeNode> {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "fn build_tree(files: &[PathBuf], sections: &[Section]) -> Vec<TreeNode> {"
[SYNCDOC DEBUG]       no_spaces: "fnbuild_tree(files:&[PathBuf],sections:&[Section])->Vec<TreeNode>{"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 85: "        let mut nodes = Vec::new();"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "let mut nodes = Vec::new();"
[SYNCDOC DEBUG]       no_spaces: "letmutnodes=Vec::new();"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 86: ""
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ""
[SYNCDOC DEBUG]       no_spaces: ""
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 87: "        // Determine if this is difftastic mode by checking if multiple sections share the same file_path"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "// Determine if this is difftastic mode by checking if multiple sections share the same file_path"
[SYNCDOC DEBUG]       no_spaces: "//Determineifthisisdifftasticmodebycheckingifmultiplesectionssharethesamefile_path"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 88: "        // (in markdown mode, each section has a unique file path or sections are from the same file)"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "// (in markdown mode, each section has a unique file path or sections are from the same file)"
[SYNCDOC DEBUG]       no_spaces: "//(inmarkdownmode,eachsectionhasauniquefilepathorsectionsarefromthesamefile)"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 89: "        let mut file_section_counts: HashMap<String, usize> = HashMap::new();"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "let mut file_section_counts: HashMap<String, usize> = HashMap::new();"
[SYNCDOC DEBUG]       no_spaces: "letmutfile_section_counts:HashMap<String,usize>=HashMap::new();"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 90: "        for section in sections {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "for section in sections {"
[SYNCDOC DEBUG]       no_spaces: "forsectioninsections{"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 91: "            *file_section_counts"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "*file_section_counts"
[SYNCDOC DEBUG]       no_spaces: "*file_section_counts"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 92: "                .entry(section.file_path.clone())"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ".entry(section.file_path.clone())"
[SYNCDOC DEBUG]       no_spaces: ".entry(section.file_path.clone())"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 93: "                .or_insert(0) += 1;"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ".or_insert(0) += 1;"
[SYNCDOC DEBUG]       no_spaces: ".or_insert(0)+=1;"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 94: "        }"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "}"
[SYNCDOC DEBUG]       no_spaces: "}"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 95: "        let is_difftastic = file_section_counts.values().any(|&count| count > 1);"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "let is_difftastic = file_section_counts.values().any(|&count| count > 1);"
[SYNCDOC DEBUG]       no_spaces: "letis_difftastic=file_section_counts.values().any(|&count|count>1);"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 96: ""
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ""
[SYNCDOC DEBUG]       no_spaces: ""
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 97: "        if files.len() == 1 && !is_difftastic {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "if files.len() == 1 && !is_difftastic {"
[SYNCDOC DEBUG]       no_spaces: "iffiles.len()==1&&!is_difftastic{"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 98: "            // Single markdown file mode: use section level for tree indentation"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "// Single markdown file mode: use section level for tree indentation"
[SYNCDOC DEBUG]       no_spaces: "//Singlemarkdownfilemode:usesectionlevelfortreeindentation"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 99: "            for (idx, section) in sections.iter().enumerate() {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "for (idx, section) in sections.iter().enumerate() {"
[SYNCDOC DEBUG]       no_spaces: "for(idx,section)insections.iter().enumerate(){"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 100: "                nodes.push(TreeNode::section(section.clone(), section.level, idx));"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "nodes.push(TreeNode::section(section.clone(), section.level, idx));"
[SYNCDOC DEBUG]       no_spaces: "nodes.push(TreeNode::section(section.clone(),section.level,idx));"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 101: "            }"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "}"
[SYNCDOC DEBUG]       no_spaces: "}"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 102: "        } else if is_difftastic {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "} else if is_difftastic {"
[SYNCDOC DEBUG]       no_spaces: "}elseifis_difftastic{"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 103: "            // Difftastic mode: group sections by file, show files as non-navigable nodes"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "// Difftastic mode: group sections by file, show files as non-navigable nodes"
[SYNCDOC DEBUG]       no_spaces: "//Difftasticmode:groupsectionsbyfile,showfilesasnon-navigablenodes"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 104: "            let mut file_tree: HashMap<String, Vec<(usize, &Section)>> = HashMap::new();"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "let mut file_tree: HashMap<String, Vec<(usize, &Section)>> = HashMap::new();"
[SYNCDOC DEBUG]       no_spaces: "letmutfile_tree:HashMap<String,Vec<(usize,&Section)>>=HashMap::new();"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 105: "            let mut file_status: HashMap<String, Option<String>> = HashMap::new();"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "let mut file_status: HashMap<String, Option<String>> = HashMap::new();"
[SYNCDOC DEBUG]       no_spaces: "letmutfile_status:HashMap<String,Option<String>>=HashMap::new();"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 106: ""
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ""
[SYNCDOC DEBUG]       no_spaces: ""
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 107: "            // Group sections by file and infer file statuses"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "// Group sections by file and infer file statuses"
[SYNCDOC DEBUG]       no_spaces: "//Groupsectionsbyfileandinferfilestatuses"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 108: "            for (idx, section) in sections.iter().enumerate() {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "for (idx, section) in sections.iter().enumerate() {"
[SYNCDOC DEBUG]       no_spaces: "for(idx,section)insections.iter().enumerate(){"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 109: "                file_tree"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "file_tree"
[SYNCDOC DEBUG]       no_spaces: "file_tree"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 110: "                    .entry(section.file_path.clone())"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ".entry(section.file_path.clone())"
[SYNCDOC DEBUG]       no_spaces: ".entry(section.file_path.clone())"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 111: "                    .or_default()"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ".or_default()"
[SYNCDOC DEBUG]       no_spaces: ".or_default()"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 112: "                    .push((idx, section));"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ".push((idx, section));"
[SYNCDOC DEBUG]       no_spaces: ".push((idx,section));"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 113: ""
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ""
[SYNCDOC DEBUG]       no_spaces: ""
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 114: "                // Determine file status from hunk headers"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "// Determine file status from hunk headers"
[SYNCDOC DEBUG]       no_spaces: "//Determinefilestatusfromhunkheaders"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 115: "                if !file_status.contains_key(&section.file_path) {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "if !file_status.contains_key(&section.file_path) {"
[SYNCDOC DEBUG]       no_spaces: "if!file_status.contains_key(&section.file_path){"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 116: "                    let status = if section.title.contains(\"@@ -0,0\") {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "let status = if section.title.contains(\"@@ -0,0\") {"
[SYNCDOC DEBUG]       no_spaces: "letstatus=ifsection.title.contains(\"@@-0,0\"){"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 117: "                        Some(\"created\".to_string())"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "Some(\"created\".to_string())"
[SYNCDOC DEBUG]       no_spaces: "Some(\"created\".to_string())"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 118: "                    } else if section.title.contains(\"+0,0 @@\") {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "} else if section.title.contains(\"+0,0 @@\") {"
[SYNCDOC DEBUG]       no_spaces: "}elseifsection.title.contains(\"+0,0@@\"){"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 119: "                        Some(\"deleted\".to_string())"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "Some(\"deleted\".to_string())"
[SYNCDOC DEBUG]       no_spaces: "Some(\"deleted\".to_string())"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 120: "                    } else if section.title.contains(\"@@ \") {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "} else if section.title.contains(\"@@ \") {"
[SYNCDOC DEBUG]       no_spaces: "}elseifsection.title.contains(\"@@\"){"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 121: "                        Some(\"changed\".to_string())"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "Some(\"changed\".to_string())"
[SYNCDOC DEBUG]       no_spaces: "Some(\"changed\".to_string())"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 122: "                    } else {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "} else {"
[SYNCDOC DEBUG]       no_spaces: "}else{"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 123: "                        None"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "None"
[SYNCDOC DEBUG]       no_spaces: "None"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 124: "                    };"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "};"
[SYNCDOC DEBUG]       no_spaces: "};"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 125: "                    file_status.insert(section.file_path.clone(), status);"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "file_status.insert(section.file_path.clone(), status);"
[SYNCDOC DEBUG]       no_spaces: "file_status.insert(section.file_path.clone(),status);"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 126: "                }"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "}"
[SYNCDOC DEBUG]       no_spaces: "}"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 127: "            }"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "}"
[SYNCDOC DEBUG]       no_spaces: "}"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 128: ""
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ""
[SYNCDOC DEBUG]       no_spaces: ""
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 129: "            // Build tree with file nodes and hunk sections"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "// Build tree with file nodes and hunk sections"
[SYNCDOC DEBUG]       no_spaces: "//Buildtreewithfilenodesandhunksections"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 130: "            let mut sorted_files: Vec<_> = file_tree.keys().collect();"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "let mut sorted_files: Vec<_> = file_tree.keys().collect();"
[SYNCDOC DEBUG]       no_spaces: "letmutsorted_files:Vec<_>=file_tree.keys().collect();"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 131: "            sorted_files.sort();"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "sorted_files.sort();"
[SYNCDOC DEBUG]       no_spaces: "sorted_files.sort();"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 132: ""
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ""
[SYNCDOC DEBUG]       no_spaces: ""
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 133: "            for file_path in sorted_files {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "for file_path in sorted_files {"
[SYNCDOC DEBUG]       no_spaces: "forfile_pathinsorted_files{"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 134: "                // Add file node (non-navigable)"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "// Add file node (non-navigable)"
[SYNCDOC DEBUG]       no_spaces: "//Addfilenode(non-navigable)"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 135: "                let file_name = PathBuf::from(file_path)"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "let file_name = PathBuf::from(file_path)"
[SYNCDOC DEBUG]       no_spaces: "letfile_name=PathBuf::from(file_path)"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 136: "                    .file_name()"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ".file_name()"
[SYNCDOC DEBUG]       no_spaces: ".file_name()"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 137: "                    .map_or_else(|| file_path.clone(), |n| n.to_string_lossy().to_string());"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ".map_or_else(|| file_path.clone(), |n| n.to_string_lossy().to_string());"
[SYNCDOC DEBUG]       no_spaces: ".map_or_else(||file_path.clone(),|n|n.to_string_lossy().to_string());"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 138: ""
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ""
[SYNCDOC DEBUG]       no_spaces: ""
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 139: "                let status_opt = file_status.get(file_path).and_then(|opt| opt.as_deref()); // flatten Option<Option<&str>>"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "let status_opt = file_status.get(file_path).and_then(|opt| opt.as_deref()); // flatten Option<Option<&str>>"
[SYNCDOC DEBUG]       no_spaces: "letstatus_opt=file_status.get(file_path).and_then(|opt|opt.as_deref());//flattenOption<Option<&str>>"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 140: ""
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ""
[SYNCDOC DEBUG]       no_spaces: ""
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 141: "                let label = match status_opt {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "let label = match status_opt {"
[SYNCDOC DEBUG]       no_spaces: "letlabel=matchstatus_opt{"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 142: "                    Some(status) => format!(\"{file_name} ({status})\"),"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "Some(status) => format!(\"{file_name} ({status})\"),"
[SYNCDOC DEBUG]       no_spaces: "Some(status)=>format!(\"{file_name}({status})\"),"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 143: "                    None => file_name.clone(),"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "None => file_name.clone(),"
[SYNCDOC DEBUG]       no_spaces: "None=>file_name.clone(),"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 144: "                };"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "};"
[SYNCDOC DEBUG]       no_spaces: "};"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 145: ""
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ""
[SYNCDOC DEBUG]       no_spaces: ""
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 146: "                nodes.push(TreeNode::file(label, file_path.clone(), 0));"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "nodes.push(TreeNode::file(label, file_path.clone(), 0));"
[SYNCDOC DEBUG]       no_spaces: "nodes.push(TreeNode::file(label,file_path.clone(),0));"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 147: ""
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ""
[SYNCDOC DEBUG]       no_spaces: ""
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 148: "                // Add hunk sections under this file"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "// Add hunk sections under this file"
[SYNCDOC DEBUG]       no_spaces: "//Addhunksectionsunderthisfile"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 149: "                if let Some(file_sections) = file_tree.get(file_path) {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "if let Some(file_sections) = file_tree.get(file_path) {"
[SYNCDOC DEBUG]       no_spaces: "ifletSome(file_sections)=file_tree.get(file_path){"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 150: "                    for (idx, section) in file_sections {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "for (idx, section) in file_sections {"
[SYNCDOC DEBUG]       no_spaces: "for(idx,section)infile_sections{"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 151: "                        nodes.push(TreeNode::section((*section).clone(), 1, *idx));"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "nodes.push(TreeNode::section((*section).clone(), 1, *idx));"
[SYNCDOC DEBUG]       no_spaces: "nodes.push(TreeNode::section((*section).clone(),1,*idx));"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 152: "                    }"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "}"
[SYNCDOC DEBUG]       no_spaces: "}"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 153: "                }"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "}"
[SYNCDOC DEBUG]       no_spaces: "}"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 154: "            }"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "}"
[SYNCDOC DEBUG]       no_spaces: "}"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 155: "        } else {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "} else {"
[SYNCDOC DEBUG]       no_spaces: "}else{"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 156: "            // Multi-file markdown mode: build directory tree with sections nested under files"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "// Multi-file markdown mode: build directory tree with sections nested under files"
[SYNCDOC DEBUG]       no_spaces: "//Multi-filemarkdownmode:builddirectorytreewithsectionsnestedunderfiles"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 157: "            let mut file_tree: HashMap<String, Vec<(usize, &Section)>> = HashMap::new();"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "let mut file_tree: HashMap<String, Vec<(usize, &Section)>> = HashMap::new();"
[SYNCDOC DEBUG]       no_spaces: "letmutfile_tree:HashMap<String,Vec<(usize,&Section)>>=HashMap::new();"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 158: ""
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ""
[SYNCDOC DEBUG]       no_spaces: ""
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 159: "            // Group sections by file"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "// Group sections by file"
[SYNCDOC DEBUG]       no_spaces: "//Groupsectionsbyfile"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 160: "            for (idx, section) in sections.iter().enumerate() {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "for (idx, section) in sections.iter().enumerate() {"
[SYNCDOC DEBUG]       no_spaces: "for(idx,section)insections.iter().enumerate(){"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 161: "                file_tree"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "file_tree"
[SYNCDOC DEBUG]       no_spaces: "file_tree"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 162: "                    .entry(section.file_path.clone())"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ".entry(section.file_path.clone())"
[SYNCDOC DEBUG]       no_spaces: ".entry(section.file_path.clone())"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 163: "                    .or_default()"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ".or_default()"
[SYNCDOC DEBUG]       no_spaces: ".or_default()"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 164: "                    .push((idx, section));"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ".push((idx, section));"
[SYNCDOC DEBUG]       no_spaces: ".push((idx,section));"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 165: "            }"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "}"
[SYNCDOC DEBUG]       no_spaces: "}"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 166: ""
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ""
[SYNCDOC DEBUG]       no_spaces: ""
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 167: "            // Build tree with directory structure"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "// Build tree with directory structure"
[SYNCDOC DEBUG]       no_spaces: "//Buildtreewithdirectorystructure"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 168: "            let mut sorted_files: Vec<_> = files.iter().collect();"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "let mut sorted_files: Vec<_> = files.iter().collect();"
[SYNCDOC DEBUG]       no_spaces: "letmutsorted_files:Vec<_>=files.iter().collect();"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 169: "            sorted_files.sort();"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "sorted_files.sort();"
[SYNCDOC DEBUG]       no_spaces: "sorted_files.sort();"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 170: ""
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ""
[SYNCDOC DEBUG]       no_spaces: ""
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 171: "            for file_path in sorted_files {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "for file_path in sorted_files {"
[SYNCDOC DEBUG]       no_spaces: "forfile_pathinsorted_files{"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 172: "                let path_str = file_path.to_string_lossy().to_string();"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "let path_str = file_path.to_string_lossy().to_string();"
[SYNCDOC DEBUG]       no_spaces: "letpath_str=file_path.to_string_lossy().to_string();"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 173: ""
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ""
[SYNCDOC DEBUG]       no_spaces: ""
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 174: "                // Add file node (non-navigable)"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "// Add file node (non-navigable)"
[SYNCDOC DEBUG]       no_spaces: "//Addfilenode(non-navigable)"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 175: "                let file_name = file_path"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "let file_name = file_path"
[SYNCDOC DEBUG]       no_spaces: "letfile_name=file_path"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 176: "                    .file_name()"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ".file_name()"
[SYNCDOC DEBUG]       no_spaces: ".file_name()"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 177: "                    .map_or_else(|| path_str.clone(), |n| n.to_string_lossy().to_string());"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ".map_or_else(|| path_str.clone(), |n| n.to_string_lossy().to_string());"
[SYNCDOC DEBUG]       no_spaces: ".map_or_else(||path_str.clone(),|n|n.to_string_lossy().to_string());"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 178: ""
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ""
[SYNCDOC DEBUG]       no_spaces: ""
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 179: "                nodes.push(TreeNode::file(file_name.clone(), path_str.clone(), 0));"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "nodes.push(TreeNode::file(file_name.clone(), path_str.clone(), 0));"
[SYNCDOC DEBUG]       no_spaces: "nodes.push(TreeNode::file(file_name.clone(),path_str.clone(),0));"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 180: ""
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ""
[SYNCDOC DEBUG]       no_spaces: ""
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 181: "                // Add sections under this file"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "// Add sections under this file"
[SYNCDOC DEBUG]       no_spaces: "//Addsectionsunderthisfile"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 182: "                if let Some(file_sections) = file_tree.get(&path_str) {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "if let Some(file_sections) = file_tree.get(&path_str) {"
[SYNCDOC DEBUG]       no_spaces: "ifletSome(file_sections)=file_tree.get(&path_str){"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 183: "                    for (idx, section) in file_sections {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "for (idx, section) in file_sections {"
[SYNCDOC DEBUG]       no_spaces: "for(idx,section)infile_sections{"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 184: "                        nodes.push(TreeNode::section((*section).clone(), section.level, *idx));"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "nodes.push(TreeNode::section((*section).clone(), section.level, *idx));"
[SYNCDOC DEBUG]       no_spaces: "nodes.push(TreeNode::section((*section).clone(),section.level,*idx));"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 185: "                    }"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "}"
[SYNCDOC DEBUG]       no_spaces: "}"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 186: "                }"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "}"
[SYNCDOC DEBUG]       no_spaces: "}"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 187: "            }"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "}"
[SYNCDOC DEBUG]       no_spaces: "}"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 188: "        }"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "}"
[SYNCDOC DEBUG]       no_spaces: "}"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 189: ""
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ""
[SYNCDOC DEBUG]       no_spaces: ""
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 190: "        nodes"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "nodes"
[SYNCDOC DEBUG]       no_spaces: "nodes"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 191: "    }"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "}"
[SYNCDOC DEBUG]       no_spaces: "}"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 192: ""
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ""
[SYNCDOC DEBUG]       no_spaces: ""
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 193: "    pub fn rebuild_tree(&mut self) {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "pub fn rebuild_tree(&mut self) {"
[SYNCDOC DEBUG]       no_spaces: "pubfnrebuild_tree(&mutself){"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 194: "        self.tree_nodes = Self::build_tree(&self.files, &self.sections);"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "self.tree_nodes = Self::build_tree(&self.files, &self.sections);"
[SYNCDOC DEBUG]       no_spaces: "self.tree_nodes=Self::build_tree(&self.files,&self.sections);"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 195: ""
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ""
[SYNCDOC DEBUG]       no_spaces: ""
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 196: "        // Try to maintain current position by finding same section"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "// Try to maintain current position by finding same section"
[SYNCDOC DEBUG]       no_spaces: "//Trytomaintaincurrentpositionbyfindingsamesection"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 197: "        if let Some(current_section_idx) = self.get_current_section_index() {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "if let Some(current_section_idx) = self.get_current_section_index() {"
[SYNCDOC DEBUG]       no_spaces: "ifletSome(current_section_idx)=self.get_current_section_index(){"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 198: "            if let Some(node_idx) = self"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "if let Some(node_idx) = self"
[SYNCDOC DEBUG]       no_spaces: "ifletSome(node_idx)=self"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 199: "                .tree_nodes"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ".tree_nodes"
[SYNCDOC DEBUG]       no_spaces: ".tree_nodes"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 200: "                .iter()"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ".iter()"
[SYNCDOC DEBUG]       no_spaces: ".iter()"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 201: "                .position(|n| n.section_index == Some(current_section_idx))"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ".position(|n| n.section_index == Some(current_section_idx))"
[SYNCDOC DEBUG]       no_spaces: ".position(|n|n.section_index==Some(current_section_idx))"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 202: "            {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "{"
[SYNCDOC DEBUG]       no_spaces: "{"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 203: "                self.current_node_index = node_idx;"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "self.current_node_index = node_idx;"
[SYNCDOC DEBUG]       no_spaces: "self.current_node_index=node_idx;"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 204: "            }"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "}"
[SYNCDOC DEBUG]       no_spaces: "}"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 205: "        }"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "}"
[SYNCDOC DEBUG]       no_spaces: "}"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 206: "    }"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "}"
[SYNCDOC DEBUG]       no_spaces: "}"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 207: ""
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ""
[SYNCDOC DEBUG]       no_spaces: ""
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 208: "    #[must_use]"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "#[must_use]"
[SYNCDOC DEBUG]       no_spaces: "#[must_use]"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 209: "    pub fn get_current_section_index(&self) -> Option<usize> {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "pub fn get_current_section_index(&self) -> Option<usize> {"
[SYNCDOC DEBUG]       no_spaces: "pubfnget_current_section_index(&self)->Option<usize>{"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 210: "        if self.current_node_index < self.tree_nodes.len() {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "if self.current_node_index < self.tree_nodes.len() {"
[SYNCDOC DEBUG]       no_spaces: "ifself.current_node_index<self.tree_nodes.len(){"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 211: "            self.tree_nodes[self.current_node_index].section_index"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "self.tree_nodes[self.current_node_index].section_index"
[SYNCDOC DEBUG]       no_spaces: "self.tree_nodes[self.current_node_index].section_index"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 212: "        } else {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "} else {"
[SYNCDOC DEBUG]       no_spaces: "}else{"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 213: "            None"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "None"
[SYNCDOC DEBUG]       no_spaces: "None"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 214: "        }"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "}"
[SYNCDOC DEBUG]       no_spaces: "}"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 215: "    }"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "}"
[SYNCDOC DEBUG]       no_spaces: "}"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 216: ""
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ""
[SYNCDOC DEBUG]       no_spaces: ""
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 217: "    #[must_use]"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "#[must_use]"
[SYNCDOC DEBUG]       no_spaces: "#[must_use]"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 218: "    pub fn get_current_section(&self) -> Option<&Section> {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "pub fn get_current_section(&self) -> Option<&Section> {"
[SYNCDOC DEBUG]       no_spaces: "pubfnget_current_section(&self)->Option<&Section>{"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 219: "        self.get_current_section_index()"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "self.get_current_section_index()"
[SYNCDOC DEBUG]       no_spaces: "self.get_current_section_index()"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 220: "            .and_then(|idx| self.sections.get(idx))"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ".and_then(|idx| self.sections.get(idx))"
[SYNCDOC DEBUG]       no_spaces: ".and_then(|idx|self.sections.get(idx))"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 221: "    }"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "}"
[SYNCDOC DEBUG]       no_spaces: "}"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 222: ""
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ""
[SYNCDOC DEBUG]       no_spaces: ""
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 223: "    fn rebuild_file_offsets(&mut self) {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "fn rebuild_file_offsets(&mut self) {"
[SYNCDOC DEBUG]       no_spaces: "fnrebuild_file_offsets(&mutself){"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 224: "        self.file_offsets.clear();"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "self.file_offsets.clear();"
[SYNCDOC DEBUG]       no_spaces: "self.file_offsets.clear();"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 225: ""
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ""
[SYNCDOC DEBUG]       no_spaces: ""
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 226: "        if let Some(section_idx) = self.get_current_section_index() {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "if let Some(section_idx) = self.get_current_section_index() {"
[SYNCDOC DEBUG]       no_spaces: "ifletSome(section_idx)=self.get_current_section_index(){"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 227: "            if let Some(section) = self.sections.get(section_idx) {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "if let Some(section) = self.sections.get(section_idx) {"
[SYNCDOC DEBUG]       no_spaces: "ifletSome(section)=self.sections.get(section_idx){"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 228: "                let lines_added = self.editor_state.as_ref().map_or(0, |es| es.lines.len());"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "let lines_added = self.editor_state.as_ref().map_or(0, |es| es.lines.len());"
[SYNCDOC DEBUG]       no_spaces: "letlines_added=self.editor_state.as_ref().map_or(0,|es|es.lines.len());"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 229: ""
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ""
[SYNCDOC DEBUG]       no_spaces: ""
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 230: "                let file_map = self"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "let file_map = self"
[SYNCDOC DEBUG]       no_spaces: "letfile_map=self"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 231: "                    .file_offsets"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ".file_offsets"
[SYNCDOC DEBUG]       no_spaces: ".file_offsets"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 232: "                    .entry(section.file_path.clone())"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ".entry(section.file_path.clone())"
[SYNCDOC DEBUG]       no_spaces: ".entry(section.file_path.clone())"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 233: "                    .or_default();"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ".or_default();"
[SYNCDOC DEBUG]       no_spaces: ".or_default();"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 234: ""
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ""
[SYNCDOC DEBUG]       no_spaces: ""
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 235: "                file_map.insert(section.line_start, lines_added);"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "file_map.insert(section.line_start, lines_added);"
[SYNCDOC DEBUG]       no_spaces: "file_map.insert(section.line_start,lines_added);"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 236: "            }"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "}"
[SYNCDOC DEBUG]       no_spaces: "}"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 237: "        }"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "}"
[SYNCDOC DEBUG]       no_spaces: "}"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 238: "    }"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "}"
[SYNCDOC DEBUG]       no_spaces: "}"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 239: ""
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ""
[SYNCDOC DEBUG]       no_spaces: ""
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 240: "    #[must_use]"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "#[must_use]"
[SYNCDOC DEBUG]       no_spaces: "#[must_use]"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 241: "    pub fn cumulative_offset(&self, index: usize) -> usize {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "pub fn cumulative_offset(&self, index: usize) -> usize {"
[SYNCDOC DEBUG]       no_spaces: "pubfncumulative_offset(&self,index:usize)->usize{"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 242: "        let section = &self.sections[index];"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "let section = &self.sections[index];"
[SYNCDOC DEBUG]       no_spaces: "letsection=&self.sections[index];"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 243: "        let target_file = &section.file_path;"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "let target_file = &section.file_path;"
[SYNCDOC DEBUG]       no_spaces: "lettarget_file=&section.file_path;"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 244: "        let target_line = section.line_start;"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "let target_line = section.line_start;"
[SYNCDOC DEBUG]       no_spaces: "lettarget_line=section.line_start;"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 245: ""
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ""
[SYNCDOC DEBUG]       no_spaces: ""
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 246: "        if let Some(file_map) = self.file_offsets.get(target_file) {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "if let Some(file_map) = self.file_offsets.get(target_file) {"
[SYNCDOC DEBUG]       no_spaces: "ifletSome(file_map)=self.file_offsets.get(target_file){"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 247: "            file_map"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "file_map"
[SYNCDOC DEBUG]       no_spaces: "file_map"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 248: "                .iter()"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ".iter()"
[SYNCDOC DEBUG]       no_spaces: ".iter()"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 249: "                .filter(|(line, _)| **line < target_line)"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ".filter(|(line, _)| **line < target_line)"
[SYNCDOC DEBUG]       no_spaces: ".filter(|(line,_)|**line<target_line)"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 250: "                .map(|(_, offset)| offset)"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ".map(|(_, offset)| offset)"
[SYNCDOC DEBUG]       no_spaces: ".map(|(_,offset)|offset)"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 251: "                .sum()"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ".sum()"
[SYNCDOC DEBUG]       no_spaces: ".sum()"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 252: "        } else {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "} else {"
[SYNCDOC DEBUG]       no_spaces: "}else{"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 253: "            0"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "0"
[SYNCDOC DEBUG]       no_spaces: "0"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 254: "        }"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "}"
[SYNCDOC DEBUG]       no_spaces: "}"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 255: "    }"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "}"
[SYNCDOC DEBUG]       no_spaces: "}"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 256: ""
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ""
[SYNCDOC DEBUG]       no_spaces: ""
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 257: "    pub fn load_docs(&mut self, plan: EditPlan) {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "pub fn load_docs(&mut self, plan: EditPlan) {"
[SYNCDOC DEBUG]       no_spaces: "pubfnload_docs(&mutself,plan:EditPlan){"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 258: "        let mut doc_map: HashMap<String, Vec<String>> = HashMap::new();"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "let mut doc_map: HashMap<String, Vec<String>> = HashMap::new();"
[SYNCDOC DEBUG]       no_spaces: "letmutdoc_map:HashMap<String,Vec<String>>=HashMap::new();"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 259: "        for edit in plan.edits {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "for edit in plan.edits {"
[SYNCDOC DEBUG]       no_spaces: "foreditinplan.edits{"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 260: "            let key = format!("
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "let key = format!("
[SYNCDOC DEBUG]       no_spaces: "letkey=format!("
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 261: "                \"{}:{}:{}\","
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "\"{}:{}:{}\","
[SYNCDOC DEBUG]       no_spaces: "\"{}:{}:{}\","
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 262: "                edit.file_name, edit.line_start, edit.column_start"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "edit.file_name, edit.line_start, edit.column_start"
[SYNCDOC DEBUG]       no_spaces: "edit.file_name,edit.line_start,edit.column_start"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 263: "            );"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ");"
[SYNCDOC DEBUG]       no_spaces: ");"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 264: "            let lines: Vec<String> = edit"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "let lines: Vec<String> = edit"
[SYNCDOC DEBUG]       no_spaces: "letlines:Vec<String>=edit"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 265: "                .section_content"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ".section_content"
[SYNCDOC DEBUG]       no_spaces: ".section_content"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 266: "                .lines()"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ".lines()"
[SYNCDOC DEBUG]       no_spaces: ".lines()"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 267: "                .map(std::string::ToString::to_string)"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ".map(std::string::ToString::to_string)"
[SYNCDOC DEBUG]       no_spaces: ".map(std::string::ToString::to_string)"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 268: "                .collect();"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ".collect();"
[SYNCDOC DEBUG]       no_spaces: ".collect();"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 269: "            doc_map.insert(key, lines);"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "doc_map.insert(key, lines);"
[SYNCDOC DEBUG]       no_spaces: "doc_map.insert(key,lines);"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 270: "        }"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "}"
[SYNCDOC DEBUG]       no_spaces: "}"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 271: ""
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ""
[SYNCDOC DEBUG]       no_spaces: ""
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 272: "        // Match edits to sections and pre-populate editor content"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "// Match edits to sections and pre-populate editor content"
[SYNCDOC DEBUG]       no_spaces: "//Matcheditstosectionsandpre-populateeditorcontent"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 273: "        for section in &mut self.sections {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "for section in &mut self.sections {"
[SYNCDOC DEBUG]       no_spaces: "forsectionin&mutself.sections{"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 274: "            let key = format!("
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "let key = format!("
[SYNCDOC DEBUG]       no_spaces: "letkey=format!("
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 275: "                \"{}:{}:{}\","
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "\"{}:{}:{}\","
[SYNCDOC DEBUG]       no_spaces: "\"{}:{}:{}\","
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 276: "                section.file_path, section.line_start, section.column_start"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "section.file_path, section.line_start, section.column_start"
[SYNCDOC DEBUG]       no_spaces: "section.file_path,section.line_start,section.column_start"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 277: "            );"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ");"
[SYNCDOC DEBUG]       no_spaces: ");"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 278: "            if doc_map.contains_key(&key) {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "if doc_map.contains_key(&key) {"
[SYNCDOC DEBUG]       no_spaces: "ifdoc_map.contains_key(&key){"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 279: "                if let Ok(content) = fs::read_to_string(&section.file_path) {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "if let Ok(content) = fs::read_to_string(&section.file_path) {"
[SYNCDOC DEBUG]       no_spaces: "ifletOk(content)=fs::read_to_string(&section.file_path){"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 280: "                    let bytes = content.as_bytes();"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "let bytes = content.as_bytes();"
[SYNCDOC DEBUG]       no_spaces: "letbytes=content.as_bytes();"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 281: "                    if section.byte_start < bytes.len() && section.byte_end <= bytes.len() {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "if section.byte_start < bytes.len() && section.byte_end <= bytes.len() {"
[SYNCDOC DEBUG]       no_spaces: "ifsection.byte_start<bytes.len()&&section.byte_end<=bytes.len(){"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 282: "                        // Section exists and can be loaded"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "// Section exists and can be loaded"
[SYNCDOC DEBUG]       no_spaces: "//Sectionexistsandcanbeloaded"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 283: "                    }"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "}"
[SYNCDOC DEBUG]       no_spaces: "}"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 284: "                }"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "}"
[SYNCDOC DEBUG]       no_spaces: "}"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 285: "            }"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "}"
[SYNCDOC DEBUG]       no_spaces: "}"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 286: "        }"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "}"
[SYNCDOC DEBUG]       no_spaces: "}"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 287: "    }"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "}"
[SYNCDOC DEBUG]       no_spaces: "}"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 288: ""
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ""
[SYNCDOC DEBUG]       no_spaces: ""
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 289: "    #[must_use]"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "#[must_use]"
[SYNCDOC DEBUG]       no_spaces: "#[must_use]"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 290: "    pub fn generate_edit_plan(&self) -> EditPlan {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "pub fn generate_edit_plan(&self) -> EditPlan {"
[SYNCDOC DEBUG]       no_spaces: "pubfngenerate_edit_plan(&self)->EditPlan{"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 291: "        let mut edits = Vec::new();"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "let mut edits = Vec::new();"
[SYNCDOC DEBUG]       no_spaces: "letmutedits=Vec::new();"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 292: ""
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ""
[SYNCDOC DEBUG]       no_spaces: ""
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 293: "        for section in &self.sections {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "for section in &self.sections {"
[SYNCDOC DEBUG]       no_spaces: "forsectionin&self.sections{"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 294: "            if let Some(ref doc_lines) = section.section_content {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "if let Some(ref doc_lines) = section.section_content {"
[SYNCDOC DEBUG]       no_spaces: "ifletSome(refdoc_lines)=section.section_content{"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 295: "                let section_content = doc_lines.join(\"\\n\");"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "let section_content = doc_lines.join(\"\\n\");"
[SYNCDOC DEBUG]       no_spaces: "letsection_content=doc_lines.join(\"\\n\");"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 296: ""
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ""
[SYNCDOC DEBUG]       no_spaces: ""
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 297: "                edits.push(Edit {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "edits.push(Edit {"
[SYNCDOC DEBUG]       no_spaces: "edits.push(Edit{"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 298: "                    file_name: section.file_path.clone(),"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "file_name: section.file_path.clone(),"
[SYNCDOC DEBUG]       no_spaces: "file_name:section.file_path.clone(),"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 299: "                    line_start: section.line_start,"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "line_start: section.line_start,"
[SYNCDOC DEBUG]       no_spaces: "line_start:section.line_start,"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 300: "                    line_end: section.line_end,"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "line_end: section.line_end,"
[SYNCDOC DEBUG]       no_spaces: "line_end:section.line_end,"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 301: "                    column_start: section.column_start,"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "column_start: section.column_start,"
[SYNCDOC DEBUG]       no_spaces: "column_start:section.column_start,"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 302: "                    column_end: section.column_end,"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "column_end: section.column_end,"
[SYNCDOC DEBUG]       no_spaces: "column_end:section.column_end,"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 303: "                    section_content,"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "section_content,"
[SYNCDOC DEBUG]       no_spaces: "section_content,"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 304: "                    item_name: section.title.clone(),"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "item_name: section.title.clone(),"
[SYNCDOC DEBUG]       no_spaces: "item_name:section.title.clone(),"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 305: "                });"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "});"
[SYNCDOC DEBUG]       no_spaces: "});"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 306: "            }"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "}"
[SYNCDOC DEBUG]       no_spaces: "}"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 307: "        }"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "}"
[SYNCDOC DEBUG]       no_spaces: "}"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 308: ""
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ""
[SYNCDOC DEBUG]       no_spaces: ""
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 309: "        EditPlan { edits }"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "EditPlan { edits }"
[SYNCDOC DEBUG]       no_spaces: "EditPlan{edits}"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 310: "    }"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "}"
[SYNCDOC DEBUG]       no_spaces: "}"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 311: ""
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ""
[SYNCDOC DEBUG]       no_spaces: ""
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 312: "    pub fn enter_detail_view(&mut self) {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "pub fn enter_detail_view(&mut self) {"
[SYNCDOC DEBUG]       no_spaces: "pubfnenter_detail_view(&mutself){"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 313: "        let Some(section_idx) = self.get_current_section_index() else {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "let Some(section_idx) = self.get_current_section_index() else {"
[SYNCDOC DEBUG]       no_spaces: "letSome(section_idx)=self.get_current_section_index()else{"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 314: "            return;"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "return;"
[SYNCDOC DEBUG]       no_spaces: "return;"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 315: "        };"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "};"
[SYNCDOC DEBUG]       no_spaces: "};"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 316: ""
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ""
[SYNCDOC DEBUG]       no_spaces: ""
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 317: "        let section = &self.sections[section_idx];"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "let section = &self.sections[section_idx];"
[SYNCDOC DEBUG]       no_spaces: "letsection=&self.sections[section_idx];"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 318: ""
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ""
[SYNCDOC DEBUG]       no_spaces: ""
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 319: "        // Handle difftastic chunks differently"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "// Handle difftastic chunks differently"
[SYNCDOC DEBUG]       no_spaces: "//Handledifftasticchunksdifferently"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 320: "        if let Some(chunk_type) = &section.chunk_type {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "if let Some(chunk_type) = &section.chunk_type {"
[SYNCDOC DEBUG]       no_spaces: "ifletSome(chunk_type)=&section.chunk_type{"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 321: "            let content = match chunk_type {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "let content = match chunk_type {"
[SYNCDOC DEBUG]       no_spaces: "letcontent=matchchunk_type{"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 322: "                ChunkType::Added => {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "ChunkType::Added => {"
[SYNCDOC DEBUG]       no_spaces: "ChunkType::Added=>{"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 323: "                    // Show only RHS for added chunks"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "// Show only RHS for added chunks"
[SYNCDOC DEBUG]       no_spaces: "//ShowonlyRHSforaddedchunks"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 324: "                    section.rhs_content.clone().unwrap_or_default()"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "section.rhs_content.clone().unwrap_or_default()"
[SYNCDOC DEBUG]       no_spaces: "section.rhs_content.clone().unwrap_or_default()"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 325: "                }"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "}"
[SYNCDOC DEBUG]       no_spaces: "}"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 326: "                ChunkType::Deleted => {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "ChunkType::Deleted => {"
[SYNCDOC DEBUG]       no_spaces: "ChunkType::Deleted=>{"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 327: "                    // Show LHS with strikethrough or special formatting"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "// Show LHS with strikethrough or special formatting"
[SYNCDOC DEBUG]       no_spaces: "//ShowLHSwithstrikethroughorspecialformatting"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 328: "                    section.lhs_content.clone().unwrap_or_default()"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "section.lhs_content.clone().unwrap_or_default()"
[SYNCDOC DEBUG]       no_spaces: "section.lhs_content.clone().unwrap_or_default()"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 329: "                }"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "}"
[SYNCDOC DEBUG]       no_spaces: "}"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 330: "                ChunkType::Modified => {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "ChunkType::Modified => {"
[SYNCDOC DEBUG]       no_spaces: "ChunkType::Modified=>{"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 331: "                    // Show a unified or side-by-side view"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "// Show a unified or side-by-side view"
[SYNCDOC DEBUG]       no_spaces: "//Showaunifiedorside-by-sideview"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 332: "                    let lhs = section.lhs_content.as_deref().unwrap_or(\"\");"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "let lhs = section.lhs_content.as_deref().unwrap_or(\"\");"
[SYNCDOC DEBUG]       no_spaces: "letlhs=section.lhs_content.as_deref().unwrap_or(\"\");"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 333: "                    let rhs = section.rhs_content.as_deref().unwrap_or(\"\");"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "let rhs = section.rhs_content.as_deref().unwrap_or(\"\");"
[SYNCDOC DEBUG]       no_spaces: "letrhs=section.rhs_content.as_deref().unwrap_or(\"\");"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 334: "                    format!(\"- {lhs}\\n+ {rhs}\")"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "format!(\"- {lhs}\\n+ {rhs}\")"
[SYNCDOC DEBUG]       no_spaces: "format!(\"-{lhs}\\n+{rhs}\")"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 335: "                }"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "}"
[SYNCDOC DEBUG]       no_spaces: "}"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 336: "                ChunkType::Unchanged => {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "ChunkType::Unchanged => {"
[SYNCDOC DEBUG]       no_spaces: "ChunkType::Unchanged=>{"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 337: "                    // Show either side (they're the same)"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "// Show either side (they're the same)"
[SYNCDOC DEBUG]       no_spaces: "//Showeitherside(they'rethesame)"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 338: "                    section"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "section"
[SYNCDOC DEBUG]       no_spaces: "section"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 339: "                        .lhs_content"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ".lhs_content"
[SYNCDOC DEBUG]       no_spaces: ".lhs_content"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 340: "                        .clone()"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ".clone()"
[SYNCDOC DEBUG]       no_spaces: ".clone()"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 341: "                        .or_else(|| section.rhs_content.clone())"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ".or_else(|| section.rhs_content.clone())"
[SYNCDOC DEBUG]       no_spaces: ".or_else(||section.rhs_content.clone())"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 342: "                        .unwrap_or_default()"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ".unwrap_or_default()"
[SYNCDOC DEBUG]       no_spaces: ".unwrap_or_default()"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 343: "                }"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "}"
[SYNCDOC DEBUG]       no_spaces: "}"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 344: "            };"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "};"
[SYNCDOC DEBUG]       no_spaces: "};"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 345: ""
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ""
[SYNCDOC DEBUG]       no_spaces: ""
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 346: "            let lines = Lines::from(content.as_str());"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "let lines = Lines::from(content.as_str());"
[SYNCDOC DEBUG]       no_spaces: "letlines=Lines::from(content.as_str());"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 347: "            self.editor_state = Some(EditorState::new(lines));"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "self.editor_state = Some(EditorState::new(lines));"
[SYNCDOC DEBUG]       no_spaces: "self.editor_state=Some(EditorState::new(lines));"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 348: "        } else if let Ok(content) = fs::read_to_string(&section.file_path) {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "} else if let Ok(content) = fs::read_to_string(&section.file_path) {"
[SYNCDOC DEBUG]       no_spaces: "}elseifletOk(content)=fs::read_to_string(&section.file_path){"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 349: "            let bytes = content.as_bytes();"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "let bytes = content.as_bytes();"
[SYNCDOC DEBUG]       no_spaces: "letbytes=content.as_bytes();"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 350: "            let section_bytes ="
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "let section_bytes ="
[SYNCDOC DEBUG]       no_spaces: "letsection_bytes="
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 351: "                &bytes[section.byte_start.min(bytes.len())..section.byte_end.min(bytes.len())];"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "&bytes[section.byte_start.min(bytes.len())..section.byte_end.min(bytes.len())];"
[SYNCDOC DEBUG]       no_spaces: "&bytes[section.byte_start.min(bytes.len())..section.byte_end.min(bytes.len())];"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 352: ""
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ""
[SYNCDOC DEBUG]       no_spaces: ""
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 353: "            let section_content = String::from_utf8_lossy(section_bytes).to_string();"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "let section_content = String::from_utf8_lossy(section_bytes).to_string();"
[SYNCDOC DEBUG]       no_spaces: "letsection_content=String::from_utf8_lossy(section_bytes).to_string();"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 354: ""
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ""
[SYNCDOC DEBUG]       no_spaces: ""
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 355: "            let lines_text = if section_content.trim().is_empty() {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "let lines_text = if section_content.trim().is_empty() {"
[SYNCDOC DEBUG]       no_spaces: "letlines_text=ifsection_content.trim().is_empty(){"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 356: "                \"\\n\".to_string()"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "\"\\n\".to_string()"
[SYNCDOC DEBUG]       no_spaces: "\"\\n\".to_string()"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 357: "            } else {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "} else {"
[SYNCDOC DEBUG]       no_spaces: "}else{"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 358: "                format!(\"\\n{}\\n\", section_content.trim())"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "format!(\"\\n{}\\n\", section_content.trim())"
[SYNCDOC DEBUG]       no_spaces: "format!(\"\\n{}\\n\",section_content.trim())"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 359: "            };"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "};"
[SYNCDOC DEBUG]       no_spaces: "};"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 360: ""
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ""
[SYNCDOC DEBUG]       no_spaces: ""
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 361: "            let lines = Lines::from(lines_text.as_str());"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "let lines = Lines::from(lines_text.as_str());"
[SYNCDOC DEBUG]       no_spaces: "letlines=Lines::from(lines_text.as_str());"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 362: "            self.editor_state = Some(EditorState::new(lines));"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "self.editor_state = Some(EditorState::new(lines));"
[SYNCDOC DEBUG]       no_spaces: "self.editor_state=Some(EditorState::new(lines));"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 363: "        }"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "}"
[SYNCDOC DEBUG]       no_spaces: "}"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 364: ""
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ""
[SYNCDOC DEBUG]       no_spaces: ""
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 365: "        self.current_view = View::Detail;"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "self.current_view = View::Detail;"
[SYNCDOC DEBUG]       no_spaces: "self.current_view=View::Detail;"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 366: "    }"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "}"
[SYNCDOC DEBUG]       no_spaces: "}"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 367: ""
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ""
[SYNCDOC DEBUG]       no_spaces: ""
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 368: "    pub fn exit_detail_view(&mut self, save: bool) {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "pub fn exit_detail_view(&mut self, save: bool) {"
[SYNCDOC DEBUG]       no_spaces: "pubfnexit_detail_view(&mutself,save:bool){"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 369: "        if save {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "if save {"
[SYNCDOC DEBUG]       no_spaces: "ifsave{"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 370: "            if let Some(ref editor_state) = self.editor_state {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "if let Some(ref editor_state) = self.editor_state {"
[SYNCDOC DEBUG]       no_spaces: "ifletSome(refeditor_state)=self.editor_state{"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 371: "                if let Some(section_idx) = self.get_current_section_index() {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "if let Some(section_idx) = self.get_current_section_index() {"
[SYNCDOC DEBUG]       no_spaces: "ifletSome(section_idx)=self.get_current_section_index(){"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 372: "                    let lines = editor_state"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "let lines = editor_state"
[SYNCDOC DEBUG]       no_spaces: "letlines=editor_state"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 373: "                        .lines"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ".lines"
[SYNCDOC DEBUG]       no_spaces: ".lines"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 374: "                        .iter_row()"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ".iter_row()"
[SYNCDOC DEBUG]       no_spaces: ".iter_row()"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 375: "                        .map(|line| line.iter().collect::<String>())"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ".map(|line| line.iter().collect::<String>())"
[SYNCDOC DEBUG]       no_spaces: ".map(|line|line.iter().collect::<String>())"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 376: "                        .collect();"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ".collect();"
[SYNCDOC DEBUG]       no_spaces: ".collect();"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 377: "                    self.sections[section_idx].section_content = Some(lines);"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "self.sections[section_idx].section_content = Some(lines);"
[SYNCDOC DEBUG]       no_spaces: "self.sections[section_idx].section_content=Some(lines);"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 378: "                }"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "}"
[SYNCDOC DEBUG]       no_spaces: "}"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 379: "            }"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "}"
[SYNCDOC DEBUG]       no_spaces: "}"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 380: "        }"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "}"
[SYNCDOC DEBUG]       no_spaces: "}"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 381: "        self.editor_state = None;"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "self.editor_state = None;"
[SYNCDOC DEBUG]       no_spaces: "self.editor_state=None;"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 382: "        self.current_view = View::List;"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "self.current_view = View::List;"
[SYNCDOC DEBUG]       no_spaces: "self.current_view=View::List;"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 383: "    }"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "}"
[SYNCDOC DEBUG]       no_spaces: "}"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 384: ""
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ""
[SYNCDOC DEBUG]       no_spaces: ""
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 385: "    pub fn save_current(&mut self) -> io::Result<()> {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "pub fn save_current(&mut self) -> io::Result<()> {"
[SYNCDOC DEBUG]       no_spaces: "pubfnsave_current(&mutself)->io::Result<()>{"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 386: "        let editor_lines = if let Some(ref editor_state) = self.editor_state {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "let editor_lines = if let Some(ref editor_state) = self.editor_state {"
[SYNCDOC DEBUG]       no_spaces: "leteditor_lines=ifletSome(refeditor_state)=self.editor_state{"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 387: "            editor_state"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "editor_state"
[SYNCDOC DEBUG]       no_spaces: "editor_state"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 388: "                .lines"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ".lines"
[SYNCDOC DEBUG]       no_spaces: ".lines"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 389: "                .iter_row()"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ".iter_row()"
[SYNCDOC DEBUG]       no_spaces: ".iter_row()"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 390: "                .map(|line| line.iter().collect::<String>())"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ".map(|line| line.iter().collect::<String>())"
[SYNCDOC DEBUG]       no_spaces: ".map(|line|line.iter().collect::<String>())"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 391: "                .collect::<Vec<_>>()"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ".collect::<Vec<_>>()"
[SYNCDOC DEBUG]       no_spaces: ".collect::<Vec<_>>()"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 392: "        } else {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "} else {"
[SYNCDOC DEBUG]       no_spaces: "}else{"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 393: "            return Ok(());"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "return Ok(());"
[SYNCDOC DEBUG]       no_spaces: "returnOk(());"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 394: "        };"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "};"
[SYNCDOC DEBUG]       no_spaces: "};"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 395: ""
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ""
[SYNCDOC DEBUG]       no_spaces: ""
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 396: "        let Some(section_idx) = self.get_current_section_index() else {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "let Some(section_idx) = self.get_current_section_index() else {"
[SYNCDOC DEBUG]       no_spaces: "letSome(section_idx)=self.get_current_section_index()else{"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 397: "            return Ok(());"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "return Ok(());"
[SYNCDOC DEBUG]       no_spaces: "returnOk(());"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 398: "        };"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "};"
[SYNCDOC DEBUG]       no_spaces: "};"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 399: ""
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ""
[SYNCDOC DEBUG]       no_spaces: ""
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 400: "        self.sections[section_idx].section_content = Some(editor_lines.clone());"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "self.sections[section_idx].section_content = Some(editor_lines.clone());"
[SYNCDOC DEBUG]       no_spaces: "self.sections[section_idx].section_content=Some(editor_lines.clone());"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 401: ""
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ""
[SYNCDOC DEBUG]       no_spaces: ""
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 402: "        let section = &self.sections[section_idx];"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "let section = &self.sections[section_idx];"
[SYNCDOC DEBUG]       no_spaces: "letsection=&self.sections[section_idx];"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 403: ""
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ""
[SYNCDOC DEBUG]       no_spaces: ""
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 404: "        let raw_content = editor_lines.join(\"\\n\");"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "let raw_content = editor_lines.join(\"\\n\");"
[SYNCDOC DEBUG]       no_spaces: "letraw_content=editor_lines.join(\"\\n\");"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 405: "        let trimmed_content = raw_content.trim();"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "let trimmed_content = raw_content.trim();"
[SYNCDOC DEBUG]       no_spaces: "lettrimmed_content=raw_content.trim();"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 406: "        let padded_content = format!(\"\\n{trimmed_content}\\n\\n\");"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "let padded_content = format!(\"\\n{trimmed_content}\\n\\n\");"
[SYNCDOC DEBUG]       no_spaces: "letpadded_content=format!(\"\\n{trimmed_content}\\n\\n\");"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 407: ""
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ""
[SYNCDOC DEBUG]       no_spaces: ""
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 408: "        let edit = Edit {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "let edit = Edit {"
[SYNCDOC DEBUG]       no_spaces: "letedit=Edit{"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 409: "            file_name: section.file_path.clone(),"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "file_name: section.file_path.clone(),"
[SYNCDOC DEBUG]       no_spaces: "file_name:section.file_path.clone(),"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 410: "            line_start: section.line_start,"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "line_start: section.line_start,"
[SYNCDOC DEBUG]       no_spaces: "line_start:section.line_start,"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 411: "            line_end: section.line_end,"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "line_end: section.line_end,"
[SYNCDOC DEBUG]       no_spaces: "line_end:section.line_end,"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 412: "            column_start: section.column_start,"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "column_start: section.column_start,"
[SYNCDOC DEBUG]       no_spaces: "column_start:section.column_start,"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 413: "            column_end: section.column_end,"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "column_end: section.column_end,"
[SYNCDOC DEBUG]       no_spaces: "column_end:section.column_end,"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 414: "            section_content: padded_content,"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "section_content: padded_content,"
[SYNCDOC DEBUG]       no_spaces: "section_content:padded_content,"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 415: "            item_name: section.title.clone(),"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "item_name: section.title.clone(),"
[SYNCDOC DEBUG]       no_spaces: "item_name:section.title.clone(),"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 416: "        };"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "};"
[SYNCDOC DEBUG]       no_spaces: "};"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 417: ""
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ""
[SYNCDOC DEBUG]       no_spaces: ""
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 418: "        let mut plan = EditPlan { edits: vec![edit] };"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "let mut plan = EditPlan { edits: vec![edit] };"
[SYNCDOC DEBUG]       no_spaces: "letmutplan=EditPlan{edits:vec![edit]};"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 419: "        plan.apply()?;"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "plan.apply()?;"
[SYNCDOC DEBUG]       no_spaces: "plan.apply()?;"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 420: ""
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ""
[SYNCDOC DEBUG]       no_spaces: ""
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 421: "        // Reload sections"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "// Reload sections"
[SYNCDOC DEBUG]       no_spaces: "//Reloadsections"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 422: "        let format = MarkdownFormat;"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "let format = MarkdownFormat;"
[SYNCDOC DEBUG]       no_spaces: "letformat=MarkdownFormat;"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 423: "        if let Ok(new_sections) ="
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "if let Ok(new_sections) ="
[SYNCDOC DEBUG]       no_spaces: "ifletOk(new_sections)="
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 424: "            input::extract_sections(&PathBuf::from(&section.file_path), &format)"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "input::extract_sections(&PathBuf::from(&section.file_path), &format)"
[SYNCDOC DEBUG]       no_spaces: "input::extract_sections(&PathBuf::from(&section.file_path),&format)"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 425: "        {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "{"
[SYNCDOC DEBUG]       no_spaces: "{"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 426: "            let target_title = section.title.clone();"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "let target_title = section.title.clone();"
[SYNCDOC DEBUG]       no_spaces: "lettarget_title=section.title.clone();"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 427: "            let target_level = section.level;"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "let target_level = section.level;"
[SYNCDOC DEBUG]       no_spaces: "lettarget_level=section.level;"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 428: ""
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ""
[SYNCDOC DEBUG]       no_spaces: ""
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 429: "            let file_path = section.file_path.clone();"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "let file_path = section.file_path.clone();"
[SYNCDOC DEBUG]       no_spaces: "letfile_path=section.file_path.clone();"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 430: "            self.sections.retain(|s| s.file_path != file_path);"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "self.sections.retain(|s| s.file_path != file_path);"
[SYNCDOC DEBUG]       no_spaces: "self.sections.retain(|s|s.file_path!=file_path);"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 431: ""
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ""
[SYNCDOC DEBUG]       no_spaces: ""
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 432: "            if let Some(local_index) = new_sections"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "if let Some(local_index) = new_sections"
[SYNCDOC DEBUG]       no_spaces: "ifletSome(local_index)=new_sections"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 433: "                .iter()"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ".iter()"
[SYNCDOC DEBUG]       no_spaces: ".iter()"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 434: "                .position(|s| s.title == target_title && s.level == target_level)"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ".position(|s| s.title == target_title && s.level == target_level)"
[SYNCDOC DEBUG]       no_spaces: ".position(|s|s.title==target_title&&s.level==target_level)"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 435: "            {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "{"
[SYNCDOC DEBUG]       no_spaces: "{"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 436: "                let new_global_index = self.sections.len() + local_index;"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "let new_global_index = self.sections.len() + local_index;"
[SYNCDOC DEBUG]       no_spaces: "letnew_global_index=self.sections.len()+local_index;"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 437: "                self.sections.extend(new_sections);"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "self.sections.extend(new_sections);"
[SYNCDOC DEBUG]       no_spaces: "self.sections.extend(new_sections);"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 438: ""
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ""
[SYNCDOC DEBUG]       no_spaces: ""
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 439: "                // Rebuild tree and find the updated section"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "// Rebuild tree and find the updated section"
[SYNCDOC DEBUG]       no_spaces: "//Rebuildtreeandfindtheupdatedsection"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 440: "                self.rebuild_tree();"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "self.rebuild_tree();"
[SYNCDOC DEBUG]       no_spaces: "self.rebuild_tree();"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 441: ""
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ""
[SYNCDOC DEBUG]       no_spaces: ""
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 442: "                // Find node with this section index"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "// Find node with this section index"
[SYNCDOC DEBUG]       no_spaces: "//Findnodewiththissectionindex"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 443: "                if let Some(node_idx) = self"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "if let Some(node_idx) = self"
[SYNCDOC DEBUG]       no_spaces: "ifletSome(node_idx)=self"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 444: "                    .tree_nodes"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ".tree_nodes"
[SYNCDOC DEBUG]       no_spaces: ".tree_nodes"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 445: "                    .iter()"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ".iter()"
[SYNCDOC DEBUG]       no_spaces: ".iter()"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 446: "                    .position(|n| n.section_index == Some(new_global_index))"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ".position(|n| n.section_index == Some(new_global_index))"
[SYNCDOC DEBUG]       no_spaces: ".position(|n|n.section_index==Some(new_global_index))"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 447: "                {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "{"
[SYNCDOC DEBUG]       no_spaces: "{"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 448: "                    self.current_node_index = node_idx;"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "self.current_node_index = node_idx;"
[SYNCDOC DEBUG]       no_spaces: "self.current_node_index=node_idx;"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 449: "                }"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "}"
[SYNCDOC DEBUG]       no_spaces: "}"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 450: "            } else {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "} else {"
[SYNCDOC DEBUG]       no_spaces: "}else{"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 451: "                self.sections.extend(new_sections);"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "self.sections.extend(new_sections);"
[SYNCDOC DEBUG]       no_spaces: "self.sections.extend(new_sections);"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 452: "                self.rebuild_tree();"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "self.rebuild_tree();"
[SYNCDOC DEBUG]       no_spaces: "self.rebuild_tree();"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 453: "            }"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "}"
[SYNCDOC DEBUG]       no_spaces: "}"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 454: "        }"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "}"
[SYNCDOC DEBUG]       no_spaces: "}"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 455: ""
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ""
[SYNCDOC DEBUG]       no_spaces: ""
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 456: "        self.rebuild_file_offsets();"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "self.rebuild_file_offsets();"
[SYNCDOC DEBUG]       no_spaces: "self.rebuild_file_offsets();"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 457: "        self.message = Some(\"Saved\".to_string());"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "self.message = Some(\"Saved\".to_string());"
[SYNCDOC DEBUG]       no_spaces: "self.message=Some(\"Saved\".to_string());"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 458: "        Ok(())"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "Ok(())"
[SYNCDOC DEBUG]       no_spaces: "Ok(())"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 459: "    }"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "}"
[SYNCDOC DEBUG]       no_spaces: "}"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 460: ""
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ""
[SYNCDOC DEBUG]       no_spaces: ""
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 461: "    #[must_use]"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "#[must_use]"
[SYNCDOC DEBUG]       no_spaces: "#[must_use]"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 462: "    pub fn find_next_node(&self) -> Option<usize> {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "pub fn find_next_node(&self) -> Option<usize> {"
[SYNCDOC DEBUG]       no_spaces: "pubfnfind_next_node(&self)->Option<usize>{"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 463: "        ((self.current_node_index + 1)..self.tree_nodes.len())"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "((self.current_node_index + 1)..self.tree_nodes.len())"
[SYNCDOC DEBUG]       no_spaces: "((self.current_node_index+1)..self.tree_nodes.len())"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 464: "            .find(|&i| self.tree_nodes[i].navigable)"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ".find(|&i| self.tree_nodes[i].navigable)"
[SYNCDOC DEBUG]       no_spaces: ".find(|&i|self.tree_nodes[i].navigable)"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 465: "    }"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "}"
[SYNCDOC DEBUG]       no_spaces: "}"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 466: ""
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ""
[SYNCDOC DEBUG]       no_spaces: ""
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 467: "    #[must_use]"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "#[must_use]"
[SYNCDOC DEBUG]       no_spaces: "#[must_use]"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 468: "    pub fn find_prev_node(&self) -> Option<usize> {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "pub fn find_prev_node(&self) -> Option<usize> {"
[SYNCDOC DEBUG]       no_spaces: "pubfnfind_prev_node(&self)->Option<usize>{"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 469: "        (0..self.current_node_index)"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "(0..self.current_node_index)"
[SYNCDOC DEBUG]       no_spaces: "(0..self.current_node_index)"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 470: "            .rev()"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ".rev()"
[SYNCDOC DEBUG]       no_spaces: ".rev()"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 471: "            .find(|&i| self.tree_nodes[i].navigable)"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ".find(|&i| self.tree_nodes[i].navigable)"
[SYNCDOC DEBUG]       no_spaces: ".find(|&i|self.tree_nodes[i].navigable)"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 472: "    }"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "}"
[SYNCDOC DEBUG]       no_spaces: "}"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 473: ""
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ""
[SYNCDOC DEBUG]       no_spaces: ""
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 474: "    #[must_use]"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "#[must_use]"
[SYNCDOC DEBUG]       no_spaces: "#[must_use]"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 475: "    pub fn navigate_to_parent(&self) -> Option<usize> {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "pub fn navigate_to_parent(&self) -> Option<usize> {"
[SYNCDOC DEBUG]       no_spaces: "pubfnnavigate_to_parent(&self)->Option<usize>{"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 476: "        let section_idx = self.get_current_section_index()?;"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "let section_idx = self.get_current_section_index()?;"
[SYNCDOC DEBUG]       no_spaces: "letsection_idx=self.get_current_section_index()?;"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 477: "        let parent_section_idx = self.sections[section_idx].parent_index?;"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "let parent_section_idx = self.sections[section_idx].parent_index?;"
[SYNCDOC DEBUG]       no_spaces: "letparent_section_idx=self.sections[section_idx].parent_index?;"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 478: ""
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ""
[SYNCDOC DEBUG]       no_spaces: ""
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 479: "        // Find tree node with this section index"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "// Find tree node with this section index"
[SYNCDOC DEBUG]       no_spaces: "//Findtreenodewiththissectionindex"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 480: "        self.tree_nodes"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "self.tree_nodes"
[SYNCDOC DEBUG]       no_spaces: "self.tree_nodes"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 481: "            .iter()"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ".iter()"
[SYNCDOC DEBUG]       no_spaces: ".iter()"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 482: "            .position(|n| n.section_index == Some(parent_section_idx))"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ".position(|n| n.section_index == Some(parent_section_idx))"
[SYNCDOC DEBUG]       no_spaces: ".position(|n|n.section_index==Some(parent_section_idx))"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 483: "    }"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "}"
[SYNCDOC DEBUG]       no_spaces: "}"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 484: ""
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ""
[SYNCDOC DEBUG]       no_spaces: ""
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 485: "    #[must_use]"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "#[must_use]"
[SYNCDOC DEBUG]       no_spaces: "#[must_use]"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 486: "    pub fn navigate_to_first_child(&self) -> Option<usize> {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "pub fn navigate_to_first_child(&self) -> Option<usize> {"
[SYNCDOC DEBUG]       no_spaces: "pubfnnavigate_to_first_child(&self)->Option<usize>{"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 487: "        let section_idx = self.get_current_section_index()?;"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "let section_idx = self.get_current_section_index()?;"
[SYNCDOC DEBUG]       no_spaces: "letsection_idx=self.get_current_section_index()?;"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 488: "        let first_child_idx = self.sections[section_idx].children_indices.first()?;"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "let first_child_idx = self.sections[section_idx].children_indices.first()?;"
[SYNCDOC DEBUG]       no_spaces: "letfirst_child_idx=self.sections[section_idx].children_indices.first()?;"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 489: ""
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ""
[SYNCDOC DEBUG]       no_spaces: ""
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 490: "        self.tree_nodes"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "self.tree_nodes"
[SYNCDOC DEBUG]       no_spaces: "self.tree_nodes"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 491: "            .iter()"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ".iter()"
[SYNCDOC DEBUG]       no_spaces: ".iter()"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 492: "            .position(|n| n.section_index == Some(*first_child_idx))"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ".position(|n| n.section_index == Some(*first_child_idx))"
[SYNCDOC DEBUG]       no_spaces: ".position(|n|n.section_index==Some(*first_child_idx))"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 493: "    }"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "}"
[SYNCDOC DEBUG]       no_spaces: "}"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 494: ""
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ""
[SYNCDOC DEBUG]       no_spaces: ""
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 495: "    #[must_use]"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "#[must_use]"
[SYNCDOC DEBUG]       no_spaces: "#[must_use]"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 496: "    pub fn navigate_to_next_descendant(&self) -> Option<usize> {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "pub fn navigate_to_next_descendant(&self) -> Option<usize> {"
[SYNCDOC DEBUG]       no_spaces: "pubfnnavigate_to_next_descendant(&self)->Option<usize>{"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 497: "        let section_idx = self.get_current_section_index()?;"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "let section_idx = self.get_current_section_index()?;"
[SYNCDOC DEBUG]       no_spaces: "letsection_idx=self.get_current_section_index()?;"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 498: ""
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ""
[SYNCDOC DEBUG]       no_spaces: ""
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 499: "        // First try immediate children"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "// First try immediate children"
[SYNCDOC DEBUG]       no_spaces: "//Firsttryimmediatechildren"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 500: "        if let Some(first_child) = self.sections[section_idx].children_indices.first() {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "if let Some(first_child) = self.sections[section_idx].children_indices.first() {"
[SYNCDOC DEBUG]       no_spaces: "ifletSome(first_child)=self.sections[section_idx].children_indices.first(){"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 501: "            return self"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "return self"
[SYNCDOC DEBUG]       no_spaces: "returnself"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 502: "                .tree_nodes"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ".tree_nodes"
[SYNCDOC DEBUG]       no_spaces: ".tree_nodes"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 503: "                .iter()"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ".iter()"
[SYNCDOC DEBUG]       no_spaces: ".iter()"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 504: "                .position(|n| n.section_index == Some(*first_child));"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ".position(|n| n.section_index == Some(*first_child));"
[SYNCDOC DEBUG]       no_spaces: ".position(|n|n.section_index==Some(*first_child));"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 505: "        }"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "}"
[SYNCDOC DEBUG]       no_spaces: "}"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 506: ""
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ""
[SYNCDOC DEBUG]       no_spaces: ""
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 507: "        // Otherwise find next section at deeper level"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "// Otherwise find next section at deeper level"
[SYNCDOC DEBUG]       no_spaces: "//Otherwisefindnextsectionatdeeperlevel"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 508: "        for i in (section_idx + 1)..self.sections.len() {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "for i in (section_idx + 1)..self.sections.len() {"
[SYNCDOC DEBUG]       no_spaces: "foriin(section_idx+1)..self.sections.len(){"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 509: "            if self.sections[i].level > self.sections[section_idx].level {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "if self.sections[i].level > self.sections[section_idx].level {"
[SYNCDOC DEBUG]       no_spaces: "ifself.sections[i].level>self.sections[section_idx].level{"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 510: "                return self"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "return self"
[SYNCDOC DEBUG]       no_spaces: "returnself"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 511: "                    .tree_nodes"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ".tree_nodes"
[SYNCDOC DEBUG]       no_spaces: ".tree_nodes"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 512: "                    .iter()"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ".iter()"
[SYNCDOC DEBUG]       no_spaces: ".iter()"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 513: "                    .position(|n| n.section_index == Some(i));"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ".position(|n| n.section_index == Some(i));"
[SYNCDOC DEBUG]       no_spaces: ".position(|n|n.section_index==Some(i));"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 514: "            }"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "}"
[SYNCDOC DEBUG]       no_spaces: "}"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 515: "        }"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "}"
[SYNCDOC DEBUG]       no_spaces: "}"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 516: ""
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ""
[SYNCDOC DEBUG]       no_spaces: ""
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 517: "        None"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "None"
[SYNCDOC DEBUG]       no_spaces: "None"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 518: "    }"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "}"
[SYNCDOC DEBUG]       no_spaces: "}"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 519: ""
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ""
[SYNCDOC DEBUG]       no_spaces: ""
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 520: "    #[must_use]"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "#[must_use]"
[SYNCDOC DEBUG]       no_spaces: "#[must_use]"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 521: "    pub fn navigate_to_next_sibling(&self) -> Option<usize> {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "pub fn navigate_to_next_sibling(&self) -> Option<usize> {"
[SYNCDOC DEBUG]       no_spaces: "pubfnnavigate_to_next_sibling(&self)->Option<usize>{"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 522: "        let section_idx = self.get_current_section_index()?;"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "let section_idx = self.get_current_section_index()?;"
[SYNCDOC DEBUG]       no_spaces: "letsection_idx=self.get_current_section_index()?;"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 523: "        let current_level = self.sections[section_idx].level;"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "let current_level = self.sections[section_idx].level;"
[SYNCDOC DEBUG]       no_spaces: "letcurrent_level=self.sections[section_idx].level;"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 524: ""
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ""
[SYNCDOC DEBUG]       no_spaces: ""
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 525: "        for i in (section_idx + 1)..self.sections.len() {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "for i in (section_idx + 1)..self.sections.len() {"
[SYNCDOC DEBUG]       no_spaces: "foriin(section_idx+1)..self.sections.len(){"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 526: "            if self.sections[i].level == current_level {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "if self.sections[i].level == current_level {"
[SYNCDOC DEBUG]       no_spaces: "ifself.sections[i].level==current_level{"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 527: "                return self"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "return self"
[SYNCDOC DEBUG]       no_spaces: "returnself"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 528: "                    .tree_nodes"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ".tree_nodes"
[SYNCDOC DEBUG]       no_spaces: ".tree_nodes"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 529: "                    .iter()"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ".iter()"
[SYNCDOC DEBUG]       no_spaces: ".iter()"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 530: "                    .position(|n| n.section_index == Some(i));"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ".position(|n| n.section_index == Some(i));"
[SYNCDOC DEBUG]       no_spaces: ".position(|n|n.section_index==Some(i));"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 531: "            }"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "}"
[SYNCDOC DEBUG]       no_spaces: "}"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 532: "            if self.sections[i].level < current_level {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "if self.sections[i].level < current_level {"
[SYNCDOC DEBUG]       no_spaces: "ifself.sections[i].level<current_level{"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 533: "                break;"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "break;"
[SYNCDOC DEBUG]       no_spaces: "break;"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 534: "            }"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "}"
[SYNCDOC DEBUG]       no_spaces: "}"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 535: "        }"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "}"
[SYNCDOC DEBUG]       no_spaces: "}"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 536: ""
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ""
[SYNCDOC DEBUG]       no_spaces: ""
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 537: "        None"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "None"
[SYNCDOC DEBUG]       no_spaces: "None"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 538: "    }"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "}"
[SYNCDOC DEBUG]       no_spaces: "}"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 539: ""
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ""
[SYNCDOC DEBUG]       no_spaces: ""
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 540: "    #[must_use]"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "#[must_use]"
[SYNCDOC DEBUG]       no_spaces: "#[must_use]"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 541: "    pub fn navigate_to_prev_sibling(&self) -> Option<usize> {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "pub fn navigate_to_prev_sibling(&self) -> Option<usize> {"
[SYNCDOC DEBUG]       no_spaces: "pubfnnavigate_to_prev_sibling(&self)->Option<usize>{"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 542: "        let section_idx = self.get_current_section_index()?;"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "let section_idx = self.get_current_section_index()?;"
[SYNCDOC DEBUG]       no_spaces: "letsection_idx=self.get_current_section_index()?;"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 543: "        let current_level = self.sections[section_idx].level;"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "let current_level = self.sections[section_idx].level;"
[SYNCDOC DEBUG]       no_spaces: "letcurrent_level=self.sections[section_idx].level;"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 544: ""
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ""
[SYNCDOC DEBUG]       no_spaces: ""
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 545: "        for i in (0..section_idx).rev() {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "for i in (0..section_idx).rev() {"
[SYNCDOC DEBUG]       no_spaces: "foriin(0..section_idx).rev(){"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 546: "            if self.sections[i].level == current_level {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "if self.sections[i].level == current_level {"
[SYNCDOC DEBUG]       no_spaces: "ifself.sections[i].level==current_level{"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 547: "                return self"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "return self"
[SYNCDOC DEBUG]       no_spaces: "returnself"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 548: "                    .tree_nodes"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ".tree_nodes"
[SYNCDOC DEBUG]       no_spaces: ".tree_nodes"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 549: "                    .iter()"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ".iter()"
[SYNCDOC DEBUG]       no_spaces: ".iter()"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 550: "                    .position(|n| n.section_index == Some(i));"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ".position(|n| n.section_index == Some(i));"
[SYNCDOC DEBUG]       no_spaces: ".position(|n|n.section_index==Some(i));"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 551: "            }"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "}"
[SYNCDOC DEBUG]       no_spaces: "}"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 552: "            if self.sections[i].level < current_level {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "if self.sections[i].level < current_level {"
[SYNCDOC DEBUG]       no_spaces: "ifself.sections[i].level<current_level{"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 553: "                break;"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "break;"
[SYNCDOC DEBUG]       no_spaces: "break;"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 554: "            }"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "}"
[SYNCDOC DEBUG]       no_spaces: "}"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 555: "        }"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "}"
[SYNCDOC DEBUG]       no_spaces: "}"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 556: ""
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ""
[SYNCDOC DEBUG]       no_spaces: ""
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 557: "        None"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "None"
[SYNCDOC DEBUG]       no_spaces: "None"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 558: "    }"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "}"
[SYNCDOC DEBUG]       no_spaces: "}"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 559: ""
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ""
[SYNCDOC DEBUG]       no_spaces: ""
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 560: "    #[must_use]"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "#[must_use]"
[SYNCDOC DEBUG]       no_spaces: "#[must_use]"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 561: "    pub fn navigate_to_first(&self) -> Option<usize> {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "pub fn navigate_to_first(&self) -> Option<usize> {"
[SYNCDOC DEBUG]       no_spaces: "pubfnnavigate_to_first(&self)->Option<usize>{"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 562: "        self.tree_nodes.iter().position(|n| n.navigable)"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "self.tree_nodes.iter().position(|n| n.navigable)"
[SYNCDOC DEBUG]       no_spaces: "self.tree_nodes.iter().position(|n|n.navigable)"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 563: "    }"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "}"
[SYNCDOC DEBUG]       no_spaces: "}"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 564: ""
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ""
[SYNCDOC DEBUG]       no_spaces: ""
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 565: "    #[must_use]"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "#[must_use]"
[SYNCDOC DEBUG]       no_spaces: "#[must_use]"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 566: "    pub fn navigate_to_last(&self) -> Option<usize> {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "pub fn navigate_to_last(&self) -> Option<usize> {"
[SYNCDOC DEBUG]       no_spaces: "pubfnnavigate_to_last(&self)->Option<usize>{"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 567: "        self.tree_nodes.iter().rposition(|n| n.navigable)"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "self.tree_nodes.iter().rposition(|n| n.navigable)"
[SYNCDOC DEBUG]       no_spaces: "self.tree_nodes.iter().rposition(|n|n.navigable)"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 568: "    }"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "}"
[SYNCDOC DEBUG]       no_spaces: "}"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 569: ""
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ""
[SYNCDOC DEBUG]       no_spaces: ""
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 570: "    #[must_use]"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "#[must_use]"
[SYNCDOC DEBUG]       no_spaces: "#[must_use]"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 571: "    pub fn navigate_to_first_at_level(&self) -> Option<usize> {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "pub fn navigate_to_first_at_level(&self) -> Option<usize> {"
[SYNCDOC DEBUG]       no_spaces: "pubfnnavigate_to_first_at_level(&self)->Option<usize>{"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 572: "        let section_idx = self.get_current_section_index()?;"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "let section_idx = self.get_current_section_index()?;"
[SYNCDOC DEBUG]       no_spaces: "letsection_idx=self.get_current_section_index()?;"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 573: "        let current_level = self.sections[section_idx].level;"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "let current_level = self.sections[section_idx].level;"
[SYNCDOC DEBUG]       no_spaces: "letcurrent_level=self.sections[section_idx].level;"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 574: ""
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ""
[SYNCDOC DEBUG]       no_spaces: ""
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 575: "        for i in 0..self.sections.len() {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "for i in 0..self.sections.len() {"
[SYNCDOC DEBUG]       no_spaces: "foriin0..self.sections.len(){"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 576: "            if self.sections[i].level == current_level {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "if self.sections[i].level == current_level {"
[SYNCDOC DEBUG]       no_spaces: "ifself.sections[i].level==current_level{"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 577: "                return self"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "return self"
[SYNCDOC DEBUG]       no_spaces: "returnself"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 578: "                    .tree_nodes"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ".tree_nodes"
[SYNCDOC DEBUG]       no_spaces: ".tree_nodes"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 579: "                    .iter()"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ".iter()"
[SYNCDOC DEBUG]       no_spaces: ".iter()"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 580: "                    .position(|n| n.section_index == Some(i));"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ".position(|n| n.section_index == Some(i));"
[SYNCDOC DEBUG]       no_spaces: ".position(|n|n.section_index==Some(i));"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 581: "            }"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "}"
[SYNCDOC DEBUG]       no_spaces: "}"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 582: "        }"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "}"
[SYNCDOC DEBUG]       no_spaces: "}"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 583: ""
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ""
[SYNCDOC DEBUG]       no_spaces: ""
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 584: "        None"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "None"
[SYNCDOC DEBUG]       no_spaces: "None"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 585: "    }"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "}"
[SYNCDOC DEBUG]       no_spaces: "}"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 586: ""
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ""
[SYNCDOC DEBUG]       no_spaces: ""
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 587: "    #[must_use]"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "#[must_use]"
[SYNCDOC DEBUG]       no_spaces: "#[must_use]"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 588: "    pub fn navigate_to_last_at_level(&self) -> Option<usize> {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "pub fn navigate_to_last_at_level(&self) -> Option<usize> {"
[SYNCDOC DEBUG]       no_spaces: "pubfnnavigate_to_last_at_level(&self)->Option<usize>{"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 589: "        let section_idx = self.get_current_section_index()?;"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "let section_idx = self.get_current_section_index()?;"
[SYNCDOC DEBUG]       no_spaces: "letsection_idx=self.get_current_section_index()?;"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 590: "        let current_level = self.sections[section_idx].level;"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "let current_level = self.sections[section_idx].level;"
[SYNCDOC DEBUG]       no_spaces: "letcurrent_level=self.sections[section_idx].level;"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 591: ""
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ""
[SYNCDOC DEBUG]       no_spaces: ""
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 592: "        for i in (0..self.sections.len()).rev() {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "for i in (0..self.sections.len()).rev() {"
[SYNCDOC DEBUG]       no_spaces: "foriin(0..self.sections.len()).rev(){"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 593: "            if self.sections[i].level == current_level {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "if self.sections[i].level == current_level {"
[SYNCDOC DEBUG]       no_spaces: "ifself.sections[i].level==current_level{"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 594: "                return self"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "return self"
[SYNCDOC DEBUG]       no_spaces: "returnself"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 595: "                    .tree_nodes"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ".tree_nodes"
[SYNCDOC DEBUG]       no_spaces: ".tree_nodes"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 596: "                    .iter()"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ".iter()"
[SYNCDOC DEBUG]       no_spaces: ".iter()"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 597: "                    .position(|n| n.section_index == Some(i));"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ".position(|n| n.section_index == Some(i));"
[SYNCDOC DEBUG]       no_spaces: ".position(|n|n.section_index==Some(i));"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 598: "            }"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "}"
[SYNCDOC DEBUG]       no_spaces: "}"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 599: "        }"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "}"
[SYNCDOC DEBUG]       no_spaces: "}"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 600: ""
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ""
[SYNCDOC DEBUG]       no_spaces: ""
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 601: "        None"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "None"
[SYNCDOC DEBUG]       no_spaces: "None"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 602: "    }"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "}"
[SYNCDOC DEBUG]       no_spaces: "}"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 603: ""
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ""
[SYNCDOC DEBUG]       no_spaces: ""
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 604: "    #[must_use]"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "#[must_use]"
[SYNCDOC DEBUG]       no_spaces: "#[must_use]"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 605: "    pub fn get_indent(&self) -> usize {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "pub fn get_indent(&self) -> usize {"
[SYNCDOC DEBUG]       no_spaces: "pubfnget_indent(&self)->usize{"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 606: "        if let Some(section) = self.get_current_section() {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "if let Some(section) = self.get_current_section() {"
[SYNCDOC DEBUG]       no_spaces: "ifletSome(section)=self.get_current_section(){"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 607: "            section.level * 2"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "section.level * 2"
[SYNCDOC DEBUG]       no_spaces: "section.level*2"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 608: "        } else {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "} else {"
[SYNCDOC DEBUG]       no_spaces: "}else{"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 609: "            0"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "0"
[SYNCDOC DEBUG]       no_spaces: "0"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 610: "        }"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "}"
[SYNCDOC DEBUG]       no_spaces: "}"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 611: "    }"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "}"
[SYNCDOC DEBUG]       no_spaces: "}"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 612: ""
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ""
[SYNCDOC DEBUG]       no_spaces: ""
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 613: "    #[must_use]"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "#[must_use]"
[SYNCDOC DEBUG]       no_spaces: "#[must_use]"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 614: "    pub fn get_max_line_width(&self) -> usize {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "pub fn get_max_line_width(&self) -> usize {"
[SYNCDOC DEBUG]       no_spaces: "pubfnget_max_line_width(&self)->usize{"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 615: "        let indent = self.get_indent();"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "let indent = self.get_indent();"
[SYNCDOC DEBUG]       no_spaces: "letindent=self.get_indent();"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 616: "        self.wrap_width.saturating_sub(indent)"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "self.wrap_width.saturating_sub(indent)"
[SYNCDOC DEBUG]       no_spaces: "self.wrap_width.saturating_sub(indent)"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 617: "    }"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "}"
[SYNCDOC DEBUG]       no_spaces: "}"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 618: ""
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ""
[SYNCDOC DEBUG]       no_spaces: ""
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 619: ""
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ""
[SYNCDOC DEBUG]       no_spaces: ""
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 620: "    // --- Section List Movement ---"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "// --- Section List Movement ---"
[SYNCDOC DEBUG]       no_spaces: "//---SectionListMovement---"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 621: "    pub fn start_move(&mut self) {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "pub fn start_move(&mut self) {"
[SYNCDOC DEBUG]       no_spaces: "pubfnstart_move(&mutself){"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 622: "        if let Some(section_idx) = self.get_current_section_index() {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "if let Some(section_idx) = self.get_current_section_index() {"
[SYNCDOC DEBUG]       no_spaces: "ifletSome(section_idx)=self.get_current_section_index(){"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 623: "            self.moving_section_index = Some(section_idx);"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "self.moving_section_index = Some(section_idx);"
[SYNCDOC DEBUG]       no_spaces: "self.moving_section_index=Some(section_idx);"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 624: "            self.move_state = MoveState::Selected;"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "self.move_state = MoveState::Selected;"
[SYNCDOC DEBUG]       no_spaces: "self.move_state=MoveState::Selected;"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 625: "        }"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "}"
[SYNCDOC DEBUG]       no_spaces: "}"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 626: "    }"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "}"
[SYNCDOC DEBUG]       no_spaces: "}"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 627: ""
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ""
[SYNCDOC DEBUG]       no_spaces: ""
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 628: "    pub fn cancel_move(&mut self) {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "pub fn cancel_move(&mut self) {"
[SYNCDOC DEBUG]       no_spaces: "pubfncancel_move(&mutself){"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 629: "        self.moving_section_index = None;"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "self.moving_section_index = None;"
[SYNCDOC DEBUG]       no_spaces: "self.moving_section_index=None;"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 630: "        self.move_state = MoveState::None;"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "self.move_state = MoveState::None;"
[SYNCDOC DEBUG]       no_spaces: "self.move_state=MoveState::None;"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 631: "    }"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "}"
[SYNCDOC DEBUG]       no_spaces: "}"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 632: ""
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ""
[SYNCDOC DEBUG]       no_spaces: ""
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 633: "    pub fn mark_moved(&mut self) {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "pub fn mark_moved(&mut self) {"
[SYNCDOC DEBUG]       no_spaces: "pubfnmark_moved(&mutself){"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 634: "        self.move_state = MoveState::Moved;"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "self.move_state = MoveState::Moved;"
[SYNCDOC DEBUG]       no_spaces: "self.move_state=MoveState::Moved;"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 635: "    }"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "}"
[SYNCDOC DEBUG]       no_spaces: "}"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 636: ""
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ""
[SYNCDOC DEBUG]       no_spaces: ""
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 637: "    pub fn move_section_up(&mut self) -> bool {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "pub fn move_section_up(&mut self) -> bool {"
[SYNCDOC DEBUG]       no_spaces: "pubfnmove_section_up(&mutself)->bool{"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 638: "        if let Some(moving_idx) = self.moving_section_index {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "if let Some(moving_idx) = self.moving_section_index {"
[SYNCDOC DEBUG]       no_spaces: "ifletSome(moving_idx)=self.moving_section_index{"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 639: "            if moving_idx > 0 {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "if moving_idx > 0 {"
[SYNCDOC DEBUG]       no_spaces: "ifmoving_idx>0{"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 640: "                self.sections.swap(moving_idx, moving_idx - 1);"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "self.sections.swap(moving_idx, moving_idx - 1);"
[SYNCDOC DEBUG]       no_spaces: "self.sections.swap(moving_idx,moving_idx-1);"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 641: "                self.moving_section_index = Some(moving_idx - 1);"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "self.moving_section_index = Some(moving_idx - 1);"
[SYNCDOC DEBUG]       no_spaces: "self.moving_section_index=Some(moving_idx-1);"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 642: "                self.rebuild_tree();"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "self.rebuild_tree();"
[SYNCDOC DEBUG]       no_spaces: "self.rebuild_tree();"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 643: ""
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ""
[SYNCDOC DEBUG]       no_spaces: ""
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 644: "                // Update current node to follow the moved section"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "// Update current node to follow the moved section"
[SYNCDOC DEBUG]       no_spaces: "//Updatecurrentnodetofollowthemovedsection"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 645: "                if let Some(node_idx) = self"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "if let Some(node_idx) = self"
[SYNCDOC DEBUG]       no_spaces: "ifletSome(node_idx)=self"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 646: "                    .tree_nodes"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ".tree_nodes"
[SYNCDOC DEBUG]       no_spaces: ".tree_nodes"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 647: "                    .iter()"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ".iter()"
[SYNCDOC DEBUG]       no_spaces: ".iter()"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 648: "                    .position(|n| n.section_index == Some(moving_idx - 1))"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ".position(|n| n.section_index == Some(moving_idx - 1))"
[SYNCDOC DEBUG]       no_spaces: ".position(|n|n.section_index==Some(moving_idx-1))"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 649: "                {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "{"
[SYNCDOC DEBUG]       no_spaces: "{"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 650: "                    self.current_node_index = node_idx;"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "self.current_node_index = node_idx;"
[SYNCDOC DEBUG]       no_spaces: "self.current_node_index=node_idx;"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 651: "                }"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "}"
[SYNCDOC DEBUG]       no_spaces: "}"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 652: ""
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ""
[SYNCDOC DEBUG]       no_spaces: ""
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 653: "                self.mark_moved();"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "self.mark_moved();"
[SYNCDOC DEBUG]       no_spaces: "self.mark_moved();"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 654: "                return true;"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "return true;"
[SYNCDOC DEBUG]       no_spaces: "returntrue;"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 655: "            }"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "}"
[SYNCDOC DEBUG]       no_spaces: "}"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 656: "        }"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "}"
[SYNCDOC DEBUG]       no_spaces: "}"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 657: "        false"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "false"
[SYNCDOC DEBUG]       no_spaces: "false"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 658: "    }"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "}"
[SYNCDOC DEBUG]       no_spaces: "}"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 659: ""
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ""
[SYNCDOC DEBUG]       no_spaces: ""
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 660: "    pub fn move_section_down(&mut self) -> bool {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "pub fn move_section_down(&mut self) -> bool {"
[SYNCDOC DEBUG]       no_spaces: "pubfnmove_section_down(&mutself)->bool{"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 661: "        if let Some(moving_idx) = self.moving_section_index {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "if let Some(moving_idx) = self.moving_section_index {"
[SYNCDOC DEBUG]       no_spaces: "ifletSome(moving_idx)=self.moving_section_index{"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 662: "            if moving_idx < self.sections.len() - 1 {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "if moving_idx < self.sections.len() - 1 {"
[SYNCDOC DEBUG]       no_spaces: "ifmoving_idx<self.sections.len()-1{"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 663: "                self.sections.swap(moving_idx, moving_idx + 1);"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "self.sections.swap(moving_idx, moving_idx + 1);"
[SYNCDOC DEBUG]       no_spaces: "self.sections.swap(moving_idx,moving_idx+1);"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 664: "                self.moving_section_index = Some(moving_idx + 1);"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "self.moving_section_index = Some(moving_idx + 1);"
[SYNCDOC DEBUG]       no_spaces: "self.moving_section_index=Some(moving_idx+1);"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 665: "                self.rebuild_tree();"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "self.rebuild_tree();"
[SYNCDOC DEBUG]       no_spaces: "self.rebuild_tree();"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 666: ""
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ""
[SYNCDOC DEBUG]       no_spaces: ""
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 667: "                if let Some(node_idx) = self"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "if let Some(node_idx) = self"
[SYNCDOC DEBUG]       no_spaces: "ifletSome(node_idx)=self"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 668: "                    .tree_nodes"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ".tree_nodes"
[SYNCDOC DEBUG]       no_spaces: ".tree_nodes"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 669: "                    .iter()"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ".iter()"
[SYNCDOC DEBUG]       no_spaces: ".iter()"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 670: "                    .position(|n| n.section_index == Some(moving_idx + 1))"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ".position(|n| n.section_index == Some(moving_idx + 1))"
[SYNCDOC DEBUG]       no_spaces: ".position(|n|n.section_index==Some(moving_idx+1))"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 671: "                {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "{"
[SYNCDOC DEBUG]       no_spaces: "{"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 672: "                    self.current_node_index = node_idx;"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "self.current_node_index = node_idx;"
[SYNCDOC DEBUG]       no_spaces: "self.current_node_index=node_idx;"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 673: "                }"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "}"
[SYNCDOC DEBUG]       no_spaces: "}"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 674: ""
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ""
[SYNCDOC DEBUG]       no_spaces: ""
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 675: "                self.mark_moved();"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "self.mark_moved();"
[SYNCDOC DEBUG]       no_spaces: "self.mark_moved();"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 676: "                return true;"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "return true;"
[SYNCDOC DEBUG]       no_spaces: "returntrue;"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 677: "            }"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "}"
[SYNCDOC DEBUG]       no_spaces: "}"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 678: "        }"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "}"
[SYNCDOC DEBUG]       no_spaces: "}"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 679: "        false"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "false"
[SYNCDOC DEBUG]       no_spaces: "false"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 680: "    }"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "}"
[SYNCDOC DEBUG]       no_spaces: "}"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 681: ""
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ""
[SYNCDOC DEBUG]       no_spaces: ""
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 682: "    pub fn move_section_to_top(&mut self) -> bool {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "pub fn move_section_to_top(&mut self) -> bool {"
[SYNCDOC DEBUG]       no_spaces: "pubfnmove_section_to_top(&mutself)->bool{"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 683: "        if let Some(moving_idx) = self.moving_section_index {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "if let Some(moving_idx) = self.moving_section_index {"
[SYNCDOC DEBUG]       no_spaces: "ifletSome(moving_idx)=self.moving_section_index{"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 684: "            if moving_idx > 0 {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "if moving_idx > 0 {"
[SYNCDOC DEBUG]       no_spaces: "ifmoving_idx>0{"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 685: "                let section = self.sections.remove(moving_idx);"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "let section = self.sections.remove(moving_idx);"
[SYNCDOC DEBUG]       no_spaces: "letsection=self.sections.remove(moving_idx);"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 686: "                self.sections.insert(0, section);"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "self.sections.insert(0, section);"
[SYNCDOC DEBUG]       no_spaces: "self.sections.insert(0,section);"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 687: "                self.moving_section_index = Some(0);"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "self.moving_section_index = Some(0);"
[SYNCDOC DEBUG]       no_spaces: "self.moving_section_index=Some(0);"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 688: "                self.rebuild_tree();"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "self.rebuild_tree();"
[SYNCDOC DEBUG]       no_spaces: "self.rebuild_tree();"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 689: ""
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ""
[SYNCDOC DEBUG]       no_spaces: ""
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 690: "                if let Some(node_idx) = self"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "if let Some(node_idx) = self"
[SYNCDOC DEBUG]       no_spaces: "ifletSome(node_idx)=self"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 691: "                    .tree_nodes"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ".tree_nodes"
[SYNCDOC DEBUG]       no_spaces: ".tree_nodes"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 692: "                    .iter()"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ".iter()"
[SYNCDOC DEBUG]       no_spaces: ".iter()"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 693: "                    .position(|n| n.section_index == Some(0))"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ".position(|n| n.section_index == Some(0))"
[SYNCDOC DEBUG]       no_spaces: ".position(|n|n.section_index==Some(0))"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 694: "                {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "{"
[SYNCDOC DEBUG]       no_spaces: "{"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 695: "                    self.current_node_index = node_idx;"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "self.current_node_index = node_idx;"
[SYNCDOC DEBUG]       no_spaces: "self.current_node_index=node_idx;"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 696: "                }"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "}"
[SYNCDOC DEBUG]       no_spaces: "}"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 697: ""
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ""
[SYNCDOC DEBUG]       no_spaces: ""
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 698: "                self.mark_moved();"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "self.mark_moved();"
[SYNCDOC DEBUG]       no_spaces: "self.mark_moved();"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 699: "                return true;"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "return true;"
[SYNCDOC DEBUG]       no_spaces: "returntrue;"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 700: "            }"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "}"
[SYNCDOC DEBUG]       no_spaces: "}"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 701: "        }"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "}"
[SYNCDOC DEBUG]       no_spaces: "}"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 702: "        false"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "false"
[SYNCDOC DEBUG]       no_spaces: "false"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 703: "    }"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "}"
[SYNCDOC DEBUG]       no_spaces: "}"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 704: ""
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ""
[SYNCDOC DEBUG]       no_spaces: ""
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 705: "    pub fn move_section_to_bottom(&mut self) -> bool {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "pub fn move_section_to_bottom(&mut self) -> bool {"
[SYNCDOC DEBUG]       no_spaces: "pubfnmove_section_to_bottom(&mutself)->bool{"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 706: "        if let Some(moving_idx) = self.moving_section_index {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "if let Some(moving_idx) = self.moving_section_index {"
[SYNCDOC DEBUG]       no_spaces: "ifletSome(moving_idx)=self.moving_section_index{"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 707: "            let last_idx = self.sections.len() - 1;"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "let last_idx = self.sections.len() - 1;"
[SYNCDOC DEBUG]       no_spaces: "letlast_idx=self.sections.len()-1;"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 708: "            if moving_idx < last_idx {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "if moving_idx < last_idx {"
[SYNCDOC DEBUG]       no_spaces: "ifmoving_idx<last_idx{"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 709: "                let section = self.sections.remove(moving_idx);"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "let section = self.sections.remove(moving_idx);"
[SYNCDOC DEBUG]       no_spaces: "letsection=self.sections.remove(moving_idx);"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 710: "                self.sections.push(section);"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "self.sections.push(section);"
[SYNCDOC DEBUG]       no_spaces: "self.sections.push(section);"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 711: "                self.moving_section_index = Some(last_idx);"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "self.moving_section_index = Some(last_idx);"
[SYNCDOC DEBUG]       no_spaces: "self.moving_section_index=Some(last_idx);"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 712: "                self.rebuild_tree();"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "self.rebuild_tree();"
[SYNCDOC DEBUG]       no_spaces: "self.rebuild_tree();"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 713: ""
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ""
[SYNCDOC DEBUG]       no_spaces: ""
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 714: "                if let Some(node_idx) = self"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "if let Some(node_idx) = self"
[SYNCDOC DEBUG]       no_spaces: "ifletSome(node_idx)=self"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 715: "                    .tree_nodes"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ".tree_nodes"
[SYNCDOC DEBUG]       no_spaces: ".tree_nodes"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 716: "                    .iter()"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ".iter()"
[SYNCDOC DEBUG]       no_spaces: ".iter()"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 717: "                    .position(|n| n.section_index == Some(last_idx))"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ".position(|n| n.section_index == Some(last_idx))"
[SYNCDOC DEBUG]       no_spaces: ".position(|n|n.section_index==Some(last_idx))"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 718: "                {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "{"
[SYNCDOC DEBUG]       no_spaces: "{"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 719: "                    self.current_node_index = node_idx;"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "self.current_node_index = node_idx;"
[SYNCDOC DEBUG]       no_spaces: "self.current_node_index=node_idx;"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 720: "                }"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "}"
[SYNCDOC DEBUG]       no_spaces: "}"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 721: ""
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ""
[SYNCDOC DEBUG]       no_spaces: ""
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 722: "                self.mark_moved();"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "self.mark_moved();"
[SYNCDOC DEBUG]       no_spaces: "self.mark_moved();"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 723: "                return true;"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "return true;"
[SYNCDOC DEBUG]       no_spaces: "returntrue;"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 724: "            }"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "}"
[SYNCDOC DEBUG]       no_spaces: "}"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 725: "        }"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "}"
[SYNCDOC DEBUG]       no_spaces: "}"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 726: "        false"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "false"
[SYNCDOC DEBUG]       no_spaces: "false"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 727: "    }"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "}"
[SYNCDOC DEBUG]       no_spaces: "}"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 728: ""
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ""
[SYNCDOC DEBUG]       no_spaces: ""
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 729: "    pub fn move_section_in(&mut self) -> bool {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "pub fn move_section_in(&mut self) -> bool {"
[SYNCDOC DEBUG]       no_spaces: "pubfnmove_section_in(&mutself)->bool{"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 730: "        if let Some(moving_idx) = self.moving_section_index {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "if let Some(moving_idx) = self.moving_section_index {"
[SYNCDOC DEBUG]       no_spaces: "ifletSome(moving_idx)=self.moving_section_index{"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 731: "            if self.sections[moving_idx].level > 1 {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "if self.sections[moving_idx].level > 1 {"
[SYNCDOC DEBUG]       no_spaces: "ifself.sections[moving_idx].level>1{"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 732: "                self.sections[moving_idx].level -= 1;"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "self.sections[moving_idx].level -= 1;"
[SYNCDOC DEBUG]       no_spaces: "self.sections[moving_idx].level-=1;"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 733: "                self.rebuild_tree();"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "self.rebuild_tree();"
[SYNCDOC DEBUG]       no_spaces: "self.rebuild_tree();"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 734: "                self.mark_moved();"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "self.mark_moved();"
[SYNCDOC DEBUG]       no_spaces: "self.mark_moved();"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 735: "                return true;"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "return true;"
[SYNCDOC DEBUG]       no_spaces: "returntrue;"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 736: "            }"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "}"
[SYNCDOC DEBUG]       no_spaces: "}"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 737: "        }"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "}"
[SYNCDOC DEBUG]       no_spaces: "}"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 738: "        false"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "false"
[SYNCDOC DEBUG]       no_spaces: "false"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 739: "    }"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "}"
[SYNCDOC DEBUG]       no_spaces: "}"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 740: ""
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ""
[SYNCDOC DEBUG]       no_spaces: ""
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 741: "    pub fn move_section_out(&mut self) -> bool {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "pub fn move_section_out(&mut self) -> bool {"
[SYNCDOC DEBUG]       no_spaces: "pubfnmove_section_out(&mutself)->bool{"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 742: "        if let Some(moving_idx) = self.moving_section_index {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "if let Some(moving_idx) = self.moving_section_index {"
[SYNCDOC DEBUG]       no_spaces: "ifletSome(moving_idx)=self.moving_section_index{"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 743: "            if self.sections[moving_idx].level < 6 {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "if self.sections[moving_idx].level < 6 {"
[SYNCDOC DEBUG]       no_spaces: "ifself.sections[moving_idx].level<6{"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 744: "                self.sections[moving_idx].level += 1;"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "self.sections[moving_idx].level += 1;"
[SYNCDOC DEBUG]       no_spaces: "self.sections[moving_idx].level+=1;"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 745: "                self.rebuild_tree();"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "self.rebuild_tree();"
[SYNCDOC DEBUG]       no_spaces: "self.rebuild_tree();"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 746: "                self.mark_moved();"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "self.mark_moved();"
[SYNCDOC DEBUG]       no_spaces: "self.mark_moved();"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 747: "                return true;"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "return true;"
[SYNCDOC DEBUG]       no_spaces: "returntrue;"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 748: "            }"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "}"
[SYNCDOC DEBUG]       no_spaces: "}"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 749: "        }"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "}"
[SYNCDOC DEBUG]       no_spaces: "}"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 750: "        false"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "false"
[SYNCDOC DEBUG]       no_spaces: "false"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 751: "    }"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "}"
[SYNCDOC DEBUG]       no_spaces: "}"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 752: ""
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ""
[SYNCDOC DEBUG]       no_spaces: ""
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 753: "    pub fn save_section_reorder(&mut self) -> io::Result<()> {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "pub fn save_section_reorder(&mut self) -> io::Result<()> {"
[SYNCDOC DEBUG]       no_spaces: "pubfnsave_section_reorder(&mutself)->io::Result<()>{"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 754: "        if self.move_state != MoveState::Moved {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "if self.move_state != MoveState::Moved {"
[SYNCDOC DEBUG]       no_spaces: "ifself.move_state!=MoveState::Moved{"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 755: "            return Ok(());"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "return Ok(());"
[SYNCDOC DEBUG]       no_spaces: "returnOk(());"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 756: "        }"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "}"
[SYNCDOC DEBUG]       no_spaces: "}"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 757: ""
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ""
[SYNCDOC DEBUG]       no_spaces: ""
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 758: "        // Group sections by file"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "// Group sections by file"
[SYNCDOC DEBUG]       no_spaces: "//Groupsectionsbyfile"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 759: "        let mut file_sections: HashMap<String, Vec<&Section>> = HashMap::new();"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "let mut file_sections: HashMap<String, Vec<&Section>> = HashMap::new();"
[SYNCDOC DEBUG]       no_spaces: "letmutfile_sections:HashMap<String,Vec<&Section>>=HashMap::new();"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 760: "        for section in &self.sections {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "for section in &self.sections {"
[SYNCDOC DEBUG]       no_spaces: "forsectionin&self.sections{"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 761: "            file_sections"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "file_sections"
[SYNCDOC DEBUG]       no_spaces: "file_sections"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 762: "                .entry(section.file_path.clone())"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ".entry(section.file_path.clone())"
[SYNCDOC DEBUG]       no_spaces: ".entry(section.file_path.clone())"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 763: "                .or_default()"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ".or_default()"
[SYNCDOC DEBUG]       no_spaces: ".or_default()"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 764: "                .push(section);"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ".push(section);"
[SYNCDOC DEBUG]       no_spaces: ".push(section);"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 765: "        }"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "}"
[SYNCDOC DEBUG]       no_spaces: "}"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 766: ""
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ""
[SYNCDOC DEBUG]       no_spaces: ""
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 767: "        // Process each file"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "// Process each file"
[SYNCDOC DEBUG]       no_spaces: "//Processeachfile"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 768: "        for (file_path, sections) in file_sections {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "for (file_path, sections) in file_sections {"
[SYNCDOC DEBUG]       no_spaces: "for(file_path,sections)infile_sections{"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 769: "            Self::rewrite_file_sections(&file_path, &sections)?;"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "Self::rewrite_file_sections(&file_path, &sections)?;"
[SYNCDOC DEBUG]       no_spaces: "Self::rewrite_file_sections(&file_path,&sections)?;"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 770: "        }"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "}"
[SYNCDOC DEBUG]       no_spaces: "}"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 771: ""
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ""
[SYNCDOC DEBUG]       no_spaces: ""
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 772: "        // Reload sections to get updated positions"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "// Reload sections to get updated positions"
[SYNCDOC DEBUG]       no_spaces: "//Reloadsectionstogetupdatedpositions"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 773: "        let format = MarkdownFormat;"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "let format = MarkdownFormat;"
[SYNCDOC DEBUG]       no_spaces: "letformat=MarkdownFormat;"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 774: "        let mut new_sections = Vec::new();"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "let mut new_sections = Vec::new();"
[SYNCDOC DEBUG]       no_spaces: "letmutnew_sections=Vec::new();"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 775: "        for file in &self.files {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "for file in &self.files {"
[SYNCDOC DEBUG]       no_spaces: "forfilein&self.files{"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 776: "            if let Ok(secs) = input::extract_sections(file, &format) {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "if let Ok(secs) = input::extract_sections(file, &format) {"
[SYNCDOC DEBUG]       no_spaces: "ifletOk(secs)=input::extract_sections(file,&format){"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 777: "                new_sections.extend(secs);"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "new_sections.extend(secs);"
[SYNCDOC DEBUG]       no_spaces: "new_sections.extend(secs);"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 778: "            }"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "}"
[SYNCDOC DEBUG]       no_spaces: "}"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 779: "        }"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "}"
[SYNCDOC DEBUG]       no_spaces: "}"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 780: ""
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ""
[SYNCDOC DEBUG]       no_spaces: ""
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 781: "        self.sections = new_sections;"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "self.sections = new_sections;"
[SYNCDOC DEBUG]       no_spaces: "self.sections=new_sections;"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 782: "        self.rebuild_tree();"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "self.rebuild_tree();"
[SYNCDOC DEBUG]       no_spaces: "self.rebuild_tree();"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 783: "        self.cancel_move();"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "self.cancel_move();"
[SYNCDOC DEBUG]       no_spaces: "self.cancel_move();"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 784: "        self.message = Some(\"Sections reordered\".to_string());"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "self.message = Some(\"Sections reordered\".to_string());"
[SYNCDOC DEBUG]       no_spaces: "self.message=Some(\"Sectionsreordered\".to_string());"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 785: ""
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ""
[SYNCDOC DEBUG]       no_spaces: ""
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 786: "        Ok(())"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "Ok(())"
[SYNCDOC DEBUG]       no_spaces: "Ok(())"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 787: "    }"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "}"
[SYNCDOC DEBUG]       no_spaces: "}"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 788: ""
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ""
[SYNCDOC DEBUG]       no_spaces: ""
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 789: "    fn rewrite_file_sections(file_path: &str, sections: &[&Section]) -> io::Result<()> {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "fn rewrite_file_sections(file_path: &str, sections: &[&Section]) -> io::Result<()> {"
[SYNCDOC DEBUG]       no_spaces: "fnrewrite_file_sections(file_path:&str,sections:&[&Section])->io::Result<()>{"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 790: "        let content = fs::read_to_string(file_path)?;"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "let content = fs::read_to_string(file_path)?;"
[SYNCDOC DEBUG]       no_spaces: "letcontent=fs::read_to_string(file_path)?;"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 791: "        let mut new_content = String::new();"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "let mut new_content = String::new();"
[SYNCDOC DEBUG]       no_spaces: "letmutnew_content=String::new();"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 792: ""
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ""
[SYNCDOC DEBUG]       no_spaces: ""
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 793: "        for section in sections {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "for section in sections {"
[SYNCDOC DEBUG]       no_spaces: "forsectioninsections{"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 794: "            let heading_prefix = \"#\".repeat(section.level);"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "let heading_prefix = \"#\".repeat(section.level);"
[SYNCDOC DEBUG]       no_spaces: "letheading_prefix=\"#\".repeat(section.level);"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 795: "            let heading = format!(\"{} {}\", heading_prefix, section.title);"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "let heading = format!(\"{} {}\", heading_prefix, section.title);"
[SYNCDOC DEBUG]       no_spaces: "letheading=format!(\"{}{}\",heading_prefix,section.title);"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 796: ""
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ""
[SYNCDOC DEBUG]       no_spaces: ""
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 797: "            let bytes = content.as_bytes();"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "let bytes = content.as_bytes();"
[SYNCDOC DEBUG]       no_spaces: "letbytes=content.as_bytes();"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 798: "            let section_text ="
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "let section_text ="
[SYNCDOC DEBUG]       no_spaces: "letsection_text="
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 799: "                if section.byte_start < bytes.len() && section.byte_end <= bytes.len() {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "if section.byte_start < bytes.len() && section.byte_end <= bytes.len() {"
[SYNCDOC DEBUG]       no_spaces: "ifsection.byte_start<bytes.len()&&section.byte_end<=bytes.len(){"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 800: "                    String::from_utf8_lossy(&bytes[section.byte_start..section.byte_end])"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "String::from_utf8_lossy(&bytes[section.byte_start..section.byte_end])"
[SYNCDOC DEBUG]       no_spaces: "String::from_utf8_lossy(&bytes[section.byte_start..section.byte_end])"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 801: "                        .to_string()"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ".to_string()"
[SYNCDOC DEBUG]       no_spaces: ".to_string()"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 802: "                        .trim()"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ".trim()"
[SYNCDOC DEBUG]       no_spaces: ".trim()"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 803: "                        .to_string()"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ".to_string()"
[SYNCDOC DEBUG]       no_spaces: ".to_string()"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 804: "                } else {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "} else {"
[SYNCDOC DEBUG]       no_spaces: "}else{"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 805: "                    String::new()"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "String::new()"
[SYNCDOC DEBUG]       no_spaces: "String::new()"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 806: "                };"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "};"
[SYNCDOC DEBUG]       no_spaces: "};"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 807: ""
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ""
[SYNCDOC DEBUG]       no_spaces: ""
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 808: "            new_content.push_str(&heading);"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "new_content.push_str(&heading);"
[SYNCDOC DEBUG]       no_spaces: "new_content.push_str(&heading);"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 809: "            new_content.push_str(\"\\n\\n\");"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "new_content.push_str(\"\\n\\n\");"
[SYNCDOC DEBUG]       no_spaces: "new_content.push_str(\"\\n\\n\");"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 810: "            if !section_text.is_empty() {"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "if !section_text.is_empty() {"
[SYNCDOC DEBUG]       no_spaces: "if!section_text.is_empty(){"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 811: "                new_content.push_str(&section_text);"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "new_content.push_str(&section_text);"
[SYNCDOC DEBUG]       no_spaces: "new_content.push_str(&section_text);"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 812: "                new_content.push_str(\"\\n\\n\");"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "new_content.push_str(\"\\n\\n\");"
[SYNCDOC DEBUG]       no_spaces: "new_content.push_str(\"\\n\\n\");"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 813: "            }"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "}"
[SYNCDOC DEBUG]       no_spaces: "}"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 814: "        }"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "}"
[SYNCDOC DEBUG]       no_spaces: "}"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 815: ""
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ""
[SYNCDOC DEBUG]       no_spaces: ""
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 816: "        fs::write(file_path, new_content)?;"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "fs::write(file_path, new_content)?;"
[SYNCDOC DEBUG]       no_spaces: "fs::write(file_path,new_content)?;"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 817: "        Ok(())"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "Ok(())"
[SYNCDOC DEBUG]       no_spaces: "Ok(())"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 818: "    }"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "}"
[SYNCDOC DEBUG]       no_spaces: "}"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 819: "}"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "}"
[SYNCDOC DEBUG]       no_spaces: "}"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 820: ""
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: ""
[SYNCDOC DEBUG]       no_spaces: ""
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 821: "#[cfg(test)]"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "#[cfg(test)]"
[SYNCDOC DEBUG]       no_spaces: "#[cfg(test)]"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 822: "#[path = \"tests/app_state.rs\"]"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "#[path = \"tests/app_state.rs\"]"
[SYNCDOC DEBUG]       no_spaces: "#[path=\"tests/app_state.rs\"]"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Line 823: "mod tests;"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "mod tests;"
[SYNCDOC DEBUG]       no_spaces: "modtests;"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Final result length: 27369
[SYNCDOC DEBUG] === BOOKEND DEBUG END ===

[SYNCDOC DEBUG] After bookending: 19860
[SYNCDOC DEBUG] 
--- Final Result ---
[SYNCDOC DEBUG] #![doc = syncdoc::module_doc!()]

use crate::edit_plan::{Edit, EditPlan};
use crate::formats::markdown::MarkdownFormat;
use crate::input;
use crate::section::ChunkType;
use crate::section::{Section, TreeNode};
use edtui::{EditorState, Lines};
use std::collections::HashMap;
use std::path::PathBuf;
use std::{fs, io};

#[syncdoc::omnidoc]
#[derive(PartialEq)]
pub enum FileMode {
    Single,
    Multi,
}

#[syncdoc::omnidoc]
#[derive(Clone, PartialEq, Debug)]
pub enum MoveState {
    None,
    Selected,
    Moved,
}

#[syncdoc::omnidoc]
pub struct AppState {
    pub sections: Vec<Section>,
    pub tree_nodes: Vec<TreeNode>,
    pub files: Vec<PathBuf>,
    pub file_mode: FileMode,
    pub current_view: View,
    pub current_node_index: usize,
    pub editor_state: Option<EditorState>,
    pub command_buffer: String,
    pub message: Option<String>,
    pub wrap_width: usize,
    pub file_offsets: HashMap<String, HashMap<i64, usize>>,
    pub move_state: MoveState,
    pub moving_section_index: Option<usize>,
}

#[syncdoc::omnidoc]
#[derive(PartialEq)]
pub enum View {
    List,
    Detail,
    Command,
}

#[syncdoc::omnidoc]
impl AppState {
    #[must_use]
    pub fn new(files: Vec<PathBuf>, sections: Vec<Section>, wrap_width: usize) -> Self {
        let file_mode = if files.len() == 1 {
            FileMode::Single
        } else {
            FileMode::Multi
        };

        let tree_nodes = Self::build_tree(&files, &sections);

        // Find first navigable node
        let initial_index = tree_nodes.iter().position(|n| n.navigable).unwrap_or(0);

        Self {
            sections,
            tree_nodes,
            files,
            file_mode,
            current_view: View::List,
            current_node_index: initial_index,
            editor_state: None,
            command_buffer: String::new(),
            message: None,
            wrap_width,
            file_offsets: HashMap::new(),
            move_state: MoveState::None,
            moving_section_index: None,
        }
    }

    fn build_tree(files: &[PathBuf], sections: &[Section]) -> Vec<TreeNode> {
        let mut nodes = Vec::new();

        // Determine if this is difftastic mode by checking if multiple sections share the same file_path
        // (in markdown mode, each section has a unique file path or sections are from the same file)
        let mut file_section_counts: HashMap<String, usize> = HashMap::new();
        for section in sections {
            *file_section_counts
                .entry(section.file_path.clone())
                .or_insert(0) += 1;
        }
        let is_difftastic = file_section_counts.values().any(|&count| count > 1);

        if files.len() == 1 && !is_difftastic {
            // Single markdown file mode: use section level for tree indentation
            for (idx, section) in sections.iter().enumerate() {
                nodes.push(TreeNode::section(section.clone(), section.level, idx));
            }
        } else if is_difftastic {
            // Difftastic mode: group sections by file, show files as non-navigable nodes
            let mut file_tree: HashMap<String, Vec<(usize, &Section)>> = HashMap::new();
            let mut file_status: HashMap<String, Option<String>> = HashMap::new();

            // Group sections by file and infer file statuses
            for (idx, section) in sections.iter().enumerate() {
                file_tree
                    .entry(section.file_path.clone())
                    .or_default()
                    .push((idx, section));

                // Determine file status from hunk headers
                if !file_status.contains_key(&section.file_path) {
                    let status = if section.title.contains("@@ -0,0") {
                        Some("created".to_string())
                    } else if section.title.contains("+0,0 @@") {
                        Some("deleted".to_string())
                    } else if section.title.contains("@@ ") {
                        Some("changed".to_string())
                    } else {
                        None
                    };
                    file_status.insert(section.file_path.clone(), status);
                }
            }

            // Build tree with file nodes and hunk sections
            let mut sorted_files: Vec<_> = file_tree.keys().collect();
            sorted_files.sort();

            for file_path in sorted_files {
                // Add file node (non-navigable)
                let file_name = PathBuf::from(file_path)
                    .file_name()
                    .map_or_else(|| file_path.clone(), |n| n.to_string_lossy().to_string());

                let status_opt = file_status.get(file_path).and_then(|opt| opt.as_deref()); // flatten Option<Option<&str>>

                let label = match status_opt {
                    Some(status) => format!("{file_name} ({status})"),
                    None => file_name.clone(),
                };

                nodes.push(TreeNode::file(label, file_path.clone(), 0));

                // Add hunk sections under this file
                if let Some(file_sections) = file_tree.get(file_path) {
                    for (idx, section) in file_sections {
                        nodes.push(TreeNode::section((*section).clone(), 1, *idx));
                    }
                }
            }
        } else {
            // Multi-file markdown mode: build directory tree with sections nested under files
            let mut file_tree: HashMap<String, Vec<(usize, &Section)>> = HashMap::new();

            // Group sections by file
            for (idx, section) in sections.iter().enumerate() {
                file_tree
                    .entry(section.file_path.clone())
                    .or_default()
                    .push((idx, section));
            }

            // Build tree with directory structure
            let mut sorted_files: Vec<_> = files.iter().collect();
            sorted_files.sort();

            for file_path in sorted_files {
                let path_str = file_path.to_string_lossy().to_string();

                // Add file node (non-navigable)
                let file_name = file_path
                    .file_name()
                    .map_or_else(|| path_str.clone(), |n| n.to_string_lossy().to_string());

                nodes.push(TreeNode::file(file_name.clone(), path_str.clone(), 0));

                // Add sections under this file
                if let Some(file_sections) = file_tree.get(&path_str) {
                    for (idx, section) in file_sections {
                        nodes.push(TreeNode::section((*section).clone(), section.level, *idx));
                    }
                }
            }
        }

        nodes
    }

    pub fn rebuild_tree(&mut self) {
        self.tree_nodes = Self::build_tree(&self.files, &self.sections);

        // Try to maintain current position by finding same section
        if let Some(current_section_idx) = self.get_current_section_index() {
            if let Some(node_idx) = self
                .tree_nodes
                .iter()
                .position(|n| n.section_index == Some(current_section_idx))
            {
                self.current_node_index = node_idx;
            }
        }
    }

    #[must_use]
    pub fn get_current_section_index(&self) -> Option<usize> {
        if self.current_node_index < self.tree_nodes.len() {
            self.tree_nodes[self.current_node_index].section_index
        } else {
            None
        }
    }

    #[must_use]
    pub fn get_current_section(&self) -> Option<&Section> {
        self.get_current_section_index()
            .and_then(|idx| self.sections.get(idx))
    }

    fn rebuild_file_offsets(&mut self) {
        self.file_offsets.clear();

        if let Some(section_idx) = self.get_current_section_index() {
            if let Some(section) = self.sections.get(section_idx) {
                let lines_added = self.editor_state.as_ref().map_or(0, |es| es.lines.len());

                let file_map = self
                    .file_offsets
                    .entry(section.file_path.clone())
                    .or_default();

                file_map.insert(section.line_start, lines_added);
            }
        }
    }

    #[must_use]
    pub fn cumulative_offset(&self, index: usize) -> usize {
        let section = &self.sections[index];
        let target_file = &section.file_path;
        let target_line = section.line_start;

        if let Some(file_map) = self.file_offsets.get(target_file) {
            file_map
                .iter()
                .filter(|(line, _)| **line < target_line)
                .map(|(_, offset)| offset)
                .sum()
        } else {
            0
        }
    }

    pub fn load_docs(&mut self, plan: EditPlan) {
        let mut doc_map: HashMap<String, Vec<String>> = HashMap::new();
        for edit in plan.edits {
            let key = format!(
                "{}:{}:{}",
                edit.file_name, edit.line_start, edit.column_start
            );
            let lines: Vec<String> = edit
                .section_content
                .lines()
                .map(std::string::ToString::to_string)
                .collect();
            doc_map.insert(key, lines);
        }

        // Match edits to sections and pre-populate editor content
        for section in &mut self.sections {
            let key = format!(
                "{}:{}:{}",
                section.file_path, section.line_start, section.column_start
            );
            if doc_map.contains_key(&key) {
                if let Ok(content) = fs::read_to_string(&section.file_path) {
                    let bytes = content.as_bytes();
                    if section.byte_start < bytes.len() && section.byte_end <= bytes.len() {
                        // Section exists and can be loaded
                    }
                }
            }
        }
    }

    #[must_use]
    pub fn generate_edit_plan(&self) -> EditPlan {
        let mut edits = Vec::new();

        for section in &self.sections {
            if let Some(ref doc_lines) = section.section_content {
                let section_content = doc_lines.join("\n");

                edits.push(Edit {
                    file_name: section.file_path.clone(),
                    line_start: section.line_start,
                    line_end: section.line_end,
                    column_start: section.column_start,
                    column_end: section.column_end,
                    section_content,
                    item_name: section.title.clone(),
                });
            }
        }

        EditPlan { edits }
    }

    pub fn enter_detail_view(&mut self) {
        let Some(section_idx) = self.get_current_section_index() else {
            return;
        };

        let section = &self.sections[section_idx];

        // Handle difftastic chunks differently
        if let Some(chunk_type) = &section.chunk_type {
            let content = match chunk_type {
                ChunkType::Added => {
                    // Show only RHS for added chunks
                    section.rhs_content.clone().unwrap_or_default()
                }
                ChunkType::Deleted => {
                    // Show LHS with strikethrough or special formatting
                    section.lhs_content.clone().unwrap_or_default()
                }
                ChunkType::Modified => {
                    // Show a unified or side-by-side view
                    let lhs = section.lhs_content.as_deref().unwrap_or("");
                    let rhs = section.rhs_content.as_deref().unwrap_or("");
                    format!("- {lhs}\n+ {rhs}")
                }
                ChunkType::Unchanged => {
                    // Show either side (they're the same)
                    section
                        .lhs_content
                        .clone()
                        .or_else(|| section.rhs_content.clone())
                        .unwrap_or_default()
                }
            };

            let lines = Lines::from(content.as_str());
            self.editor_state = Some(EditorState::new(lines));
        } else if let Ok(content) = fs::read_to_string(&section.file_path) {
            let bytes = content.as_bytes();
            let section_bytes =
                &bytes[section.byte_start.min(bytes.len())..section.byte_end.min(bytes.len())];

            let section_content = String::from_utf8_lossy(section_bytes).to_string();

            let lines_text = if section_content.trim().is_empty() {
                "\n".to_string()
            } else {
                format!("\n{}\n", section_content.trim())
            };

            let lines = Lines::from(lines_text.as_str());
            self.editor_state = Some(EditorState::new(lines));
        }

        self.current_view = View::Detail;
    }

    pub fn exit_detail_view(&mut self, save: bool) {
        if save {
            if let Some(ref editor_state) = self.editor_state {
                if let Some(section_idx) = self.get_current_section_index() {
                    let lines = editor_state
                        .lines
                        .iter_row()
                        .map(|line| line.iter().collect::<String>())
                        .collect();
                    self.sections[section_idx].section_content = Some(lines);
                }
            }
        }
        self.editor_state = None;
        self.current_view = View::List;
    }

    pub fn save_current(&mut self) -> io::Result<()> {
        let editor_lines = if let Some(ref editor_state) = self.editor_state {
            editor_state
                .lines
                .iter_row()
                .map(|line| line.iter().collect::<String>())
                .collect::<Vec<_>>()
        } else {
            return Ok(());
        };

        let Some(section_idx) = self.get_current_section_index() else {
            return Ok(());
        };

        self.sections[section_idx].section_content = Some(editor_lines.clone());

        let section = &self.sections[section_idx];

        let raw_content = editor_lines.join("\n");
        let trimmed_content = raw_content.trim();
        let padded_content = format!("\n{trimmed_content}\n\n");

        let edit = Edit {
            file_name: section.file_path.clone(),
            line_start: section.line_start,
            line_end: section.line_end,
            column_start: section.column_start,
            column_end: section.column_end,
            section_content: padded_content,
            item_name: section.title.clone(),
        };

        let mut plan = EditPlan { edits: vec![edit] };
        plan.apply()?;

        // Reload sections
        let format = MarkdownFormat;
        if let Ok(new_sections) =
            input::extract_sections(&PathBuf::from(&section.file_path), &format)
        {
            let target_title = section.title.clone();
            let target_level = section.level;

            let file_path = section.file_path.clone();
            self.sections.retain(|s| s.file_path != file_path);

            if let Some(local_index) = new_sections
                .iter()
                .position(|s| s.title == target_title && s.level == target_level)
            {
                let new_global_index = self.sections.len() + local_index;
                self.sections.extend(new_sections);

                // Rebuild tree and find the updated section
                self.rebuild_tree();

                // Find node with this section index
                if let Some(node_idx) = self
                    .tree_nodes
                    .iter()
                    .position(|n| n.section_index == Some(new_global_index))
                {
                    self.current_node_index = node_idx;
                }
            } else {
                self.sections.extend(new_sections);
                self.rebuild_tree();
            }
        }

        self.rebuild_file_offsets();
        self.message = Some("Saved".to_string());
        Ok(())
    }

    #[must_use]
    pub fn find_next_node(&self) -> Option<usize> {
        ((self.current_node_index + 1)..self.tree_nodes.len())
            .find(|&i| self.tree_nodes[i].navigable)
    }

    #[must_use]
    pub fn find_prev_node(&self) -> Option<usize> {
        (0..self.current_node_index)
            .rev()
            .find(|&i| self.tree_nodes[i].navigable)
    }

    #[must_use]
    pub fn navigate_to_parent(&self) -> Option<usize> {
        let section_idx = self.get_current_section_index()?;
        let parent_section_idx = self.sections[section_idx].parent_index?;

        // Find tree node with this section index
        self.tree_nodes
            .iter()
            .position(|n| n.section_index == Some(parent_section_idx))
    }

    #[must_use]
    pub fn navigate_to_first_child(&self) -> Option<usize> {
        let section_idx = self.get_current_section_index()?;
        let first_child_idx = self.sections[section_idx].children_indices.first()?;

        self.tree_nodes
            .iter()
            .position(|n| n.section_index == Some(*first_child_idx))
    }

    #[must_use]
    pub fn navigate_to_next_descendant(&self) -> Option<usize> {
        let section_idx = self.get_current_section_index()?;

        // First try immediate children
        if let Some(first_child) = self.sections[section_idx].children_indices.first() {
            return self
                .tree_nodes
                .iter()
                .position(|n| n.section_index == Some(*first_child));
        }

        // Otherwise find next section at deeper level
        for i in (section_idx + 1)..self.sections.len() {
            if self.sections[i].level > self.sections[section_idx].level {
                return self
                    .tree_nodes
                    .iter()
                    .position(|n| n.section_index == Some(i));
            }
        }

        None
    }

    #[must_use]
    pub fn navigate_to_next_sibling(&self) -> Option<usize> {
        let section_idx = self.get_current_section_index()?;
        let current_level = self.sections[section_idx].level;

        for i in (section_idx + 1)..self.sections.len() {
            if self.sections[i].level == current_level {
                return self
                    .tree_nodes
                    .iter()
                    .position(|n| n.section_index == Some(i));
            }
            if self.sections[i].level < current_level {
                break;
            }
        }

        None
    }

    #[must_use]
    pub fn navigate_to_prev_sibling(&self) -> Option<usize> {
        let section_idx = self.get_current_section_index()?;
        let current_level = self.sections[section_idx].level;

        for i in (0..section_idx).rev() {
            if self.sections[i].level == current_level {
                return self
                    .tree_nodes
                    .iter()
                    .position(|n| n.section_index == Some(i));
            }
            if self.sections[i].level < current_level {
                break;
            }
        }

        None
    }

    #[must_use]
    pub fn navigate_to_first(&self) -> Option<usize> {
        self.tree_nodes.iter().position(|n| n.navigable)
    }

    #[must_use]
    pub fn navigate_to_last(&self) -> Option<usize> {
        self.tree_nodes.iter().rposition(|n| n.navigable)
    }

    #[must_use]
    pub fn navigate_to_first_at_level(&self) -> Option<usize> {
        let section_idx = self.get_current_section_index()?;
        let current_level = self.sections[section_idx].level;

        for i in 0..self.sections.len() {
            if self.sections[i].level == current_level {
                return self
                    .tree_nodes
                    .iter()
                    .position(|n| n.section_index == Some(i));
            }
        }

        None
    }

    #[must_use]
    pub fn navigate_to_last_at_level(&self) -> Option<usize> {
        let section_idx = self.get_current_section_index()?;
        let current_level = self.sections[section_idx].level;

        for i in (0..self.sections.len()).rev() {
            if self.sections[i].level == current_level {
                return self
                    .tree_nodes
                    .iter()
                    .position(|n| n.section_index == Some(i));
            }
        }

        None
    }

    #[must_use]
    pub fn get_indent(&self) -> usize {
        if let Some(section) = self.get_current_section() {
            section.level * 2
        } else {
            0
        }
    }

    #[must_use]
    pub fn get_max_line_width(&self) -> usize {
        let indent = self.get_indent();
        self.wrap_width.saturating_sub(indent)
    }


    // --- Section List Movement ---
    pub fn start_move(&mut self) {
        if let Some(section_idx) = self.get_current_section_index() {
            self.moving_section_index = Some(section_idx);
            self.move_state = MoveState::Selected;
        }
    }

    pub fn cancel_move(&mut self) {
        self.moving_section_index = None;
        self.move_state = MoveState::None;
    }

    pub fn mark_moved(&mut self) {
        self.move_state = MoveState::Moved;
    }

    pub fn move_section_up(&mut self) -> bool {
        if let Some(moving_idx) = self.moving_section_index {
            if moving_idx > 0 {
                self.sections.swap(moving_idx, moving_idx - 1);
                self.moving_section_index = Some(moving_idx - 1);
                self.rebuild_tree();

                // Update current node to follow the moved section
                if let Some(node_idx) = self
                    .tree_nodes
                    .iter()
                    .position(|n| n.section_index == Some(moving_idx - 1))
                {
                    self.current_node_index = node_idx;
                }

                self.mark_moved();
                return true;
            }
        }
        false
    }

    pub fn move_section_down(&mut self) -> bool {
        if let Some(moving_idx) = self.moving_section_index {
            if moving_idx < self.sections.len() - 1 {
                self.sections.swap(moving_idx, moving_idx + 1);
                self.moving_section_index = Some(moving_idx + 1);
                self.rebuild_tree();

                if let Some(node_idx) = self
                    .tree_nodes
                    .iter()
                    .position(|n| n.section_index == Some(moving_idx + 1))
                {
                    self.current_node_index = node_idx;
                }

                self.mark_moved();
                return true;
            }
        }
        false
    }

    pub fn move_section_to_top(&mut self) -> bool {
        if let Some(moving_idx) = self.moving_section_index {
            if moving_idx > 0 {
                let section = self.sections.remove(moving_idx);
                self.sections.insert(0, section);
                self.moving_section_index = Some(0);
                self.rebuild_tree();

                if let Some(node_idx) = self
                    .tree_nodes
                    .iter()
                    .position(|n| n.section_index == Some(0))
                {
                    self.current_node_index = node_idx;
                }

                self.mark_moved();
                return true;
            }
        }
        false
    }

    pub fn move_section_to_bottom(&mut self) -> bool {
        if let Some(moving_idx) = self.moving_section_index {
            let last_idx = self.sections.len() - 1;
            if moving_idx < last_idx {
                let section = self.sections.remove(moving_idx);
                self.sections.push(section);
                self.moving_section_index = Some(last_idx);
                self.rebuild_tree();

                if let Some(node_idx) = self
                    .tree_nodes
                    .iter()
                    .position(|n| n.section_index == Some(last_idx))
                {
                    self.current_node_index = node_idx;
                }

                self.mark_moved();
                return true;
            }
        }
        false
    }

    pub fn move_section_in(&mut self) -> bool {
        if let Some(moving_idx) = self.moving_section_index {
            if self.sections[moving_idx].level > 1 {
                self.sections[moving_idx].level -= 1;
                self.rebuild_tree();
                self.mark_moved();
                return true;
            }
        }
        false
    }

    pub fn move_section_out(&mut self) -> bool {
        if let Some(moving_idx) = self.moving_section_index {
            if self.sections[moving_idx].level < 6 {
                self.sections[moving_idx].level += 1;
                self.rebuild_tree();
                self.mark_moved();
                return true;
            }
        }
        false
    }

    pub fn save_section_reorder(&mut self) -> io::Result<()> {
        if self.move_state != MoveState::Moved {
            return Ok(());
        }

        // Group sections by file
        let mut file_sections: HashMap<String, Vec<&Section>> = HashMap::new();
        for section in &self.sections {
            file_sections
                .entry(section.file_path.clone())
                .or_default()
                .push(section);
        }

        // Process each file
        for (file_path, sections) in file_sections {
            Self::rewrite_file_sections(&file_path, &sections)?;
        }

        // Reload sections to get updated positions
        let format = MarkdownFormat;
        let mut new_sections = Vec::new();
        for file in &self.files {
            if let Ok(secs) = input::extract_sections(file, &format) {
                new_sections.extend(secs);
            }
        }

        self.sections = new_sections;
        self.rebuild_tree();
        self.cancel_move();
        self.message = Some("Sections reordered".to_string());

        Ok(())
    }

    fn rewrite_file_sections(file_path: &str, sections: &[&Section]) -> io::Result<()> {
        let content = fs::read_to_string(file_path)?;
        let mut new_content = String::new();

        for section in sections {
            let heading_prefix = "#".repeat(section.level);
            let heading = format!("{} {}", heading_prefix, section.title);

            let bytes = content.as_bytes();
            let section_text =
                if section.byte_start < bytes.len() && section.byte_end <= bytes.len() {
                    String::from_utf8_lossy(&bytes[section.byte_start..section.byte_end])
                        .to_string()
                        .trim()
                        .to_string()
                } else {
                    String::new()
                };

            new_content.push_str(&heading);
            new_content.push_str("\n\n");
            if !section_text.is_empty() {
                new_content.push_str(&section_text);
                new_content.push_str("\n\n");
            }
        }

        fs::write(file_path, new_content)?;
        Ok(())
    }
}

#[cfg(test)]
#[path = "tests/app_state.rs"]
mod tests;

[SYNCDOC DEBUG] === REFORMAT END ===

[SYNCDOC DEBUG] Processing item type: Other
[SYNCDOC DEBUG] Processing item: Other(Ident { sym: pub, span: bytes(31554..31557) })
[SYNCDOC DEBUG] Processing item type: Other
[SYNCDOC DEBUG] Processing item: Other(Ident { sym: mod, span: bytes(31558..31561) })
[SYNCDOC DEBUG] Processing item type: Other
[SYNCDOC DEBUG] Processing item: Other(Ident { sym: app_state, span: bytes(31562..31571) })
[SYNCDOC DEBUG] Processing item type: Other
[SYNCDOC DEBUG] Processing item: Other(Punct { char: ';', spacing: Alone, span: bytes(31571..31572) })
[SYNCDOC DEBUG] 
=== REFORMAT START ===
[SYNCDOC DEBUG] Original length: 19
[SYNCDOC DEBUG] Transformed length: 19
[SYNCDOC DEBUG] Formatted original length: 19
[SYNCDOC DEBUG] Formatted transformed length: 19
[SYNCDOC DEBUG] 
--- Formatted Original ---
[SYNCDOC DEBUG] pub mod app_state;

[SYNCDOC DEBUG] 
--- Formatted Transformed ---
[SYNCDOC DEBUG] pub mod app_state;

[SYNCDOC DEBUG] === HUNK DEBUG ===
[SYNCDOC DEBUG] Before lines: 1
[SYNCDOC DEBUG] After lines: 1
[SYNCDOC DEBUG] Hunks: 0
[SYNCDOC DEBUG] ==================
[SYNCDOC DEBUG] DEBUG restore: Found 0 hunks
[SYNCDOC DEBUG] === HUNK DEBUG ===
[SYNCDOC DEBUG] Before lines: 1
[SYNCDOC DEBUG] After lines: 1
[SYNCDOC DEBUG] Hunks: 0
[SYNCDOC DEBUG] ==================
[SYNCDOC DEBUG] Original != Result: true
[SYNCDOC DEBUG] 
=== BOOKEND DEBUG START ===
[SYNCDOC DEBUG] Input code length: 18
[SYNCDOC DEBUG] 
Line 0: "pub mod app_state;"
[SYNCDOC DEBUG]     Checking needs_bookending:
[SYNCDOC DEBUG]       trimmed: "pub mod app_state;"
[SYNCDOC DEBUG]       no_spaces: "pubmodapp_state;"
[SYNCDOC DEBUG]       -> Does NOT start with #!
[SYNCDOC DEBUG]   -> No bookending needed
[SYNCDOC DEBUG] 
Final result length: 18
[SYNCDOC DEBUG] === BOOKEND DEBUG END ===

[SYNCDOC DEBUG] After bookending: 19
[SYNCDOC DEBUG] 
--- Final Result ---
[SYNCDOC DEBUG] pub mod app_state;

[SYNCDOC DEBUG] === REFORMAT END ===


=== Migration Summary ===
Processed 2 file(s)
Extracted 60 documentation(s)
Touched 3 missing file(s)
Rewrote 2 file(s)
